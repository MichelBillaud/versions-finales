<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="M Billaud" />
  <meta name="dcterms.date" content="2021-07-17" />
  <title>Conteneurs, réalisation en langage C</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <style type="text/css">a.sourceLine {
display: inline-block;
line-height: 1.25;
}
a.sourceLine {
pointer-events: none;
color: inherit;
text-decoration: inherit;
}
a.sourceLine:empty {
height: 1.2em;
}
.sourceCode {
overflow: visible;
}
code.sourceCode {
white-space: pre;
position: relative;
}
div.sourceCode {
margin: 1em 0;
}
pre.sourceCode {
margin: 0;
}
@media screen {
div.sourceCode {
overflow: auto;
}
}
@media print {
code.sourceCode {
white-space: pre-wrap;
}
a.sourceLine {
text-indent: -1em;
padding-left: 1em;
}
}
pre.numberSource a.sourceLine {
position: relative;
left: -4em;
}
pre.numberSource a.sourceLine::before {
content: attr(title);
position: relative;
left: -1em;
text-align: right;
vertical-align: baseline;
border: none;
pointer-events: all;
display: inline-block;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
padding: 0 4px;
width: 4em;
color: #aaaaaa;
}
pre.numberSource {
margin-left: 3em;
border-left: 1px solid #aaaaaa;
padding-left: 4px;
}
div.sourceCode {}
@media screen {
a.sourceLine::before {
text-decoration: underline;
}
}
code span.al {
color: #ff0000;
font-weight: bold;
}

code span.an {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.at {
color: #7d9029;
}

code span.bn {
color: #40a070;
}

code span.bu {}

code span.cf {
color: #007020;
font-weight: bold;
}

code span.ch {
color: #4070a0;
}

code span.cn {
color: #880000;
}

code span.co {
color: #60a0b0;
font-style: italic;
}

code span.cv {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.do {
color: #ba2121;
font-style: italic;
}

code span.dt {
color: #902000;
}

code span.dv {
color: #40a070;
}

code span.er {
color: #ff0000;
font-weight: bold;
}

code span.ex {}

code span.fl {
color: #40a070;
}

code span.fu {
color: #06287e;
}

code span.im {}

code span.in {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.kw {
color: #007020;
font-weight: bold;
}

code span.op {
color: #666666;
}

code span.ot {
color: #007020;
}

code span.pp {
color: #bc7a00;
}

code span.sc {
color: #4070a0;
}

code span.ss {
color: #bb6688;
}

code span.st {
color: #4070a0;
}

code span.va {
color: #19177c;
}

code span.vs {
color: #4070a0;
}

code span.wa {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}


:root {
--title-color: #202080;
--source-bg-color: rgb(240, 240, 255);
}
h1, h2, h3, h4, h5, h6 {
border-bottom: solid 1px silver;
color: var(--title-color);
}
body {
font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}
div.sourceCode {
background-color: var(--source-bg-color);
padding: 1em;
}
#TOC {
padding: 0.5em;
border: solid 1px silver;
}
#TOC ul {
list-style-type: none;
padding-left: 1em;
}
nav:before {
text-indent: 2em;
content: "Sommaire";
color: var(--title-color);
font-weight: bold;
font-size: large;
}
#TOC a {
text-decoration: none;
}
header {
text-align: center;
}
.title {
}
.author, .date {
font-style: italic;
}
table, th, td {
border-collapse: collapse;
border: solid black 1px;
padding: 0.5em;
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Conteneurs, réalisation en langage C</h1>
<p class="author">M Billaud</p>
<p class="date">2021-07-17</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#objectifs-du-document"><span class="toc-section-number">1</span> Objectifs du document</a></li>
<li><a href="#rappels"><span class="toc-section-number">2</span>
Rappels</a>
<ul>
<li><a href="#les-données-en-mémoire"><span class="toc-section-number">2.1</span> Les données en mémoire</a>
<ul>
<li><a href="#taille-des-données-opérateur-sizeof"><span class="toc-section-number">2.1.1</span> Taille des données, opérateur
<code>sizeof()</code></a></li>
<li><a href="#structures-en-mémoire"><span class="toc-section-number">2.1.2</span> Structures en mémoire</a></li>
<li><a href="#adresse-des-données-opérateur"><span class="toc-section-number">2.1.3</span> Adresse des données, opérateur
“<code>&amp;</code>”</a></li>
<li><a href="#tableaux-et-adresses"><span class="toc-section-number">2.1.4</span> Tableaux et adresses</a></li>
</ul></li>
<li><a href="#pointeurs"><span class="toc-section-number">2.2</span>
Pointeurs</a>
<ul>
<li><a href="#déclaration-des-pointeurs"><span class="toc-section-number">2.2.1</span> Déclaration des
pointeurs</a></li>
<li><a href="#pointeurs-non-typés-conversions"><span class="toc-section-number">2.2.2</span> Pointeurs non-typés,
conversions</a></li>
<li><a href="#indirection-opérateur"><span class="toc-section-number">2.2.3</span> Indirection, opérateur
“<code>*</code>”</a></li>
<li><a href="#le-pointeur-null"><span class="toc-section-number">2.2.4</span> Le pointeur
<code>NULL</code></a></li>
<li><a href="#pointeurs-de-structures-notation--"><span class="toc-section-number">2.2.5</span> Pointeurs de structures,
notation “<code>-&gt;</code>”</a></li>
</ul></li>
<li><a href="#passage-de-paramètres"><span class="toc-section-number">2.3</span> Passage de paramètres</a>
<ul>
<li><a href="#pointeur-pour-le-passage-par-référence"><span class="toc-section-number">2.3.1</span> Pointeur pour le passage par
référence</a></li>
<li><a href="#pointeur-pour-éviter-de-copier"><span class="toc-section-number">2.3.2</span> Pointeur pour éviter de
copier</a></li>
<li><a href="#parcours-de-tableau-arithmétique-des-pointeurs"><span class="toc-section-number">2.3.3</span> Parcours de tableau,
arithmétique des pointeurs</a></li>
</ul></li>
<li><a href="#allocation-dynamique"><span class="toc-section-number">2.4</span> Allocation dynamique</a>
<ul>
<li><a href="#attention-danger"><span class="toc-section-number">2.4.1</span> Attention, danger</a></li>
<li><a href="#fonctions-malloc-et-free"><span class="toc-section-number">2.4.2</span> Fonctions <code>malloc()</code>
et <code>free()</code></a></li>
<li><a href="#exercice"><span class="toc-section-number">2.4.3</span>
Exercice :</a></li>
<li><a href="#réallocation-realloc"><span class="toc-section-number">2.4.4</span> Réallocation
(<code>realloc</code>)</a></li>
</ul></li>
</ul></li>
<li><a href="#conteneurs"><span class="toc-section-number">3</span>
Conteneurs</a>
<ul>
<li><a href="#tableaux-extensibles"><span class="toc-section-number">3.1</span> Tableaux extensibles</a>
<ul>
<li><a href="#choix-dune-api-exemple-dutilisation"><span class="toc-section-number">3.1.1</span> Choix d’une API, exemple
d’utilisation</a></li>
<li><a href="#limplémentation"><span class="toc-section-number">3.1.2</span> L’implémentation</a></li>
<li><a href="#strategiedoublement"><span class="toc-section-number">3.1.3</span> Stratégie de doublement de la
capacité</a></li>
</ul></li>
<li><a href="#ensemble-de-chaînes-hachage"><span class="toc-section-number">3.2</span> Ensemble de chaînes, hachage</a>
<ul>
<li><a href="#opérations-de-base"><span class="toc-section-number">3.2.1</span> Opérations de base</a></li>
<li><a href="#idée-générale"><span class="toc-section-number">3.2.2</span> Idée générale</a></li>
<li><a href="#agrandissement-par-doublement"><span class="toc-section-number">3.2.3</span> Agrandissement par
doublement</a></li>
<li><a href="#doublement-et-redistribution"><span class="toc-section-number">3.2.4</span> Doublement et
redistribution</a></li>
<li><a href="#détails-dimplémentation"><span class="toc-section-number">3.2.5</span> Détails
d’implémentation</a></li>
<li><a href="#choix-de-la-fonction-de-hachage"><span class="toc-section-number">3.2.6</span> Choix de la fonction de
hachage</a></li>
<li><a href="#code-source"><span class="toc-section-number">3.2.7</span>
Code source</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="objectifs-du-document"><span class="header-section-number">1</span> Objectifs du document</h1>
<p>Ce document montre les principes de fonctionnement de divers
<strong>conteneurs</strong> (tableau extensible, listes chaînées,
dictionnaire, …) en allant jusqu’aux détails d’implémentation.</p>
<p>Pour aller au niveau le plus bas que permet la portabilité,
l’implémentation est réalisée en C.</p>
<p>Inconvénient du langage C : il ne permet pas la <em>généricité</em>.
C’est-à-dire que si on a écrit le code d’un tableau extensible
d’entiers, il faut tout recommencer pour avoir un tableau extensible de
chaînes, par exemple.</p>
<p>Mais l’objectif ici n’est pas d’obtenir une implémentation
“professionnelle” des conteneurs. En pratique on utilisera des langages
de plus haut niveau, ou des bibliothèques existantes, mais ça ne
dispense pas de comprendre comment ça marche.</p>
<h1 data-number="2" id="rappels"><span class="header-section-number">2</span> Rappels</h1>
<h2 data-number="2.1" id="les-données-en-mémoire"><span class="header-section-number">2.1</span> Les données en mémoire</h2>
<p>Un programme C contient généralement des variables. Pendant
l’exécution, chaque variable est stockée en mémoire quand elle n’est pas
éliminée par le compilateur (ce qui arrive quand il détecte que la
variable est inutile, ou suffisamment temporaire pour être rangée dans
un registre du processeur), dans un <strong>emplacement en
mémoire</strong> formé d’octets consécutifs.</p>
<h3 data-number="2.1.1" id="taille-des-données-opérateur-sizeof"><span class="header-section-number">2.1.1</span> Taille des données, opérateur
<code>sizeof()</code></h3>
<p>Le nombre d’octets (la <strong>taille</strong>) dépend du type de la
variable. On la détermine en appliquant l’opérateur
<code>sizeof()</code> à une variable ou à un type.</p>
<p>Le listing ci-dessous montre un programme qui fait afficher les
tailles de quelques types.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Affichage des tailles de divers types de base.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Les tailles dépendent du compilateur, </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * sauf pour pour char (toujours 1).</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;char</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>   <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">));</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;int</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>    <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;long</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>   <span class="kw">sizeof</span><span class="op">(</span><span class="dt">long</span><span class="op">));</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;float</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>  <span class="kw">sizeof</span><span class="op">(</span><span class="dt">float</span><span class="op">));</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;double</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">));</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Le résultat dépend des choix d’implémentation du compilateur que vous
utilisez, sauf pour le type le type <code>char</code> qui correspond
<strong>toujours</strong> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> à un octet exactement.
<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Exécution du programme :</p>
<pre><code>type    taille
----    ------
char    1
int     4
long    8
float   4
double  8</code></pre>
<p>Par exemple, un <code>int</code> occupe <em>en général</em> 4 octets
sur une machine 32 bits, et 8 octets sur une machine 64 bits.</p>
<p><strong>Remarques :</strong></p>
<ol type="1">
<li><p><code>sizeof()</code> retourne un <code>size_t</code>, type qui
correspond à un entier non signé assez grand pour stocker une taille.
L’implémentation de <code>size_t</code> (<code>unsigned int</code>,
<code>unsigned long</code>, ...) est dépendante de
l’architecture.</p></li>
<li><p>Portabilité : utilisez la spécification de format
<code>%zu</code> pour le type <code>size_t</code>.</p></li>
</ol>
<h3 data-number="2.1.2" id="structures-en-mémoire"><span class="header-section-number">2.1.2</span> Structures en mémoire</h3>
<p>Rappel : une structure contient un ou plusieurs membres (champs) qui
peuvent être de types différents. Exemple de définition d’un type et
d’une variable :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Employe <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> nom<span class="op">[</span><span class="dv">40</span><span class="op">];</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>  age<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Employe cuistot  <span class="op">=</span> <span class="op">{</span> <span class="st">&quot;Maurice&quot;</span><span class="op">,</span> <span class="dv">63</span> <span class="op">};</span></span></code></pre></div>
<p><strong>Exercice :</strong> Écrivez un programme montrant un exemple
de structure dont la taille n’est pas <em>égale</em> à la somme des
tailles des champs.</p>
<h3 data-number="2.1.3" id="adresse-des-données-opérateur"><span class="header-section-number">2.1.3</span> Adresse des données,
opérateur “<code>&amp;</code>”</h3>
<p>Le programme ci-dessous fait afficher les adresses de quelques
variables pendant l’exécution, obtenues en leur appliquant l’opérateur
“<code>&amp;</code>” (<code>address-of</code>)<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> du
langage C.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Affichage d&#39;adresses de variables.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> glob1 <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> glob2 <span class="op">=</span> <span class="dv">34</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> loc1 <span class="op">=</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> loc2 <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;var.</span><span class="sc">\t</span><span class="st">adresse</span><span class="sc">\n</span><span class="st">----</span><span class="sc">\t</span><span class="st">------</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;glob1</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>  <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>  <span class="op">&amp;</span> glob1<span class="op">);</span> </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;glob2</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>  <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>  <span class="op">&amp;</span> glob2<span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;loc1</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>   <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>  <span class="op">&amp;</span> loc1<span class="op">);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;loc2</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>   <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>  <span class="op">&amp;</span> loc2<span class="op">);</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Résultat de l’exécution</p>
<pre><code>var.    adresse
----    ------
glob1   0x5594b04a9038
glob2   0x5594b04a903c
loc1    0x7fffa1c515fc
loc2    0x7fffa1c515f8</code></pre>
<p>Les adresses sont des données typées : par exemple l’adresse d’une
variable de type <code>int</code> est de type <code>int*</code>.
L’affichage se fait avec la spécification “<code>%p</code>&quot; (pour
<em>pointer</em>) en les convertissant en”adresses non-typées”
(<code>void *</code>).</p>
<p><strong>Remarques :</strong></p>
<ul>
<li><p>Les variables globales du programme et les variables locales de
la fonction <code>main()</code> sont dans des “segments” dont les
adresses diffèrent considérablement : le segment de données pour les
variables globales, et le segment de pile pour les autres<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p></li>
<li><p>Sur les systèmes d’exploitation modernes, les adresses virtuelles
qui s’affichent changent à chaque exécution<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p></li>
</ul>
<p><strong>Exercice :</strong> Reprenez l’exemple de structure dont la
taille est supérieure à la somme des tailles des champs, et définissez
une variable de ce type. Faites afficher l’adresse et la taille de la
structure et de chacun de ses champs. Conclusion ?</p>
<h3 data-number="2.1.4" id="tableaux-et-adresses"><span class="header-section-number">2.1.4</span> Tableaux et adresses</h3>
<p>Le programme ci-dessous fait affiche l’adresse d’un tableau et de ses
éléments.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Affichage d&#39;adresses tableaux / éléments</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> tab<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span> <span class="op">};</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;var.</span><span class="sc">\t</span><span class="st">adresse</span><span class="sc">\n</span><span class="st">----</span><span class="sc">\t</span><span class="st">------</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;tab</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>  <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span> tab<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>  </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;tab[%d]</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>  i<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span>  <span class="op">&amp;</span> tab<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Résultat :</p>
<pre><code>var.    adresse
----    ------
tab 0x7ffd7b053230
tab[0]  0x7ffd7b053230
tab[1]  0x7ffd7b053234
tab[2]  0x7ffd7b053238
tab[3]  0x7ffd7b05323c</code></pre>
<p><strong>Remarque :</strong> En C, une variable de type tableau
désigne en fait l’<em>adresse</em> de l’emplacement qui a été réservé en
mémoire pour placer les éléments. Il n’y a dons pas besoin de mettre un
“<code>&amp;</code>” devant <code>tab</code> dans le
<code>printf</code>.</p>
<p>On constate qu’à l’exécution, les éléments se suivent en mémoire, et
l’adresse du tableau correspond à celle du premier élément.</p>
<h2 data-number="2.2" id="pointeurs"><span class="header-section-number">2.2</span> Pointeurs</h2>
<p>On appelle <strong>pointeur</strong><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> une
donnée qui contient une adresse, c’est-à-dire la position d’une (autre)
donnée en mémoire.</p>
<p>On emploie les pointeurs pour diverses raisons, en particulier :</p>
<ul>
<li>le passage de paramètres,</li>
<li>le parcours de tableaux,</li>
<li>la manipulation des données allouées dynamiquement.</li>
</ul>
<h3 data-number="2.2.1" id="déclaration-des-pointeurs"><span class="header-section-number">2.2.1</span> Déclaration des
pointeurs</h3>
<p>Pour <strong>déclarer</strong> un pointeur destiné à contenir des
adresses d’objets de type T, on précède son nom par une étoile. Exemples
:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>pi<span class="op">;</span>               <span class="co">// pointeur sur un int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Personne <span class="op">*</span>pp<span class="op">;</span>   <span class="co">// pointeur sur struct Personne</span></span></code></pre></div>
<p>Pour déclarer un tableau de pointeurs, le nom du tableau est précédé
par une étoile :</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>noms<span class="op">[</span><span class="dv">10</span><span class="op">];</span>  <span class="co">// tableau de 10 pointeurs de caractères</span></span></code></pre></div>
<p>La règle générale est qu’en C, la déclaration d’une variable
ressemble à son usage (voir l’indirection ci-dessous).</p>
<h3 data-number="2.2.2" id="pointeurs-non-typés-conversions"><span class="header-section-number">2.2.2</span> Pointeurs non-typés,
conversions</h3>
<p>Les pointeurs non-typés sont déclarés avec <code>void *</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> entier <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>adresse <span class="op">=</span> <span class="op">&amp;</span> entier<span class="op">;</span>        <span class="co">// pointeur non typé</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;valeur=%d, adresse=%p</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>               entier<span class="op">,</span>      adresse<span class="op">);</span></span></code></pre></div>
<p><strong>Remarque :</strong> l’expression “<code>&amp; entier</code>”
de la seconde ligne est de type <code>int *</code>, mais il y a une
<strong>conversion implicite</strong> entre les adresses typées et
non-typées.</p>
<h3 data-number="2.2.3" id="indirection-opérateur"><span class="header-section-number">2.2.3</span> Indirection, opérateur
“<code>*</code>”</h3>
<p>L’opérateur “<code>*</code>” fournit un accès à la donnée dont
l’adresse est contenue dans un pointeur <strong>typé</strong>. Exemple
:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> nombre <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span> nombre<span class="op">;</span>            <span class="co">// pointeur typé (entiers)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">33</span><span class="op">;</span>                      <span class="co">// modif. à travers p</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;= %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>         <span class="co">// accès indirect</span></span></code></pre></div>
<p><strong>Terminologie :</strong> on dit que</p>
<ul>
<li>la variable <code>nombre</code> <strong>est pointée par</strong>
<code>p</code>.</li>
<li>on fait une <strong>indirection</strong> pour, à partir d’un
pointeur, accéder à la donnée qu’il pointe.</li>
<li>on <strong>dé-référence</strong> le pointeur.</li>
</ul>
<p>*<strong>Remarque :</strong> dans l’exemple d’un tableau de pointeurs
de caractères vu plus haut,</p>
<ul>
<li><p><code>noms[2]</code> est le troisième<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>
pointeur ;</p></li>
<li><p><code>*noms[2]</code> est le <code>char</code> désigné par ce
pointeur.</p></li>
</ul>
<p>Et puisque <code>*noms[i]</code> est un <code>char</code>, dans la
logique de C, il n’est pas anormal que la déclaration d’un tableau de
pointeurs</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span>   <span class="op">*</span>noms<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span></code></pre></div>
<p>ressemble fortement à l’usage qu’on a des éléments.</p>
<h3 data-number="2.2.4" id="le-pointeur-null"><span class="header-section-number">2.2.4</span> Le pointeur
<code>NULL</code></h3>
<p>La constante <code>NULL</code> est une valeur conventionnelle (de
type <code>void*</code> que l’on affecte à un pointeur pour indiquer
qu’il <strong>ne contient pas</strong>, à un moment donné, l’adresse
d’un objet en mémoire. Le pointeur ne pointe sur rien.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>Quand un pointeur contient <code>NULL</code>, tenter de le
dé-référencer est un <strong>comportement indéfini</strong>, qui
provoque généralement un arrêt brutal de l’exécution :</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>p <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>            <span class="co">// crash</span></span></code></pre></div>
<h3 data-number="2.2.5" id="pointeurs-de-structures-notation--"><span class="header-section-number">2.2.5</span> Pointeurs de structures,
notation “<code>-&gt;</code>”</h3>
<p>Selon les règles de priorités d’opérateurs de C, “<code>*a.b</code>”
se lit “<code>*(a.b)</code>”.</p>
<p>La notation <code>pointeur-&gt;champ</code> facilite la désignation
d’un champ d’une structure dont on a l’adresse dans un pointeur. Exemple
:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">*</span>p<span class="op">;</span>  <span class="co">// p pointeur de point</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>p<span class="op">-&gt;</span>x <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span>          <span class="co">// au lieu de  (*p).x = 0.0</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>p<span class="op">-&gt;</span>y <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div>
<h2 data-number="2.3" id="passage-de-paramètres"><span class="header-section-number">2.3</span> Passage de paramètres</h2>
<p>Le langage C ne connaissant que le passage de paramètres <strong>par
valeur</strong>, on utilise des pointeurs pour simuler le “passage de
référence” dans deux situations :</p>
<ol type="1">
<li><p>l’action que l’on veut coder modifie un objet qu’on lui
indique,</p></li>
<li><p>les objets que l’on souhaite transmettre sont assez gros, et pour
des raisons de performance, on veut éviter la copie inhérente à un
passage par valeur.</p></li>
</ol>
<h3 data-number="2.3.1" id="pointeur-pour-le-passage-par-référence"><span class="header-section-number">2.3.1</span> Pointeur pour le passage par
référence</h3>
<p>Exemple : une action consistant à échanger les nombres contenus dans
deux variables. On la traduit par une fonction à qui on passe les
<strong>adresses</strong> des variables à modifier.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> echanger<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>pa<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>pb<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> tmp <span class="op">=</span> <span class="op">*</span>pa<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>pa <span class="op">=</span> <span class="op">*</span>pb<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>pb <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">// usage</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">34</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">23</span><span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>echanger<span class="op">(</span> <span class="op">&amp;</span> a<span class="op">,</span> <span class="op">&amp;</span> b<span class="op">);</span></span></code></pre></div>
<h3 data-number="2.3.2" id="pointeur-pour-éviter-de-copier"><span class="header-section-number">2.3.2</span> Pointeur pour éviter de
copier</h3>
<p>Exemple: affichage d’une structure.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> Personne <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> nom<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> prenom<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">void</span> afficher_personne<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> Personne <span class="op">*</span>p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;nom = %s</span><span class="sc">\n</span><span class="st">&#39;&#39;, p-&gt;nom);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span></code></pre></div>
<p>Le mot-clé <code>const</code> annonce nos intentions. La déclaration
de paramètre se lit de droite à gauche : <code>p</code> est un pointeur
vers une structure <code>Personne</code> qu’on ne modifie pas.</p>
<h3 data-number="2.3.3" id="parcours-de-tableau-arithmétique-des-pointeurs"><span class="header-section-number">2.3.3</span> Parcours de tableau,
arithmétique des pointeurs</h3>
<p>Une chaîne de caractères est un tableau d’octets terminé par un
caractère nul.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> test<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span>  <span class="co">// tableau de _4_ octets</span></span></code></pre></div>
<p>Pour parcourir une chaîne, on peut<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> utiliser un pointeur qui
va désigner tour à tour chaque octet :</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> affiche_codes<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> chaine<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> chaine<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;-&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      p<span class="op">++;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p><strong>Remarques</strong></p>
<ol type="1">
<li><p>Un tableau déclaré en paramètre est en réalité un
pointeur.</p></li>
<li><p>l’incrémentation d’un pointeur (<code>p++]</code>) modifie ce
pointeur pour qu’il désigne l’élément suivant<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p></li>
</ol>
<h2 data-number="2.4" id="allocation-dynamique"><span class="header-section-number">2.4</span> Allocation dynamique</h2>
<p>L’<strong>allocation dynamique de mémoire</strong> est un ensemble de
fonctionnalités mises à la disposition du programmeur d’application par
la bibliothèque standard C.</p>
<p>Elle lui permet de gérer de l’espace mémoire supplémentaire (en plus
de la pile d’exécution et du segment de données) pour y placer des
données, en spécifiant le nombre d’octets voulu. Elle permet aussi de
libérer un espace alloué dont on n’a plus besoin.</p>
<h3 data-number="2.4.1" id="attention-danger"><span class="header-section-number">2.4.1</span> Attention, danger</h3>
<p>L’usage de l’allocation dynamique impose un soin très attentif au
programmeur qui est guetté par deux dangers :</p>
<ul>
<li><p><strong>la fuite mémoire</strong> si un programme alloue en
boucle des zones mémoires, sans les libérer quand il n’en n’a plus
besoin. L’espace mémoire du programme s’agrandit indéfiniment, ce qui
finit mal.</p></li>
<li><p>la <strong>corruption des données</strong> si un programme
utilise par erreur une zone qui a été libérée.</p></li>
</ul>
<p>C’est une difficulté typique de la programmation en C.</p>
<h3 data-number="2.4.2" id="fonctions-malloc-et-free"><span class="header-section-number">2.4.2</span> Fonctions
<code>malloc()</code> et <code>free()</code></h3>
<p>Nous utilisons essentiellement deux fonctions, définies dans
<code>stdlib.h</code> :</p>
<ul>
<li><code>malloc()</code> pour obtenir de l’espace mémoire
supplémentaire,</li>
<li><code>free()</code> pour restituer (libérer) de l’espace obtenu par
<code>malloc()</code>,</li>
</ul>
<p>et occasionnellement <code>realloc()</code> qui agrandit ou rétrécit
un espace qu’on a obtenu, quitte à le déménager ailleurs.</p>
<p>Le listing ci-dessous montre l’utilisation d’un tableau de structures
alloué dynamiquement.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Allocations et libérations. A compléter</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Un tableau de personnes</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Employe <span class="op">{</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> prenom<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>  bureau<span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Employe <span class="op">*</span>nouveauTableau<span class="op">(</span><span class="dt">int</span> nb<span class="op">)</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> Employe <span class="op">*</span>t</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">=</span> malloc<span class="op">(</span>nb <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> Employe<span class="op">));</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>t <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;échec d&#39;allocation&quot;</span><span class="op">);</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    exit <span class="op">(</span>EXIT_FAILURE<span class="op">);</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> t<span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> nbEmployes<span class="op">;</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;Combien d&#39;employés ? &quot;</span><span class="op">);</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>  scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span> nbEmployes<span class="op">);</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> Employe <span class="op">*</span>tableau <span class="op">=</span> nouveauTableau<span class="op">(</span>nbEmployes<span class="op">);</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nb<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>    lire_employe<span class="op">(</span> <span class="op">&amp;</span> tableau<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nb<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    afficher_employe<span class="op">(</span> <span class="op">&amp;</span> tableau<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>  free<span class="op">(</span>tableau<span class="op">);</span>                      <span class="co">// libération</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>  exit <span class="op">(</span>EXIT_SUCCESS<span class="op">);</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pour l’allocation par <code>malloc()</code>, on indique en paramètre
la taille (nombre d’octets) souhaitée. La fonction retourne l’adresse
(non typée) de la zone allouée, ou <code>NULL</code> en cas
d’échec..</p>
<p>Pour libérer une zone, on fournit son adresse à la fonction
<code>free</code>.</p>
<h3 data-number="2.4.3" id="exercice"><span class="header-section-number">2.4.3</span> Exercice :</h3>
<p>Écrire les fonctions manquantes.</p>
<h3 data-number="2.4.4" id="réallocation-realloc"><span class="header-section-number">2.4.4</span> Réallocation
(<code>realloc</code>)</h3>
<p>Si on veut ajouter un employé supplémentaire, il faut agrandir le
tableau. Pour cela on fait un appel à <code>realloc()</code> en
indiquant</p>
<ul>
<li>l’adresse de la zone que l’on veut redimensionner (ici
<code>tableau</code>),</li>
<li>la nouvelle taille</li>
</ul>
<p>et <code>realloc</code> retournera l’adresse de la nouvelle zone
:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>nbElements <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>tableau <span class="op">=</span> realloc<span class="op">(</span>tableau<span class="op">,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                  nbElements <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> Employe<span class="op">));</span></span></code></pre></div>
<p><strong>À savoir :</strong></p>
<ul>
<li><p>si le premier paramètre de <code>realloc</code> est
<code>NULL</code>, la fonction se comporte comme
<code>malloc()</code>,</p></li>
<li><p>vous l’aviez deviné : en cas d’échec, <code>realloc()</code>
retourne <code>NULL</code>.</p></li>
</ul>
<p><strong>Exercice</strong></p>
<p>Écrivez un programme qui</p>
<ul>
<li>part d’un tableau vide,</li>
<li>fait une boucle, en demandant si on veut en ajouter d’autres,</li>
<li>les affiche tous à la fin.</li>
</ul>
<h1 data-number="3" id="conteneurs"><span class="header-section-number">3</span> Conteneurs</h1>
<h2 data-number="3.1" id="tableaux-extensibles"><span class="header-section-number">3.1</span> Tableaux extensibles</h2>
<p>Nous appellons <em>tableau extensible</em> une structure de données
qui sert à stocker des éléments, et qui</p>
<ul>
<li><p>comme un tableau ordinaire, permet de désigner un élément par sa
position (première = 0, seconde = 1, etc.), pour le modifier ou le
consulter.</p></li>
<li><p>à la différence des tableaux, permet d’ajouter des éléments à la
fin sans limite de taille<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p></li>
</ul>
<p>Ici nous allons prendre l’exemple des tableaux extensibles
d’entiers.</p>
<h3 data-number="3.1.1" id="choix-dune-api-exemple-dutilisation"><span class="header-section-number">3.1.1</span> Choix d’une API, exemple
d’utilisation</h3>
<ul>
<li><p>Le type “tableau extensible d’entiers” se matérialise par une
structure appelée <code>tab_int</code>.</p></li>
<li><p>Une famille de fonctions, dont le nom est préfixé par
“<code>ti</code>” représentera les actions qui agissent dessus.</p></li>
<li><p>Le premier paramètre de ces fonctions sera toujours l’adresse du
tableau concerné.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p></li>
</ul>
<p>Le programme suivant montre l’emploi d’un tel tableau :</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;tab_int.h&quot;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> afficher<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>m<span class="op">,</span> <span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">);</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> tab_int tableau<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  ti_init<span class="op">(&amp;</span> tableau<span class="op">);</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">// 10, 20 ... 100</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> v <span class="op">&lt;=</span> <span class="dv">100</span><span class="op">;</span> v <span class="op">+=</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span> </span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    ti_ajouter<span class="op">(&amp;</span> tableau<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  afficher<span class="op">(</span><span class="st">&quot;avant&quot;</span><span class="op">,</span> <span class="op">&amp;</span> tableau<span class="op">);</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>  ti_changer<span class="op">(&amp;</span> tableau<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">421</span><span class="op">);</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  afficher<span class="op">(</span><span class="st">&quot;après&quot;</span><span class="op">,</span> <span class="op">&amp;</span> tableau<span class="op">);</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>  ti_detruire<span class="op">(&amp;</span> tableau<span class="op">);</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>  exit <span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * affiche un message et le contenu d&#39;un tableau</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">m</span><span class="co"> : chaine</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">a</span><span class="co"> : adresse du tableau</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> afficher<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>m<span class="op">,</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>          <span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;%s: &quot;</span><span class="op">,</span> m<span class="op">);</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> taille <span class="op">=</span> ti_taille<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  i <span class="op">&lt;</span> taille<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d &quot;</span><span class="op">,</span> ti_valeur<span class="op">(</span>a<span class="op">,</span> i<span class="op">));</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Il remplit un tableau avec des valeurs de 10 en 10, et modifie l’une
d’elles. Affichage des résultats avant et après modification :</p>
<pre><code>    avant: 10 20 30 40 50 60 70 80 90 100 
    après: 10 20 30 421 50 60 70 80 90 100 </code></pre>
<h3 data-number="3.1.2" id="limplémentation"><span class="header-section-number">3.1.2</span> L’implémentation</h3>
<h4 data-number="3.1.2.1" id="données"><span class="header-section-number">3.1.2.1</span> Données</h4>
<p>Un tableau extensible est représenté par</p>
<ul>
<li><p>un <strong>tableau</strong> alloué dynamiquement, pouvant
accueillir un certain nombre d’éléments (sa
<strong>capacité</strong>),</p></li>
<li><p>un entier indiquant le nombre d’éléments utilisés, au début du
tableau (sa <strong>taille</strong>)</p></li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef TAB_INT_H</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAB_INT_H</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> tab_int <span class="op">{</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>  taille<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>  capacite<span class="op">;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>elements<span class="op">;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_init    <span class="op">(</span>      <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">);</span>          </span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_ajouter <span class="op">(</span>      <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_detruire<span class="op">(</span>      <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>  ti_taille  <span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">);</span> </span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>  ti_valeur  <span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> indice<span class="op">);</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_changer <span class="op">(</span>      <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> indice<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">);</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h4 data-number="3.1.2.2" id="code"><span class="header-section-number">3.1.2.2</span> Code</h4>
<p>Le code comporte quelques choix d’implémentation :</p>
<ul>
<li><p>la capacité initiale, lorsqu’on initialise un tableau extensible
(ici, 4 éléments)</p></li>
<li><p>la stratégie d’agrandissement en cas de débordement. Ici on
double : l’ajout du 5ième élément ré-alloue le tableau avec une capacité
de 8, et l’ajout du 8ième porte la capacité à 16. Cette stratégie est
justifiée plus loin.</p></li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;tab_int.h&quot;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CAPACITE_MINIMALE 4</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_init <span class="op">(</span><span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>taille <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>capacite <span class="op">=</span> CAPACITE_MINIMALE<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// </span><span class="al">NOTE</span><span class="co"> : on devrait vérifier le résultat de malloc</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>elements <span class="op">=</span> malloc<span class="op">(</span>a<span class="op">-&gt;</span>capacite <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_ajouter<span class="op">(</span><span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// si plein, agrandir</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>a<span class="op">-&gt;</span>taille <span class="op">==</span> a<span class="op">-&gt;</span>capacite<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>capacite <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">NOTE</span><span class="co"> : on devrait vérifier le résultat de realloc    </span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>elements <span class="op">=</span> realloc<span class="op">(</span>a<span class="op">-&gt;</span>elements<span class="op">,</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>              a<span class="op">-&gt;</span>capacite <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ajout à la fin</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>elements<span class="op">[</span>a<span class="op">-&gt;</span>taille<span class="op">]</span> <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span> taille <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_detruire<span class="op">(</span><span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>taille <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>capacite <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>  free<span class="op">(</span>a<span class="op">-&gt;</span>elements<span class="op">);</span></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>  a <span class="op">-&gt;</span> elements <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ti_taille<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">)</span> </span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a<span class="op">-&gt;</span>taille<span class="op">;</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="co">// les indices doivent être entre 0  et a-&gt;taille - 1</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ti_valeur<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> indice<span class="op">)</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a<span class="op">-&gt;</span>elements<span class="op">[</span>indice<span class="op">];</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ti_changer<span class="op">(</span><span class="kw">struct</span> tab_int <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> indice<span class="op">,</span></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> valeur<span class="op">)</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a>  a<span class="op">-&gt;</span>elements<span class="op">[</span>indice<span class="op">]</span> <span class="op">=</span> valeur<span class="op">;</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="3.1.3" id="strategiedoublement"><span class="header-section-number">3.1.3</span> Stratégie de doublement de la
capacité</h3>
<p>Lorsque le tableau est plein, on le ré-alloue avec une capacité
supérieure.</p>
<p>La stratégie de doublement de cette capacité est, contrairement à ce
que suggère l’intuition (souvent trompeuse pour ce genre de choses),
<strong>très efficace</strong> en terme de nombre de copies : au cours
du remplissage, chaque élément a été copié <strong>au plus une
fois</strong> en moyenne.</p>
<p>Raisonnement pour s’en convaincre :</p>
<ol type="1">
<li>Imaginons qu’à un moment le <em>vector</em> ait grandi jusqu’à 500
éléments. Comme le tableau grandit en doublant de taille, sa capacité
est la première puissance de 2 supérieure à 500, soit 512.</li>
<li>Le tableau sera agrandi (et ré-alloué) en ajoutant le 513ieme, sa
capacité passera à 1024 éléments, et pour cela il faudra ré-allouer ce
qui provoquera la copie des 512 éléments existants. Coût : 512, si on
prend comme unité de compte la copie d’un élément.</li>
<li>Mais pour arriver à 513, il avait fallu copier 256 éléments. Et pour
arriver à 257, en copier 128.</li>
<li>Si on fait le total, si on en est au 513-ième élément ajouté (et
jusqu’au 1024-ième) on a fait en tout <span class="math inline">256 + 128 + 64 + ...</span> copies d’éléments, ce
qui est plus petit que 512.</li>
</ol>
<p>Conclusion : Dans le pire des cas (ajout du 513 ième), le coût moyen
d’ajout d’un élément est inférieur à <span class="math inline">512/513</span> : il y a donc eu <strong>moins d’une
copie par élément</strong>.</p>
<p><strong>Exercice :</strong> En général la première idée qui vient est
d’augmenter d’une unité la capacité à chaque ajout. Évaluez le coût de
cette stratégie.</p>
<h2 data-number="3.2" id="ensemble-de-chaînes-hachage"><span class="header-section-number">3.2</span> Ensemble de chaînes,
hachage</h2>
<p>Dans cette partie, nous montrons comment représenter
<strong>efficacement</strong> un ensemble<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>
de chaînes de caractères en utilisant une <strong>fonction de
hachage</strong>.</p>
<h3 data-number="3.2.1" id="opérations-de-base"><span class="header-section-number">3.2.1</span> Opérations de base</h3>
<p>Les opérations de base sur cet ensemble :</p>
<ul>
<li>l’initialiser,</li>
<li>y ajouter un élément (si il n’y est pas déjà),</li>
<li>savoir combien il y a d’éléments dans l’ensemble,</li>
<li>tester si un élément est présent,</li>
<li>enlever un élément,</li>
<li>libérer les ressources utilisées.</li>
</ul>
<p>Ci-dessous un exemple d’utilisation où l’on ajoute une suite de mots
(éventuellement en plusieurs exemplaires) et on fait afficher la taille
(qui doit être 10).</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;ens_chaines.h&quot;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_chaines ensemble<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    ec_init<span class="op">(&amp;</span> ensemble<span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>mots<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;un&quot;</span><span class="op">,</span> <span class="st">&quot;deux&quot;</span><span class="op">,</span> <span class="st">&quot;trois&quot;</span><span class="op">,</span> <span class="st">&quot;un&quot;</span><span class="op">,</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;quatre&quot;</span><span class="op">,</span> <span class="st">&quot;deux&quot;</span><span class="op">,</span> <span class="st">&quot;cinq&quot;</span><span class="op">,</span> <span class="st">&quot;six&quot;</span><span class="op">,</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;sept&quot;</span><span class="op">,</span> <span class="st">&quot;trois&quot;</span><span class="op">,</span> <span class="st">&quot;huit&quot;</span><span class="op">,</span> <span class="st">&quot;neuf&quot;</span><span class="op">,</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;dix&quot;</span><span class="op">,</span> <span class="st">&quot;trois&quot;</span><span class="op">,</span> <span class="st">&quot;sept&quot;</span><span class="op">,</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        NULL</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> mots<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> NULL<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        ec_ajouter<span class="op">(&amp;</span> ensemble<span class="op">,</span> mots<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;-&gt; taille %d (attendu = 10)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>            ec_taille<span class="op">(&amp;</span> ensemble<span class="op">));</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    ec_dump<span class="op">(&amp;</span> ensemble<span class="op">);</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    ec_liberer<span class="op">(&amp;</span> ensemble<span class="op">);</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> EXIT_SUCCESS<span class="op">;</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Le programme affiche également le contenu interne de l’ensemble de
chaînes, ce qui nous facilitera les explications.</p>
<pre><code>-&gt; taille 10 (attendu = 10)
0 -&gt;
1 -&gt;    &quot;trois&quot; (10282497)
2 -&gt;    &quot;quatre&quot; (170727922)
3 -&gt;    &quot;un&quot; (2099)
4 -&gt;    &quot;six&quot; (35140)
5 -&gt;    &quot;dix&quot; (30805)
6 -&gt;    &quot;deux&quot; (522598)
7 -&gt;
8 -&gt;
9 -&gt;
10 -&gt;   &quot;huit&quot; (546666)
11 -&gt;   &quot;cinq&quot; (518715)
12 -&gt;   &quot;sept&quot; (596204)
13 -&gt;
14 -&gt;   &quot;neuf&quot; (571710)
15 -&gt;</code></pre>
<p>Nous ne présenterons que quelques opérations, les autres sont
laissées en exercice.</p>
<h3 data-number="3.2.2" id="idée-générale"><span class="header-section-number">3.2.2</span> Idée générale</h3>
<h4 data-number="3.2.2.1" id="répartition-en-alvéoles"><span class="header-section-number">3.2.2.1</span> Répartition en
alvéoles</h4>
<ul>
<li><p>les chaînes de caractères qui font partie de l’ensemble sont
réparties dans des “alvéoles”.</p></li>
<li><p>les alvéoles forment un tableau, ce qui permet un accès rapide
par indice.</p></li>
<li><p>le numéro de l’alvéole dans laquelle se trouve (ou devrait se
trouver) une chaîne de caractères est calculé à partir du contenu de
cette chaîne, par ce qu’on appelle une <strong>fonction de
hachage</strong>.</p></li>
<li><p>plus précisément, le numéro d’alvéole s’obtient comme reste
(opération modulo) de la division de la valeur du hachage par le nombre
d’alvéoles.</p></li>
</ul>
<p><strong>Intérêt :</strong> La répartition en alvéoles permet de
diviser le nombre de comparaisons nécessaires pour tester la présence
d’une chaîne : on ne regarde que celles présentes dans son alvéole.</p>
<p><strong>Dans l’idéal,</strong> la fonction de hachage serait
parfaite, et conduirait à une alvéole où ne se trouve qu’une chaîne.</p>
<p><strong>En pratique,</strong> on pourra avoir plusieurs chaînes dans
certaines alvéoles. On va donc :</p>
<ul>
<li>prévoir qu’une alvéole contient une <code>liste</code> de
chaînes,</li>
<li>avoir un grand nombre d’alvéoles de façon à avoir statistiquement
peu de chaînes par alvéole.</li>
</ul>
<h3 data-number="3.2.3" id="agrandissement-par-doublement"><span class="header-section-number">3.2.3</span> Agrandissement par
doublement</h3>
<p>La stratégie choisie est de doubler le nombre d’alvéoles quand le
nombre de chaînes présentes dans l’ensemble atteint certain seuil (3/4
du nombre d’alvéoles). Les chaînes sont alors redistribuées entre les
alvéoles.</p>
<p>Le respect de ce seuil garantit qu’il a au maximum 0.75 chaînes par
alvéole. Il y aura donc peu d’alvéoles avec plus d’une chaîne.</p>
<p>Comme pour les tableaux extensibles, la stratégie de doublement fait
qu’en moyenne chaque alvéole est copiée au plus une fois.</p>
<h3 data-number="3.2.4" id="doublement-et-redistribution"><span class="header-section-number">3.2.4</span> Doublement et
redistribution</h3>
<p>Le doublement a une autre propriété intéressante. Quand on
redistribue les chaînes d’une alvéole,</p>
<ul>
<li><p>soit elles restent dans la même alvéole,</p></li>
<li><p>soit elles vont dans une alvéole “jumelle” qui vient d’être
ajoutée.</p></li>
</ul>
<p><strong>Exemple :</strong> pour la chaîne <code>&quot;dix&quot;</code>, la
fonction de hachage vaut 30805.</p>
<ul>
<li><p>Si il y a 4 alvéoles, elle se trouve dans l’alvéole <span class="math inline">30805 % 4 = 1</span>.</p></li>
<li><p>En passant à 8 alvéoles, elle va dans la nouvelle alvéole <span class="math inline">30805 % 8 = 5 = 4 + 1</span>.</p></li>
<li><p>En passant à 16, elle reste en <span class="math inline">30805 % 16 = 5</span>.</p></li>
<li><p>En passant à 32, elle va en <span class="math inline">30805 % 32 = 21 = 16 + 5</span>.</p></li>
<li><p>etc.</p></li>
</ul>
<p>Ceci nous autorise à redistribuer les chaînes en traitant les
anciennes alvéoles une par une : on est sûr de ne pas avoir à déplacer
chaque chaîne plus d’une fois.</p>
<h3 data-number="3.2.5" id="détails-dimplémentation"><span class="header-section-number">3.2.5</span> Détails d’implémentation</h3>
<h4 data-number="3.2.5.1" id="sémantique-de-valeur-pour-les-chaînes"><span class="header-section-number">3.2.5.1</span> Sémantique de valeur pour
les chaînes</h4>
<p>Lorsqu’on appelle la fonction qui sert à ajouter une chaîne, ce qu’on
veut c’est ajouter le contenu de la chaîne. Pour cela on ne peut pas se
contenter de stocker l’adresse de la chaîne reçue, il faut en faire une
copie.</p>
<p>Ci-dessous une erreur classique de programmation en C : si on fait
ensuite afficher le tableau, on s’aperçoit qu’il ne contient pas ce
qu’on pense y avoir mis :</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span>joueurs<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> nom<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;donnez un nom :&quot;</span><span class="op">);</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%s&quot;</span><span class="op">,</span> nom<span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    joueurs<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nom<span class="op">;</span>       <span class="co">// une erreur de débutant</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>puisqu’on a stocké 10 fois l’adresse de la même variable locale
<code>nom</code>…</p>
<p>Lors de l’ajout d’une chaîne, on stocke donc en réalité <em>une
copie</em> obtenue par <code>strdup()</code>. Cette copie est une
ressource appartenant à l’ensemble, et sera libérée quand</p>
<ul>
<li><p>on retire une chaîne de l’ensemble</p></li>
<li><p>on libère l’ensemble</p></li>
</ul>
<h4 data-number="3.2.5.2" id="structure-des-alvéoles"><span class="header-section-number">3.2.5.2</span> Structure des alvéoles</h4>
<p>Nous choisissons de représenter les alvéoles, qui en principe ne
contiendront que peu d’éléments (moins de <span class="math inline">0.75</span> en moyenne), par des <strong>listes
chaînées non ordonnées</strong>.</p>
<h3 data-number="3.2.6" id="choix-de-la-fonction-de-hachage"><span class="header-section-number">3.2.6</span> Choix de la fonction de
hachage</h3>
<p>Une fonction de hachage retourne un nombre non signé, parce qu’elle
sert à calculer un indice (entier positif ou nul) comme reste d’une
division entière.</p>
<p>Ce modulo (par une puissance de 2) fait qu’on utilise comme indice
les bits de poids faible de la valeur retournée. Il est important que
ces bits soient, autant que possible, dépendants de tous les caractères
de la chaîne.</p>
<p>Un contre-exemple pour illustrer cette notion. Si le hachage était
calculé ainsi</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>c <span class="op">=</span> chaine<span class="op">;</span> <span class="op">*</span>c <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="dv">16</span> <span class="op">*</span> hash <span class="op">+</span> <span class="op">*</span>c<span class="op">;</span>               <span class="co">// mauvais</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>à cause du décalage produit par la multiplication par 16, les 4 bits
de droite ne dépendraient que du dernier caractère de la chaîne; les 8
bits de droite des deux derniers, etc. Les chaînes <code>&quot;sept&quot;</code>
et <code>&quot;huit&quot;</code> se retrouveraient toujours dans la même alvéole,
pour les ensembles qui ont moins de 256 alvéoles. Idem pour
<code>&quot;six&quot;</code> et <code>&quot;dix&quot;</code>. Et à partir d’une certaine
taille, les premiers octets de la chaîne seront sans influence sur le
résultat (ils seront perdus dans le débordement).</p>
<p>La multiplication par 17 (= 16 + 1) garantit que chaque octet de la
chaîne a une influence sur les bits de poids faible du résultat de la
fonction de hachage.</p>
<h3 data-number="3.2.7" id="code-source"><span class="header-section-number">3.2.7</span> Code source</h3>
<p><strong>Entête</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ens_chaines.h</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifndef ENS_CHAINE_H</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ENS_CHAINE_H</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ens_alveole<span class="op">;</span>            <span class="co">// prédéclaration</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ens_chaines <span class="op">{</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nb_alveoles<span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nb_elements<span class="op">;</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_alveole <span class="op">*</span>alveoles<span class="op">;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_init   <span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">);</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_ajouter<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">,</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>chaine<span class="op">);</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ec_taille  <span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">);</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_dump   <span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">);</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_liberer<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">);</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p><strong>Code</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;ens_chaines.h&quot;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ens_cellule <span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span> chaine<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_cellule <span class="op">*</span>suivant<span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ens_alveole <span class="op">{</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_cellule <span class="op">*</span>premier<span class="op">;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NOMBRE_MIN_ALVEOLES 4</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_init<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">)</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_elements <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_alveoles <span class="op">=</span> NOMBRE_MIN_ALVEOLES<span class="op">;</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>alveoles <span class="op">=</span> malloc<span class="op">(</span>e<span class="op">-&gt;</span>nb_alveoles</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>             <span class="op">*</span> <span class="kw">sizeof</span> <span class="op">(</span><span class="kw">struct</span> ens_alveole<span class="op">));</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> ec_hash<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> chaine<span class="op">)</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>c <span class="op">=</span> chaine<span class="op">;</span> <span class="op">*</span>c <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>        hash <span class="op">=</span> <span class="dv">17</span> <span class="op">*</span> hash <span class="op">+</span> <span class="op">*</span>c<span class="op">;</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hash<span class="op">;</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">void</span> ec_doubler_nb_alveoles<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">)</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> na <span class="op">=</span> e<span class="op">-&gt;</span>nb_alveoles<span class="op">;</span> <span class="co">// avant agrandissement</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_alveoles <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> taille <span class="op">=</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_alveoles <span class="op">*</span> <span class="kw">sizeof</span> <span class="op">(</span><span class="kw">struct</span> ens_alveole<span class="op">);</span> </span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>alveoles <span class="op">=</span> realloc<span class="op">(</span>e<span class="op">-&gt;</span>alveoles<span class="op">,</span> taille<span class="op">);</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// initialisation de nouvelles alvéoles</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> na<span class="op">;</span> i <span class="op">&lt;</span> e<span class="op">-&gt;</span>nb_alveoles<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>        e<span class="op">-&gt;</span>alveoles<span class="op">[</span>i<span class="op">].</span>premier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// reclassement des éléments des anciennes alvéoles</span></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> na<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> ens_cellule <span class="op">*</span>premier</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> e<span class="op">-&gt;</span>alveoles<span class="op">[</span>i<span class="op">].</span>premier<span class="op">;</span></span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>        e<span class="op">-&gt;</span>alveoles<span class="op">[</span>i<span class="op">].</span>premier <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>premier <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> ens_cellule <span class="op">*</span>c <span class="op">=</span> premier<span class="op">;</span></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>            premier <span class="op">=</span> premier<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> num_alveole</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> ec_hash<span class="op">(</span>c<span class="op">-&gt;</span>chaine<span class="op">)</span> <span class="op">%</span> <span class="op">(</span>e<span class="op">-&gt;</span>nb_alveoles<span class="op">);</span></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> ens_alveole <span class="op">*</span>a</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> <span class="op">&amp;(</span> e<span class="op">-&gt;</span>alveoles<span class="op">[</span>num_alveole<span class="op">]</span> <span class="op">);</span></span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>            c<span class="op">-&gt;</span>suivant <span class="op">=</span> a<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>            a<span class="op">-&gt;</span>premier <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_ajouter<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>chaine<span class="op">)</span></span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_alveole <span class="op">=</span> ec_hash<span class="op">(</span>chaine<span class="op">)</span> <span class="op">%</span> <span class="op">(</span>e<span class="op">-&gt;</span>nb_alveoles<span class="op">);</span></span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_alveole <span class="op">*</span> a <span class="op">=</span> <span class="op">&amp;(</span>e<span class="op">-&gt;</span>alveoles<span class="op">[</span>num_alveole<span class="op">]);</span></span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sortie si déjà present</span></span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">struct</span> ens_cellule <span class="op">*</span>c <span class="op">=</span> a<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a>     c <span class="op">!=</span> NULL<span class="op">;</span></span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a>     c <span class="op">=</span> c<span class="op">-&gt;</span>suivant<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>strcmp<span class="op">(</span>c<span class="op">-&gt;</span>chaine<span class="op">,</span> chaine<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ajout nouvelle cellule avec copie de chaîne</span></span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ens_cellule <span class="op">*</span>nc</span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">(</span><span class="kw">struct</span> ens_cellule<span class="op">));</span></span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a>    nc<span class="op">-&gt;</span>chaine <span class="op">=</span> strdup<span class="op">(</span>chaine<span class="op">);</span></span>
<span id="cb30-89"><a href="#cb30-89" aria-hidden="true" tabindex="-1"></a>    nc<span class="op">-&gt;</span>suivant <span class="op">=</span> a<span class="op">-&gt;</span>premier<span class="op">;</span></span>
<span id="cb30-90"><a href="#cb30-90" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>premier <span class="op">=</span> nc<span class="op">;</span></span>
<span id="cb30-91"><a href="#cb30-91" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_elements <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb30-92"><a href="#cb30-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-93"><a href="#cb30-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">// besoin d&#39;agrandir ?</span></span>
<span id="cb30-94"><a href="#cb30-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>e<span class="op">-&gt;</span>nb_elements <span class="op">&gt;=</span> <span class="op">(</span><span class="dv">3</span> <span class="op">*</span> e<span class="op">-&gt;</span>nb_alveoles<span class="op">)</span> <span class="op">/</span> <span class="dv">4</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-95"><a href="#cb30-95" aria-hidden="true" tabindex="-1"></a>        ec_doubler_nb_alveoles<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb30-96"><a href="#cb30-96" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-97"><a href="#cb30-97" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-98"><a href="#cb30-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-99"><a href="#cb30-99" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_liberer<span class="op">(</span><span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">)</span></span>
<span id="cb30-100"><a href="#cb30-100" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-101"><a href="#cb30-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> e<span class="op">-&gt;</span>nb_alveoles<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-102"><a href="#cb30-102" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> ens_cellule <span class="op">*</span>premier</span>
<span id="cb30-103"><a href="#cb30-103" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> e<span class="op">-&gt;</span>alveoles<span class="op">[</span>i<span class="op">].</span>premier<span class="op">;</span></span>
<span id="cb30-104"><a href="#cb30-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>premier <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-105"><a href="#cb30-105" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> ens_cellule <span class="op">*</span>c <span class="op">=</span> premier<span class="op">;</span></span>
<span id="cb30-106"><a href="#cb30-106" aria-hidden="true" tabindex="-1"></a>            premier <span class="op">=</span> premier<span class="op">-&gt;</span>suivant<span class="op">;</span></span>
<span id="cb30-107"><a href="#cb30-107" aria-hidden="true" tabindex="-1"></a>            free<span class="op">(</span>c<span class="op">-&gt;</span>chaine<span class="op">);</span></span>
<span id="cb30-108"><a href="#cb30-108" aria-hidden="true" tabindex="-1"></a>            free<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb30-109"><a href="#cb30-109" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-110"><a href="#cb30-110" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-111"><a href="#cb30-111" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>e<span class="op">-&gt;</span>alveoles<span class="op">);</span></span>
<span id="cb30-112"><a href="#cb30-112" aria-hidden="true" tabindex="-1"></a>    <span class="co">// par précaution </span></span>
<span id="cb30-113"><a href="#cb30-113" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_alveoles <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-114"><a href="#cb30-114" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>nb_elements <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-115"><a href="#cb30-115" aria-hidden="true" tabindex="-1"></a>    e<span class="op">-&gt;</span>alveoles <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb30-116"><a href="#cb30-116" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-117"><a href="#cb30-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-118"><a href="#cb30-118" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ec_taille<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">)</span></span>
<span id="cb30-119"><a href="#cb30-119" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-120"><a href="#cb30-120" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> e<span class="op">-&gt;</span>nb_elements<span class="op">;</span></span>
<span id="cb30-121"><a href="#cb30-121" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-122"><a href="#cb30-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-123"><a href="#cb30-123" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ec_dump<span class="op">(</span><span class="dt">const</span> <span class="kw">struct</span> ens_chaines <span class="op">*</span>e<span class="op">)</span></span>
<span id="cb30-124"><a href="#cb30-124" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-125"><a href="#cb30-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> e<span class="op">-&gt;</span>nb_alveoles<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb30-126"><a href="#cb30-126" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%d -&gt;&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb30-127"><a href="#cb30-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">struct</span> ens_cellule <span class="op">*</span>c <span class="op">=</span> e<span class="op">-&gt;</span>alveoles<span class="op">[</span>i<span class="op">].</span>premier<span class="op">;</span></span>
<span id="cb30-128"><a href="#cb30-128" aria-hidden="true" tabindex="-1"></a>                c <span class="op">!=</span> NULL<span class="op">;</span></span>
<span id="cb30-129"><a href="#cb30-129" aria-hidden="true" tabindex="-1"></a>                c <span class="op">=</span> c<span class="op">-&gt;</span>suivant<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-130"><a href="#cb30-130" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\t\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st"> (%u)&quot;</span><span class="op">,</span></span>
<span id="cb30-131"><a href="#cb30-131" aria-hidden="true" tabindex="-1"></a>                c<span class="op">-&gt;</span>chaine<span class="op">,</span></span>
<span id="cb30-132"><a href="#cb30-132" aria-hidden="true" tabindex="-1"></a>                ec_hash<span class="op">(</span>c<span class="op">-&gt;</span>chaine<span class="op">));</span></span>
<span id="cb30-133"><a href="#cb30-133" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-134"><a href="#cb30-134" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb30-135"><a href="#cb30-135" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-136"><a href="#cb30-136" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Presque toujours. Il y a des
complications sur les machines dont les mots sont de 36 bits, etc.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Il a été nommé <code>char</code> à
une époque où le codage d’un caractère tenait toujours sur un octet
(codages ANSI, EBCDIC, ...). Si c’était à refaire, ce type s’appellerait
certainement <code>byte</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Il s’agit ici des <em>adresses
virtuelles</em>, dans l’espace mémoire où le système a chargé le
processus.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Sur une machine qui supporte la
notion de segmentation, évidemment. Ce n’est pas le cas des petits
micro-contrôleurs dans le domaine de l’informatique embarquée<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>C’est une mesure de sécurité pour
éviter l’exploitation de “débordements de tampon” et autres erreurs de
programmation. Lors du chargement d’un programme, le système
d’exploitation choisit des adresses aléatoires pour placer les segments
dans l’espace mémoire virtuel du processus.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Ce terme est aussi (hélas) souvent
employé par extension pour désigner les adresses elles-mêmes. Nous
essaierons d’éviter ce regrettable manque de rigueur, source de
confusions, qui permettrait d’écrire qu’un pointeur (au sens de
variable) <em>contient</em> un pointeur (au sens d’adresse)…<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>le premier a l’indice 0...<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Ne pas confondre avec un pointeur
non-initialisé, qui contient une valeur aléatoire<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>à la place d’un indice<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>la valeur numérique du pointeur -
celle qu’on voit avec <code>printf</code> - est augmentée de la taille
du type pointé (ici 1, parce que c’est un <code>char</code>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>autre que les limitations de
l’allocation dynamique<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>pour les deux raisons évoquées plus
haut : - c’est obligatoire pour les fonctions qui modifient le tableau -
c’est souhaitable pour les autres, pour éviter de faire des copies. Dans
ce cas on mettra un <code>const</code>.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>fini, donné par extension<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
