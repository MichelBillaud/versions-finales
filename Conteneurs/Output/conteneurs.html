<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="M Billaud" />
  <meta name="dcterms.date" content="2021-07-17" />
  <title>Conteneurs, réalisation en langage C</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">a.sourceLine {
display: inline-block;
line-height: 1.25;
}
a.sourceLine {
pointer-events: none;
color: inherit;
text-decoration: inherit;
}
a.sourceLine:empty {
height: 1.2em;
}
.sourceCode {
overflow: visible;
}
code.sourceCode {
white-space: pre;
position: relative;
}
div.sourceCode {
margin: 1em 0;
}
pre.sourceCode {
margin: 0;
}
@media screen {
div.sourceCode {
overflow: auto;
}
}
@media print {
code.sourceCode {
white-space: pre-wrap;
}
a.sourceLine {
text-indent: -1em;
padding-left: 1em;
}
}
pre.numberSource a.sourceLine {
position: relative;
left: -4em;
}
pre.numberSource a.sourceLine::before {
content: attr(title);
position: relative;
left: -1em;
text-align: right;
vertical-align: baseline;
border: none;
pointer-events: all;
display: inline-block;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
padding: 0 4px;
width: 4em;
color: #aaaaaa;
}
pre.numberSource {
margin-left: 3em;
border-left: 1px solid #aaaaaa;
padding-left: 4px;
}
div.sourceCode {}
@media screen {
a.sourceLine::before {
text-decoration: underline;
}
}
code span.al {
color: #ff0000;
font-weight: bold;
}

code span.an {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.at {
color: #7d9029;
}

code span.bn {
color: #40a070;
}

code span.bu {}

code span.cf {
color: #007020;
font-weight: bold;
}

code span.ch {
color: #4070a0;
}

code span.cn {
color: #880000;
}

code span.co {
color: #60a0b0;
font-style: italic;
}

code span.cv {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.do {
color: #ba2121;
font-style: italic;
}

code span.dt {
color: #902000;
}

code span.dv {
color: #40a070;
}

code span.er {
color: #ff0000;
font-weight: bold;
}

code span.ex {}

code span.fl {
color: #40a070;
}

code span.fu {
color: #06287e;
}

code span.im {}

code span.in {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.kw {
color: #007020;
font-weight: bold;
}

code span.op {
color: #666666;
}

code span.ot {
color: #007020;
}

code span.pp {
color: #bc7a00;
}

code span.sc {
color: #4070a0;
}

code span.ss {
color: #bb6688;
}

code span.st {
color: #4070a0;
}

code span.va {
color: #19177c;
}

code span.vs {
color: #4070a0;
}

code span.wa {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}


:root {
--title-color: #202080;
--source-bg-color: rgb(240, 240, 255);
}
h1, h2, h3, h4, h5, h6 {
border-bottom: solid 1px silver;
color: var(--title-color);
}
body {
font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}
div.sourceCode {
background-color: var(--source-bg-color);
padding: 1em;
}
#TOC {
padding: 0.5em;
border: solid 1px silver;
}
#TOC ul {
list-style-type: none;
padding-left: 1em;
}
nav:before {
text-indent: 2em;
content: "Sommaire";
color: var(--title-color);
font-weight: bold;
font-size: large;
}
#TOC a {
text-decoration: none;
}
header {
text-align: center;
}
.title {
}
.author, .date {
font-style: italic;
}
table, th, td {
border-collapse: collapse;
border: solid black 1px;
padding: 0.5em;
}
</style>
</head>
<body>
<header>
<h1 class="title">Conteneurs, réalisation en langage C</h1>
<p class="author">M Billaud</p>
<p class="date">2021-07-17</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#objectifs-du-document"><span class="toc-section-number">1</span> Objectifs du document</a></li>
<li><a href="#rappels"><span class="toc-section-number">2</span> Rappels</a><ul>
<li><a href="#les-données-en-mémoire"><span class="toc-section-number">2.1</span> Les données en mémoire</a><ul>
<li><a href="#taille-des-données-opérateur-sizeof"><span class="toc-section-number">2.1.1</span> Taille des données, opérateur <code>sizeof()</code></a></li>
<li><a href="#structures-en-mémoire"><span class="toc-section-number">2.1.2</span> Structures en mémoire</a></li>
<li><a href="#adresse-des-données-opérateur"><span class="toc-section-number">2.1.3</span> Adresse des données, opérateur “<code>&amp;</code>”</a></li>
<li><a href="#tableaux-et-adresses"><span class="toc-section-number">2.1.4</span> Tableaux et adresses</a></li>
</ul></li>
<li><a href="#pointeurs"><span class="toc-section-number">2.2</span> Pointeurs</a><ul>
<li><a href="#déclaration-des-pointeurs"><span class="toc-section-number">2.2.1</span> Déclaration des pointeurs</a></li>
<li><a href="#pointeurs-non-typés-conversions"><span class="toc-section-number">2.2.2</span> Pointeurs non-typés, conversions</a></li>
<li><a href="#indirection-opérateur"><span class="toc-section-number">2.2.3</span> Indirection, opérateur “<code>*</code>”</a></li>
<li><a href="#le-pointeur-null"><span class="toc-section-number">2.2.4</span> Le pointeur <code>NULL</code></a></li>
<li><a href="#pointeurs-de-structures-notation--"><span class="toc-section-number">2.2.5</span> Pointeurs de structures, notation “<code>-&gt;</code>”</a></li>
</ul></li>
<li><a href="#passage-de-paramètres"><span class="toc-section-number">2.3</span> Passage de paramètres</a><ul>
<li><a href="#pointeur-pour-le-passage-par-référence"><span class="toc-section-number">2.3.1</span> Pointeur pour le passage par référence</a></li>
<li><a href="#pointeur-pour-éviter-de-copier"><span class="toc-section-number">2.3.2</span> Pointeur pour éviter de copier</a></li>
<li><a href="#parcours-de-tableau-arithmétique-des-pointeurs"><span class="toc-section-number">2.3.3</span> Parcours de tableau, arithmétique des pointeurs</a></li>
</ul></li>
<li><a href="#allocation-dynamique"><span class="toc-section-number">2.4</span> Allocation dynamique</a><ul>
<li><a href="#attention-danger"><span class="toc-section-number">2.4.1</span> Attention, danger</a></li>
<li><a href="#fonctions-malloc-et-free"><span class="toc-section-number">2.4.2</span> Fonctions <code>malloc()</code> et <code>free()</code></a></li>
<li><a href="#exercice"><span class="toc-section-number">2.4.3</span> Exercice :</a></li>
<li><a href="#réallocation-realloc"><span class="toc-section-number">2.4.4</span> Réallocation (<code>realloc</code>)</a></li>
</ul></li>
</ul></li>
<li><a href="#conteneurs"><span class="toc-section-number">3</span> Conteneurs</a><ul>
<li><a href="#tableaux-extensibles"><span class="toc-section-number">3.1</span> Tableaux extensibles</a><ul>
<li><a href="#choix-dune-api-exemple-dutilisation"><span class="toc-section-number">3.1.1</span> Choix d’une API, exemple d’utilisation</a></li>
<li><a href="#limplémentation"><span class="toc-section-number">3.1.2</span> L’implémentation</a></li>
<li><a href="#strategiedoublement"><span class="toc-section-number">3.1.3</span> Stratégie de doublement de la capacité</a></li>
</ul></li>
<li><a href="#ensemble-de-chaînes-hachage"><span class="toc-section-number">3.2</span> Ensemble de chaînes, hachage</a><ul>
<li><a href="#opérations-de-base"><span class="toc-section-number">3.2.1</span> Opérations de base</a></li>
<li><a href="#idée-générale"><span class="toc-section-number">3.2.2</span> Idée générale</a></li>
<li><a href="#agrandissement-par-doublement"><span class="toc-section-number">3.2.3</span> Agrandissement par doublement</a></li>
<li><a href="#doublement-et-redistribution"><span class="toc-section-number">3.2.4</span> Doublement et redistribution</a></li>
<li><a href="#détails-dimplémentation"><span class="toc-section-number">3.2.5</span> Détails d’implémentation</a></li>
<li><a href="#choix-de-la-fonction-de-hachage"><span class="toc-section-number">3.2.6</span> Choix de la fonction de hachage</a></li>
<li><a href="#code-source"><span class="toc-section-number">3.2.7</span> Code source</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="objectifs-du-document"><span class="header-section-number">1</span> Objectifs du document</h1>
<p>Ce document montre les principes de fonctionnement de divers <strong>conteneurs</strong> (tableau extensible, listes chaînées, dictionnaire, …) en allant jusqu’aux détails d’implémentation.</p>
<p>Pour aller au niveau le plus bas que permet la portabilité, l’implémentation est réalisée en C.</p>
<p>Inconvénient du langage C : il ne permet pas la <em>généricité</em>. C’est-à-dire que si on a écrit le code d’un tableau extensible d’entiers, il faut tout recommencer pour avoir un tableau extensible de chaînes, par exemple.</p>
<p>Mais l’objectif ici n’est pas d’obtenir une implémentation “professionnelle” des conteneurs. En pratique on utilisera des langages de plus haut niveau, ou des bibliothèques existantes, mais ça ne dispense pas de comprendre comment ça marche.</p>
<h1 id="rappels"><span class="header-section-number">2</span> Rappels</h1>
<h2 id="les-données-en-mémoire"><span class="header-section-number">2.1</span> Les données en mémoire</h2>
<p>Un programme C contient généralement des variables. Pendant l’exécution, chaque variable est stockée en mémoire quand elle n’est pas éliminée par le compilateur (ce qui arrive quand il détecte que la variable est inutile, ou suffisamment temporaire pour être rangée dans un registre du processeur), dans un <strong>emplacement en mémoire</strong> formé d’octets consécutifs.</p>
<h3 id="taille-des-données-opérateur-sizeof"><span class="header-section-number">2.1.1</span> Taille des données, opérateur <code>sizeof()</code></h3>
<p>Le nombre d’octets (la <strong>taille</strong>) dépend du type de la variable. On la détermine en appliquant l’opérateur <code>sizeof()</code> à une variable ou à un type.</p>
<p>Le listing ci-dessous montre un programme qui fait afficher les tailles de quelques types.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"> * Affichage des tailles de divers types de base.</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"> * </span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co"> * Les tailles dépendent du compilateur, </span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co"> * sauf pour pour char (toujours 1).</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1-10" title="10">{</a>
<a class="sourceLine" id="cb1-11" title="11">    printf(<span class="st">&quot;char</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span>,   <span class="kw">sizeof</span>(<span class="dt">char</span>)); </a>
<a class="sourceLine" id="cb1-12" title="12">    printf(<span class="st">&quot;int</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span>,    <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb1-13" title="13">    printf(<span class="st">&quot;long</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span>,   <span class="kw">sizeof</span>(<span class="dt">long</span>));</a>
<a class="sourceLine" id="cb1-14" title="14">    printf(<span class="st">&quot;float</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span>,  <span class="kw">sizeof</span>(<span class="dt">float</span>));</a>
<a class="sourceLine" id="cb1-15" title="15">    printf(<span class="st">&quot;double</span><span class="sc">\t</span><span class="st">%zu</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">sizeof</span>(<span class="dt">double</span>));</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-17" title="17">}</a></code></pre></div>
<p>Le résultat dépend des choix d’implémentation du compilateur que vous utilisez, sauf pour le type le type <code>char</code> qui correspond <strong>toujours</strong> <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> à un octet exactement. <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>Exécution du programme :</p>
<pre><code>type    taille
----    ------
char    1
int     4
long    8
float   4
double  8</code></pre>
<p>Par exemple, un <code>int</code> occupe <em>en général</em> 4 octets sur une machine 32 bits, et 8 octets sur une machine 64 bits.</p>
<p><strong>Remarques :</strong></p>
<ol type="1">
<li><p><code>sizeof()</code> retourne un <code>size_t</code>, type qui correspond à un entier non signé assez grand pour stocker une taille. L’implémentation de <code>size_t</code> (<code>unsigned int</code>, <code>unsigned long</code>, ...) est dépendante de l’architecture.</p></li>
<li><p>Portabilité : utilisez la spécification de format <code>%zu</code> pour le type <code>size_t</code>.</p></li>
</ol>
<h3 id="structures-en-mémoire"><span class="header-section-number">2.1.2</span> Structures en mémoire</h3>
<p>Rappel : une structure contient un ou plusieurs membres (champs) qui peuvent être de types différents. Exemple de définition d’un type et d’une variable :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">struct</span> Employe {</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">char</span> nom[<span class="dv">40</span>];</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">int</span>  age;</a>
<a class="sourceLine" id="cb3-4" title="4">};</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">struct</span> Employe cuistot  = { <span class="st">&quot;Maurice&quot;</span>, <span class="dv">63</span> };</a></code></pre></div>
<p><strong>Exercice :</strong> Écrivez un programme montrant un exemple de structure dont la taille n’est pas <em>égale</em> à la somme des tailles des champs.</p>
<h3 id="adresse-des-données-opérateur"><span class="header-section-number">2.1.3</span> Adresse des données, opérateur “<code>&amp;</code>”</h3>
<p>Le programme ci-dessous fait afficher les adresses de quelques variables pendant l’exécution, obtenues en leur appliquant l’opérateur “<code>&amp;</code>” (<code>address-of</code>)<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> du langage C.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"> * Affichage d'adresses de variables.</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"> * </span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"> */</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="dt">int</span> glob1 = <span class="dv">12</span>;</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="dt">float</span> glob2 = <span class="dv">34</span>;</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb4-11" title="11">{</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="dt">int</span> loc1 = <span class="dv">33</span>;</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="dt">float</span> loc2 = <span class="fl">3.14</span>;</a>
<a class="sourceLine" id="cb4-14" title="14">    printf(<span class="st">&quot;var.</span><span class="sc">\t</span><span class="st">adresse</span><span class="sc">\n</span><span class="st">----</span><span class="sc">\t</span><span class="st">------</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb4-15" title="15">    printf(<span class="st">&quot;glob1</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,  (<span class="dt">void</span> *)  &amp; glob1); </a>
<a class="sourceLine" id="cb4-16" title="16">    printf(<span class="st">&quot;glob2</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,  (<span class="dt">void</span> *)  &amp; glob2);</a>
<a class="sourceLine" id="cb4-17" title="17">    printf(<span class="st">&quot;loc1</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,   (<span class="dt">void</span> *)  &amp; loc1);</a>
<a class="sourceLine" id="cb4-18" title="18">    printf(<span class="st">&quot;loc2</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,   (<span class="dt">void</span> *)  &amp; loc2);</a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-20" title="20">}</a></code></pre></div>
<p>Résultat de l’exécution</p>
<pre><code>var.    adresse
----    ------
glob1   0x5594b04a9038
glob2   0x5594b04a903c
loc1    0x7fffa1c515fc
loc2    0x7fffa1c515f8</code></pre>
<p>Les adresses sont des données typées : par exemple l’adresse d’une variable de type <code>int</code> est de type <code>int*</code>. L’affichage se fait avec la spécification “<code>%p</code>&quot; (pour <em>pointer</em>) en les convertissant en”adresses non-typées&quot; (<code>void *</code>).</p>
<p><strong>Remarques :</strong></p>
<ul>
<li><p>Les variables globales du programme et les variables locales de la fonction <code>main()</code> sont dans des “segments” dont les adresses diffèrent considérablement : le segment de données pour les variables globales, et le segment de pile pour les autres<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p></li>
<li><p>Sur les systèmes d’exploitation modernes, les adresses virtuelles qui s’affichent changent à chaque exécution<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>.</p></li>
</ul>
<p><strong>Exercice :</strong> Reprenez l’exemple de structure dont la taille est supérieure à la somme des tailles des champs, et définissez une variable de ce type. Faites afficher l’adresse et la taille de la structure et de chacun de ses champs. Conclusion ?</p>
<h3 id="tableaux-et-adresses"><span class="header-section-number">2.1.4</span> Tableaux et adresses</h3>
<p>Le programme ci-dessous fait affiche l’adresse d’un tableau et de ses éléments.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co"> * Affichage d'adresses tableaux / éléments</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb6-7" title="7">{</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="dt">int</span> tab[<span class="dv">4</span>] = { <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span> };</a>
<a class="sourceLine" id="cb6-9" title="9">  </a>
<a class="sourceLine" id="cb6-10" title="10">  printf(<span class="st">&quot;var.</span><span class="sc">\t</span><span class="st">adresse</span><span class="sc">\n</span><span class="st">----</span><span class="sc">\t</span><span class="st">------</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb6-11" title="11">  printf(<span class="st">&quot;tab</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,  (<span class="dt">void</span> *) tab);</a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {  </a>
<a class="sourceLine" id="cb6-13" title="13">    printf(<span class="st">&quot;tab[%d]</span><span class="sc">\t</span><span class="st">%p</span><span class="sc">\n</span><span class="st">&quot;</span>,  i, (<span class="dt">void</span> *)  &amp; tab[i]);</a>
<a class="sourceLine" id="cb6-14" title="14">  }</a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-16" title="16">}</a></code></pre></div>
<p>Résultat :</p>
<pre><code>var.    adresse
----    ------
tab 0x7ffd7b053230
tab[0]  0x7ffd7b053230
tab[1]  0x7ffd7b053234
tab[2]  0x7ffd7b053238
tab[3]  0x7ffd7b05323c</code></pre>
<p><strong>Remarque :</strong> En C, une variable de type tableau désigne en fait l’<em>adresse</em> de l’emplacement qui a été réservé en mémoire pour placer les éléments. Il n’y a dons pas besoin de mettre un “<code>&amp;</code>” devant <code>tab</code> dans le <code>printf</code>.</p>
<p>On constate qu’à l’exécution, les éléments se suivent en mémoire, et l’adresse du tableau correspond à celle du premier élément.</p>
<h2 id="pointeurs"><span class="header-section-number">2.2</span> Pointeurs</h2>
<p>On appelle <strong>pointeur</strong><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> une donnée qui contient une adresse, c’est-à-dire la position d’une (autre) donnée en mémoire.</p>
<p>On emploie les pointeurs pour diverses raisons, en particulier :</p>
<ul>
<li>le passage de paramètres,</li>
<li>le parcours de tableaux,</li>
<li>la manipulation des données allouées dynamiquement.</li>
</ul>
<h3 id="déclaration-des-pointeurs"><span class="header-section-number">2.2.1</span> Déclaration des pointeurs</h3>
<p>Pour <strong>déclarer</strong> un pointeur destiné à contenir des adresses d’objets de type T, on précède son nom par une étoile. Exemples :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">int</span> *pi;               <span class="co">// pointeur sur un int</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">struct</span> Personne *pp;   <span class="co">// pointeur sur struct Personne</span></a></code></pre></div>
<p>Pour déclarer un tableau de pointeurs, le nom du tableau est précédé par une étoile :</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">char</span> *noms[<span class="dv">10</span>];  <span class="co">// tableau de 10 pointeurs de caractères</span></a></code></pre></div>
<p>La règle générale est qu’en C, la déclaration d’une variable ressemble à son usage (voir l’indirection ci-dessous).</p>
<h3 id="pointeurs-non-typés-conversions"><span class="header-section-number">2.2.2</span> Pointeurs non-typés, conversions</h3>
<p>Les pointeurs non-typés sont déclarés avec <code>void *</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">int</span> entier = <span class="dv">123</span>;</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">void</span> *adresse = &amp; entier;        <span class="co">// pointeur non typé</span></a>
<a class="sourceLine" id="cb10-3" title="3">printf(<span class="st">&quot;valeur=%d, adresse=%p</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb10-4" title="4">               entier,      adresse);</a></code></pre></div>
<p><strong>Remarque :</strong> l’expression “<code>&amp; entier</code>” de la seconde ligne est de type <code>int *</code>, mais il y a une <strong>conversion implicite</strong> entre les adresses typées et non-typées.</p>
<h3 id="indirection-opérateur"><span class="header-section-number">2.2.3</span> Indirection, opérateur “<code>*</code>”</h3>
<p>L’opérateur “<code>*</code>” fournit un accès à la donnée dont l’adresse est contenue dans un pointeur <strong>typé</strong>. Exemple :</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">int</span> nombre = <span class="dv">12</span>;</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="dt">int</span> *p = &amp; nombre;            <span class="co">// pointeur typé (entiers)</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4">*p = <span class="dv">33</span>;                      <span class="co">// modif. à travers p</span></a>
<a class="sourceLine" id="cb11-5" title="5">printf(<span class="st">&quot;= %d</span><span class="sc">\n</span><span class="st">&quot;</span>, *p);         <span class="co">// accès indirect</span></a></code></pre></div>
<p><strong>Terminologie :</strong> on dit que</p>
<ul>
<li>la variable <code>nombre</code> <strong>est pointée par</strong> <code>p</code>.</li>
<li>on fait une <strong>indirection</strong> pour, à partir d’un pointeur, accéder à la donnée qu’il pointe.</li>
<li>on <strong>dé-référence</strong> le pointeur.</li>
</ul>
<p>*<strong>Remarque :</strong> dans l’exemple d’un tableau de pointeurs de caractères vu plus haut,</p>
<ul>
<li><p><code>noms[2]</code> est le troisième<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> pointeur ;</p></li>
<li><p><code>*noms[2]</code> est le <code>char</code> désigné par ce pointeur.</p></li>
</ul>
<p>Et puisque <code>*noms[i]</code> est un <code>char</code>, dans la logique de C, il n’est pas anormal que la déclaration d’un tableau de pointeurs</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1">  <span class="dt">char</span>   *noms[<span class="dv">10</span>];</a></code></pre></div>
<p>ressemble fortement à l’usage qu’on a des éléments.</p>
<h3 id="le-pointeur-null"><span class="header-section-number">2.2.4</span> Le pointeur <code>NULL</code></h3>
<p>La constante <code>NULL</code> est une valeur conventionnelle (de type <code>void*</code> que l’on affecte à un pointeur pour indiquer qu’il <strong>ne contient pas</strong>, à un moment donné, l’adresse d’un objet en mémoire. Le pointeur ne pointe sur rien.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<p>Quand un pointeur contient <code>NULL</code>, tenter de le dé-référencer est un <strong>comportement indéfini</strong>, qui provoque généralement un arrêt brutal de l’exécution :</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1">  <span class="dt">int</span> *p = NULL;</a>
<a class="sourceLine" id="cb13-2" title="2">  *p = <span class="dv">12</span>;            <span class="co">// crash</span></a></code></pre></div>
<h3 id="pointeurs-de-structures-notation--"><span class="header-section-number">2.2.5</span> Pointeurs de structures, notation “<code>-&gt;</code>”</h3>
<p>Selon les règles de priorités d’opérateurs de C, “<code>*a.b</code>” se lit “<code>*(a.b)</code>”.</p>
<p>La notation <code>pointeur-&gt;champ</code> facilite la désignation d’un champ d’une structure dont on a l’adresse dans un pointeur. Exemple :</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">struct</span> Point {</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">float</span> x, y;</a>
<a class="sourceLine" id="cb14-3" title="3">};</a>
<a class="sourceLine" id="cb14-4" title="4">...</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="kw">struct</span> Point *p;  <span class="co">// p pointeur de point</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">p-&gt;x = <span class="fl">0.0</span>;          <span class="co">// au lieu de  (*p).x = 0.0</span></a>
<a class="sourceLine" id="cb14-8" title="8">p-&gt;y = <span class="fl">0.0</span>;</a></code></pre></div>
<h2 id="passage-de-paramètres"><span class="header-section-number">2.3</span> Passage de paramètres</h2>
<p>Le langage C ne connaissant que le passage de paramètres <strong>par valeur</strong>, on utilise des pointeurs pour simuler le “passage de référence” dans deux situations :</p>
<ol type="1">
<li><p>l’action que l’on veut coder modifie un objet qu’on lui indique,</p></li>
<li><p>les objets que l’on souhaite transmettre sont assez gros, et pour des raisons de performance, on veut éviter la copie inhérente à un passage par valeur.</p></li>
</ol>
<h3 id="pointeur-pour-le-passage-par-référence"><span class="header-section-number">2.3.1</span> Pointeur pour le passage par référence</h3>
<p>Exemple : une action consistant à échanger les nombres contenus dans deux variables. On la traduit par une fonction à qui on passe les <strong>adresses</strong> des variables à modifier.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span> echanger(<span class="dt">int</span> *pa, <span class="dt">int</span> *pb) {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">int</span> tmp = *pa;</a>
<a class="sourceLine" id="cb15-3" title="3">  *pa = *pb;</a>
<a class="sourceLine" id="cb15-4" title="4">  *pb = tmp;</a>
<a class="sourceLine" id="cb15-5" title="5">}</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co">// usage</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="dt">int</span> a = <span class="dv">34</span>, b = <span class="dv">23</span>;</a>
<a class="sourceLine" id="cb15-9" title="9">echanger( &amp; a, &amp; b);</a></code></pre></div>
<h3 id="pointeur-pour-éviter-de-copier"><span class="header-section-number">2.3.2</span> Pointeur pour éviter de copier</h3>
<p>Exemple: affichage d’une structure.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1">      <span class="kw">struct</span> Personne {</a>
<a class="sourceLine" id="cb16-2" title="2">        <span class="dt">char</span> nom[<span class="dv">100</span>];</a>
<a class="sourceLine" id="cb16-3" title="3">        <span class="dt">char</span> prenom[<span class="dv">100</span>];</a>
<a class="sourceLine" id="cb16-4" title="4">        ...</a>
<a class="sourceLine" id="cb16-5" title="5">      };</a>
<a class="sourceLine" id="cb16-6" title="6">      </a>
<a class="sourceLine" id="cb16-7" title="7">      <span class="dt">void</span> afficher_personne(<span class="dt">const</span> <span class="kw">struct</span> Personne *p) {</a>
<a class="sourceLine" id="cb16-8" title="8">        printf(<span class="st">&quot;nom = %s</span><span class="sc">\n</span><span class="st">'', p-&gt;nom);</span></a>
<a class="sourceLine" id="cb16-9" title="9">        ...</a>
<a class="sourceLine" id="cb16-10" title="10">      }</a></code></pre></div>
<p>Le mot-clé <code>const</code> annonce nos intentions. La déclaration de paramètre se lit de droite à gauche : <code>p</code> est un pointeur vers une structure <code>Personne</code> qu’on ne modifie pas.</p>
<h3 id="parcours-de-tableau-arithmétique-des-pointeurs"><span class="header-section-number">2.3.3</span> Parcours de tableau, arithmétique des pointeurs</h3>
<p>Une chaîne de caractères est un tableau d’octets terminé par un caractère nul.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1">  <span class="dt">char</span> test[] = <span class="st">&quot;abc&quot;</span>;  <span class="co">// tableau de _4_ octets</span></a></code></pre></div>
<p>Pour parcourir une chaîne, on peut<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> utiliser un pointeur qui va désigner tour à tour chaque octet :</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1">  <span class="dt">void</span> affiche_codes(<span class="dt">const</span> <span class="dt">char</span> chaine[]) {</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="dt">char</span> *p = chaine;</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="cf">while</span> (*p != '\<span class="dv">0</span>') {</a>
<a class="sourceLine" id="cb18-4" title="4">      printf(<span class="st">&quot;-&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span>; *p);</a>
<a class="sourceLine" id="cb18-5" title="5">      p++;</a>
<a class="sourceLine" id="cb18-6" title="6">    }</a>
<a class="sourceLine" id="cb18-7" title="7">  }</a></code></pre></div>
<p><strong>Remarques</strong></p>
<ol type="1">
<li><p>Un tableau déclaré en paramètre est en réalité un pointeur.</p></li>
<li><p>l’incrémentation d’un pointeur (<code>p++]</code>) modifie ce pointeur pour qu’il désigne l’élément suivant<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></p></li>
</ol>
<h2 id="allocation-dynamique"><span class="header-section-number">2.4</span> Allocation dynamique</h2>
<p>L’<strong>allocation dynamique de mémoire</strong> est un ensemble de fonctionnalités mises à la disposition du programmeur d’application par la bibliothèque standard C.</p>
<p>Elle lui permet de gérer de l’espace mémoire supplémentaire (en plus de la pile d’exécution et du segment de données) pour y placer des données, en spécifiant le nombre d’octets voulu. Elle permet aussi de libérer un espace alloué dont on n’a plus besoin.</p>
<h3 id="attention-danger"><span class="header-section-number">2.4.1</span> Attention, danger</h3>
<p>L’usage de l’allocation dynamique impose un soin très attentif au programmeur qui est guetté par deux dangers :</p>
<ul>
<li><p><strong>la fuite mémoire</strong> si un programme alloue en boucle des zones mémoires, sans les libérer quand il n’en n’a plus besoin. L’espace mémoire du programme s’agrandit indéfiniment, ce qui finit mal.</p></li>
<li><p>la <strong>corruption des données</strong> si un programme utilise par erreur une zone qui a été libérée.</p></li>
</ul>
<p>C’est une difficulté typique de la programmation en C.</p>
<h3 id="fonctions-malloc-et-free"><span class="header-section-number">2.4.2</span> Fonctions <code>malloc()</code> et <code>free()</code></h3>
<p>Nous utilisons essentiellement deux fonctions, définies dans <code>stdlib.h</code> :</p>
<ul>
<li><code>malloc()</code> pour obtenir de l’espace mémoire supplémentaire,</li>
<li><code>free()</code> pour restituer (libérer) de l’espace obtenu par <code>malloc()</code>,</li>
</ul>
<p>et occasionnellement <code>realloc()</code> qui agrandit ou rétrécit un espace qu’on a obtenu, quitte à le déménager ailleurs.</p>
<p>Le listing ci-dessous montre l’utilisation d’un tableau de structures alloué dynamiquement.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="co"> * Allocations et libérations. A compléter</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="co"> * Un tableau de personnes</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="co"> */</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="kw">struct</span> Employe {</a>
<a class="sourceLine" id="cb19-9" title="9">  <span class="dt">char</span> prenom[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb19-10" title="10">  <span class="dt">int</span>  bureau;</a>
<a class="sourceLine" id="cb19-11" title="11">};</a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13"><span class="kw">struct</span> Employe *nouveauTableau(<span class="dt">int</span> nb)</a>
<a class="sourceLine" id="cb19-14" title="14">{</a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="kw">struct</span> Employe *t</a>
<a class="sourceLine" id="cb19-16" title="16">    = malloc(nb * <span class="kw">sizeof</span>(<span class="kw">struct</span> Employe));</a>
<a class="sourceLine" id="cb19-17" title="17">  <span class="cf">if</span> (t == NULL) {</a>
<a class="sourceLine" id="cb19-18" title="18">    fprintf(stderr, <span class="st">&quot;échec d'allocation&quot;</span>);</a>
<a class="sourceLine" id="cb19-19" title="19">    exit (EXIT_FAILURE);</a>
<a class="sourceLine" id="cb19-20" title="20">  }</a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb19-22" title="22">}</a>
<a class="sourceLine" id="cb19-23" title="23"></a>
<a class="sourceLine" id="cb19-24" title="24"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb19-25" title="25">{</a>
<a class="sourceLine" id="cb19-26" title="26">  <span class="dt">int</span> nbEmployes;</a>
<a class="sourceLine" id="cb19-27" title="27">  printf(<span class="st">&quot;Combien d'employés ? &quot;</span>);</a>
<a class="sourceLine" id="cb19-28" title="28">  scanf(<span class="st">&quot;%d&quot;</span>, &amp; nbEmployes);</a>
<a class="sourceLine" id="cb19-29" title="29"></a>
<a class="sourceLine" id="cb19-30" title="30">  <span class="kw">struct</span> Employe *tableau = nouveauTableau(nbEmployes);</a>
<a class="sourceLine" id="cb19-31" title="31">  </a>
<a class="sourceLine" id="cb19-32" title="32">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nb; i++) {</a>
<a class="sourceLine" id="cb19-33" title="33">    lire_employe( &amp; tableau[i]);</a>
<a class="sourceLine" id="cb19-34" title="34">  }</a>
<a class="sourceLine" id="cb19-35" title="35">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nb; i++) {</a>
<a class="sourceLine" id="cb19-36" title="36">    afficher_employe( &amp; tableau[i]);</a>
<a class="sourceLine" id="cb19-37" title="37">  }</a>
<a class="sourceLine" id="cb19-38" title="38"></a>
<a class="sourceLine" id="cb19-39" title="39">  free(tableau);                      <span class="co">// libération</span></a>
<a class="sourceLine" id="cb19-40" title="40">  exit (EXIT_SUCCESS);</a>
<a class="sourceLine" id="cb19-41" title="41">}</a></code></pre></div>
<p>Pour l’allocation par <code>malloc()</code>, on indique en paramètre la taille (nombre d’octets) souhaitée. La fonction retourne l’adresse (non typée) de la zone allouée, ou <code>NULL</code> en cas d’échec..</p>
<p>Pour libérer une zone, on fournit son adresse à la fonction <code>free</code>.</p>
<h3 id="exercice"><span class="header-section-number">2.4.3</span> Exercice :</h3>
<p>Écrire les fonctions manquantes.</p>
<h3 id="réallocation-realloc"><span class="header-section-number">2.4.4</span> Réallocation (<code>realloc</code>)</h3>
<p>Si on veut ajouter un employé supplémentaire, il faut agrandir le tableau. Pour cela on fait un appel à <code>realloc()</code> en indiquant</p>
<ul>
<li>l’adresse de la zone que l’on veut redimensionner (ici <code>tableau</code>),</li>
<li>la nouvelle taille</li>
</ul>
<p>et <code>realloc</code> retournera l’adresse de la nouvelle zone :</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1">nbElements += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb20-2" title="2">tableau = realloc(tableau,</a>
<a class="sourceLine" id="cb20-3" title="3">                  nbElements * <span class="kw">sizeof</span>(<span class="kw">struct</span> Employe));</a></code></pre></div>
<p><strong>À savoir :</strong></p>
<ul>
<li><p>si le premier paramètre de <code>realloc</code> est <code>NULL</code>, la fonction se comporte comme <code>malloc()</code>,</p></li>
<li><p>vous l’aviez deviné : en cas d’échec, <code>realloc()</code> retourne <code>NULL</code>.</p></li>
</ul>
<p><strong>Exercice</strong></p>
<p>Écrivez un programme qui</p>
<ul>
<li>part d’un tableau vide,</li>
<li>fait une boucle, en demandant si on veut en ajouter d’autres,</li>
<li>les affiche tous à la fin.</li>
</ul>
<h1 id="conteneurs"><span class="header-section-number">3</span> Conteneurs</h1>
<h2 id="tableaux-extensibles"><span class="header-section-number">3.1</span> Tableaux extensibles</h2>
<p>Nous appellons <em>tableau extensible</em> une structure de données qui sert à stocker des éléments, et</p>
<ul>
<li><p>comme un tableau ordinaire, permet de désigner un élément par sa position (première = 0, seconde = 1, etc.), pour le modifier ou le consulter.</p></li>
<li><p>à la différence des tableaux, permet d’ajouter des éléments à la fin sans limite de taille<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>.</p></li>
</ul>
<p>Ici nous allons prendre l’exemple des tableaux extensibles d’entiers.</p>
<h3 id="choix-dune-api-exemple-dutilisation"><span class="header-section-number">3.1.1</span> Choix d’une API, exemple d’utilisation</h3>
<ul>
<li><p>Le type “tableau extensible d’entiers” se matérialise par une structure appelée <code>tab_int</code>.</p></li>
<li><p>Une famille de fonctions, dont le nom est préfixé par “<code>ti</code>” représentera les actions qui agissent dessus.</p></li>
<li><p>Le premier paramètre de ces fonctions sera toujours l’adresse du tableau concerné.<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a></p></li>
</ul>
<p>Le programme suivant montre l’emploi d’un tel tableau :</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="pp">#include </span><span class="im">&quot;tab_int.h&quot;</span></a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="dt">void</span> afficher(<span class="dt">const</span> <span class="dt">char</span> *m, <span class="dt">const</span> <span class="kw">struct</span> tab_int *a);</a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb21-9" title="9">{</a>
<a class="sourceLine" id="cb21-10" title="10">  <span class="kw">struct</span> tab_int tableau;</a>
<a class="sourceLine" id="cb21-11" title="11">  ti_init(&amp; tableau);</a>
<a class="sourceLine" id="cb21-12" title="12"></a>
<a class="sourceLine" id="cb21-13" title="13">   <span class="co">// 10, 20 ... 100</span></a>
<a class="sourceLine" id="cb21-14" title="14">  <span class="cf">for</span> (<span class="dt">int</span> v = <span class="dv">10</span>; v &lt;= <span class="dv">100</span>; v += <span class="dv">10</span>) { </a>
<a class="sourceLine" id="cb21-15" title="15">    ti_ajouter(&amp; tableau, v);</a>
<a class="sourceLine" id="cb21-16" title="16">  }</a>
<a class="sourceLine" id="cb21-17" title="17"></a>
<a class="sourceLine" id="cb21-18" title="18">  afficher(<span class="st">&quot;avant&quot;</span>, &amp; tableau);</a>
<a class="sourceLine" id="cb21-19" title="19">  ti_changer(&amp; tableau, <span class="dv">3</span>, <span class="dv">421</span>);</a>
<a class="sourceLine" id="cb21-20" title="20">  afficher(<span class="st">&quot;après&quot;</span>, &amp; tableau);</a>
<a class="sourceLine" id="cb21-21" title="21"></a>
<a class="sourceLine" id="cb21-22" title="22">  ti_detruire(&amp; tableau);</a>
<a class="sourceLine" id="cb21-23" title="23">  </a>
<a class="sourceLine" id="cb21-24" title="24">  exit (<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb21-25" title="25">}</a>
<a class="sourceLine" id="cb21-26" title="26"></a>
<a class="sourceLine" id="cb21-27" title="27"><span class="co">/**</span></a>
<a class="sourceLine" id="cb21-28" title="28"><span class="co"> * affiche un message et le contenu d'un tableau</span></a>
<a class="sourceLine" id="cb21-29" title="29"><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">m</span><span class="co"> : chaine</span></a>
<a class="sourceLine" id="cb21-30" title="30"><span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">a</span><span class="co"> : adresse du tableau</span></a>
<a class="sourceLine" id="cb21-31" title="31"><span class="co"> */</span></a>
<a class="sourceLine" id="cb21-32" title="32"><span class="dt">void</span> afficher(<span class="dt">const</span> <span class="dt">char</span> *m,</a>
<a class="sourceLine" id="cb21-33" title="33">          <span class="dt">const</span> <span class="kw">struct</span> tab_int *a)</a>
<a class="sourceLine" id="cb21-34" title="34">{</a>
<a class="sourceLine" id="cb21-35" title="35">  printf(<span class="st">&quot;%s: &quot;</span>, m);</a>
<a class="sourceLine" id="cb21-36" title="36">  <span class="dt">int</span> taille = ti_taille(a);</a>
<a class="sourceLine" id="cb21-37" title="37">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>;  i &lt; taille; i++) {</a>
<a class="sourceLine" id="cb21-38" title="38">    printf(<span class="st">&quot;%d &quot;</span>, ti_valeur(a, i));</a>
<a class="sourceLine" id="cb21-39" title="39">  }</a>
<a class="sourceLine" id="cb21-40" title="40">  printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb21-41" title="41">}</a></code></pre></div>
<p>Résultats :</p>
<pre><code>avant: 10 20 30 40 50 60 70 80 90 100 
après: 10 20 30 421 50 60 70 80 90 100 </code></pre>
<h3 id="limplémentation"><span class="header-section-number">3.1.2</span> L’implémentation</h3>
<h4 id="données"><span class="header-section-number">3.1.2.1</span> Données</h4>
<p>Un tableau extensible est représenté par</p>
<ul>
<li><p>un <strong>tableau</strong> alloué dynamiquement, pouvant accueillir un certain nombre d’éléments (sa <strong>capacité</strong>),</p></li>
<li><p>un entier indiquant le nombre d’éléments utilisés, au début du tableau (sa <strong>taille</strong>)</p></li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="pp">#ifndef TAB_INT_H</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="pp">#define TAB_INT_H</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">struct</span> tab_int {</a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="dt">int</span>  taille;</a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="dt">int</span>  capacite;</a>
<a class="sourceLine" id="cb23-7" title="7">  <span class="dt">int</span> *elements;</a>
<a class="sourceLine" id="cb23-8" title="8">};</a>
<a class="sourceLine" id="cb23-9" title="9"></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="dt">void</span> ti_init    (      <span class="kw">struct</span> tab_int *a);          </a>
<a class="sourceLine" id="cb23-11" title="11"><span class="dt">void</span> ti_ajouter (      <span class="kw">struct</span> tab_int *a, <span class="dt">int</span> valeur);</a>
<a class="sourceLine" id="cb23-12" title="12"><span class="dt">void</span> ti_detruire(      <span class="kw">struct</span> tab_int *a);</a>
<a class="sourceLine" id="cb23-13" title="13"><span class="dt">int</span>  ti_taille  (<span class="dt">const</span> <span class="kw">struct</span> tab_int *a); </a>
<a class="sourceLine" id="cb23-14" title="14"><span class="dt">int</span>  ti_valeur  (<span class="dt">const</span> <span class="kw">struct</span> tab_int *a, <span class="dt">int</span> indice);</a>
<a class="sourceLine" id="cb23-15" title="15"><span class="dt">void</span> ti_changer (      <span class="kw">struct</span> tab_int *a, <span class="dt">int</span> indice,</a>
<a class="sourceLine" id="cb23-16" title="16">                                  <span class="dt">int</span> valeur);</a>
<a class="sourceLine" id="cb23-17" title="17"><span class="pp">#endif</span></a></code></pre></div>
<h4 id="code"><span class="header-section-number">3.1.2.2</span> Code</h4>
<p>Le code comporte quelques choix d’implémentation :</p>
<ul>
<li><p>la capacité initiale, lorsqu’on initialise un tableau extensible (ici, 4 éléments)</p></li>
<li><p>la stratégie d’agrandissement en cas de débordement. Ici on double : l’ajout du 5ième élément ré-alloue le tableau avec une capacité de 8, et l’ajout du 8ième porte la capacité à 16. Cette stratégie est justifiée plus loin.</p></li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="pp">#include </span><span class="im">&quot;tab_int.h&quot;</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="pp">#define CAPACITE_MINIMALE 4</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="dt">void</span> ti_init (<span class="kw">struct</span> tab_int *a)</a>
<a class="sourceLine" id="cb24-7" title="7">{</a>
<a class="sourceLine" id="cb24-8" title="8">  a-&gt;taille = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-9" title="9">  a-&gt;capacite = CAPACITE_MINIMALE;</a>
<a class="sourceLine" id="cb24-10" title="10">  <span class="co">// </span><span class="al">NOTE</span><span class="co"> : on devrait vérifier le résultat de malloc</span></a>
<a class="sourceLine" id="cb24-11" title="11">  a-&gt;elements = malloc(a-&gt;capacite * <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb24-12" title="12">}</a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14"><span class="dt">void</span> ti_ajouter(<span class="kw">struct</span> tab_int *a, <span class="dt">int</span> valeur)</a>
<a class="sourceLine" id="cb24-15" title="15">{</a>
<a class="sourceLine" id="cb24-16" title="16">  <span class="co">// si plein, agrandir</span></a>
<a class="sourceLine" id="cb24-17" title="17">  <span class="cf">if</span> (a-&gt;taille == a-&gt;capacite) {</a>
<a class="sourceLine" id="cb24-18" title="18">    a-&gt;capacite *= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb24-19" title="19">    <span class="co">// </span><span class="al">NOTE</span><span class="co"> : on devrait vérifier le résultat de realloc    </span></a>
<a class="sourceLine" id="cb24-20" title="20">    a-&gt;elements = realloc(a-&gt;elements,</a>
<a class="sourceLine" id="cb24-21" title="21">              a-&gt;capacite * <span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb24-22" title="22">  }</a>
<a class="sourceLine" id="cb24-23" title="23">  <span class="co">// ajout à la fin</span></a>
<a class="sourceLine" id="cb24-24" title="24">  a-&gt;elements[a-&gt;taille] = valeur;</a>
<a class="sourceLine" id="cb24-25" title="25">  a-&gt; taille += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb24-26" title="26">}</a>
<a class="sourceLine" id="cb24-27" title="27"></a>
<a class="sourceLine" id="cb24-28" title="28"><span class="dt">void</span> ti_detruire(<span class="kw">struct</span> tab_int *a)</a>
<a class="sourceLine" id="cb24-29" title="29">{</a>
<a class="sourceLine" id="cb24-30" title="30">  a-&gt;taille = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-31" title="31">  a-&gt;capacite = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-32" title="32">  free(a-&gt;elements);</a>
<a class="sourceLine" id="cb24-33" title="33">  a -&gt; elements = NULL;</a>
<a class="sourceLine" id="cb24-34" title="34">}</a>
<a class="sourceLine" id="cb24-35" title="35"></a>
<a class="sourceLine" id="cb24-36" title="36"><span class="dt">int</span> ti_taille(<span class="dt">const</span> <span class="kw">struct</span> tab_int *a) </a>
<a class="sourceLine" id="cb24-37" title="37">{</a>
<a class="sourceLine" id="cb24-38" title="38">  <span class="cf">return</span> a-&gt;taille;</a>
<a class="sourceLine" id="cb24-39" title="39">}</a>
<a class="sourceLine" id="cb24-40" title="40"></a>
<a class="sourceLine" id="cb24-41" title="41"><span class="co">// les indices doivent être entre 0  et a-&gt;taille - 1</span></a>
<a class="sourceLine" id="cb24-42" title="42"></a>
<a class="sourceLine" id="cb24-43" title="43"><span class="dt">int</span> ti_valeur(<span class="dt">const</span> <span class="kw">struct</span> tab_int *a, <span class="dt">int</span> indice)</a>
<a class="sourceLine" id="cb24-44" title="44">{</a>
<a class="sourceLine" id="cb24-45" title="45">  <span class="cf">return</span> a-&gt;elements[indice];</a>
<a class="sourceLine" id="cb24-46" title="46">}</a>
<a class="sourceLine" id="cb24-47" title="47"></a>
<a class="sourceLine" id="cb24-48" title="48"><span class="dt">void</span> ti_changer(<span class="kw">struct</span> tab_int *a, <span class="dt">int</span> indice,</a>
<a class="sourceLine" id="cb24-49" title="49">        <span class="dt">int</span> valeur)</a>
<a class="sourceLine" id="cb24-50" title="50">{</a>
<a class="sourceLine" id="cb24-51" title="51">  a-&gt;elements[indice] = valeur;</a>
<a class="sourceLine" id="cb24-52" title="52">}</a></code></pre></div>
<h3 id="strategiedoublement"><span class="header-section-number">3.1.3</span> Stratégie de doublement de la capacité</h3>
<p>Lorsque le tableau est plein, on le ré-alloue avec une capacité supérieure.</p>
<p>La stratégie de doublement de cette capacité est, contrairement à ce que suggère l’intuition, très efficace en terme de nombre de copies : au cours du remplissage, chaque élément a été copié <strong>au plus une fois</strong> en moyenne.</p>
<p>Imaginons qu’à un moment le <em>vector</em> ait grandi jusqu’à 500 éléments. Comme le tableau grandit en doublant de taille, sa capacité est la première puissance de 2 supérieure à 500, soit 512.</p>
<p>Le tableau sera agrandi (et ré-alloué) en ajoutant le 513ieme, sa capacité passera à 1024 éléments, et pour cela il faudra ré-allouer ce qui provoquera la copie des 512 éléments existants. Coût : 512, si on prend comme unité la copie d’un élément.</p>
<p>Mais pour arriver à 513, il avait fallu copier 256 éléments. Et pour arriver à 257, en copier 128.</p>
<p>Si on fait le total, si on en est au 513-ième élément ajouté (et jusqu’au 1024-ième) on a fait en tout <span class="math inline">256 + 128 + 64 + ...</span> copies d’éléments, ce qui est plus petit que 512.</p>
<p>Dans le pire des cas (ajout du 513 ième), le coût moyen d’ajout d’un élément est inférieur à <span class="math inline">512/513</span> : il y a donc eu <strong>moins d’une copie par élément</strong>.</p>
<p><strong>Exercice :</strong> En général la première idée qui vient est d’augmenter d’une unité la capacité chaque ajout. Évaluez le coût de cette stratégie.</p>
<h2 id="ensemble-de-chaînes-hachage"><span class="header-section-number">3.2</span> Ensemble de chaînes, hachage</h2>
<p>Dans cette partie, nous montrons comment représenter <strong>efficacement</strong> un ensemble<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> de chaînes de caractères en utilisant une <strong>fonction de hachage</strong>.</p>
<h3 id="opérations-de-base"><span class="header-section-number">3.2.1</span> Opérations de base</h3>
<p>Les opérations de base sur cet ensemble :</p>
<ul>
<li><p>l’initialiser,</p></li>
<li><p>y ajouter un élément (si il n’y est pas déjà),</p></li>
<li><p>savoir combien il y a d’éléments dans l’ensemble,</p></li>
<li><p>tester si un élément est présent,</p></li>
<li><p>enlever un élément,</p></li>
<li><p>libérer les ressources utilisées.</p></li>
</ul>
<p>Ci-dessous un exemple d’utilisation où l’on ajoute une suite de mots (éventuellement en plusieurs exemplaires) et on fait afficher la taille (qui doit être 10).</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb25-3" title="3"></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="pp">#include </span><span class="im">&quot;ens_chaines.h&quot;</span></a>
<a class="sourceLine" id="cb25-5" title="5"></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb25-7" title="7">{</a>
<a class="sourceLine" id="cb25-8" title="8">    <span class="kw">struct</span> ens_chaines ensemble;</a>
<a class="sourceLine" id="cb25-9" title="9">    ec_init(&amp; ensemble);</a>
<a class="sourceLine" id="cb25-10" title="10"></a>
<a class="sourceLine" id="cb25-11" title="11">    <span class="dt">char</span> *mots[] = {</a>
<a class="sourceLine" id="cb25-12" title="12">        <span class="st">&quot;un&quot;</span>, <span class="st">&quot;deux&quot;</span>, <span class="st">&quot;trois&quot;</span>, <span class="st">&quot;un&quot;</span>,</a>
<a class="sourceLine" id="cb25-13" title="13">        <span class="st">&quot;quatre&quot;</span>, <span class="st">&quot;deux&quot;</span>, <span class="st">&quot;cinq&quot;</span>, <span class="st">&quot;six&quot;</span>,</a>
<a class="sourceLine" id="cb25-14" title="14">        <span class="st">&quot;sept&quot;</span>, <span class="st">&quot;trois&quot;</span>, <span class="st">&quot;huit&quot;</span>, <span class="st">&quot;neuf&quot;</span>,</a>
<a class="sourceLine" id="cb25-15" title="15">        <span class="st">&quot;dix&quot;</span>, <span class="st">&quot;trois&quot;</span>, <span class="st">&quot;sept&quot;</span>,</a>
<a class="sourceLine" id="cb25-16" title="16">        NULL</a>
<a class="sourceLine" id="cb25-17" title="17">    };</a>
<a class="sourceLine" id="cb25-18" title="18">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; mots[i] != NULL; i++) {</a>
<a class="sourceLine" id="cb25-19" title="19">        ec_ajouter(&amp; ensemble, mots[i]);</a>
<a class="sourceLine" id="cb25-20" title="20">    }</a>
<a class="sourceLine" id="cb25-21" title="21"></a>
<a class="sourceLine" id="cb25-22" title="22">    printf(<span class="st">&quot;-&gt; taille %d (attendu = 10)</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb25-23" title="23">            ec_taille(&amp; ensemble));</a>
<a class="sourceLine" id="cb25-24" title="24">    </a>
<a class="sourceLine" id="cb25-25" title="25">    ec_dump(&amp; ensemble);</a>
<a class="sourceLine" id="cb25-26" title="26">    ec_liberer(&amp; ensemble);</a>
<a class="sourceLine" id="cb25-27" title="27"></a>
<a class="sourceLine" id="cb25-28" title="28">    <span class="cf">return</span> EXIT_SUCCESS;</a>
<a class="sourceLine" id="cb25-29" title="29">}</a></code></pre></div>
<p>Le programme affiche également le contenu interne de l’ensemble de chaînes, ce qui nous facilitera les explications.</p>
<pre><code>-&gt; taille 10 (attendu = 10)
0 -&gt;
1 -&gt;    &quot;trois&quot; (10282497)
2 -&gt;    &quot;quatre&quot; (170727922)
3 -&gt;    &quot;un&quot; (2099)
4 -&gt;    &quot;six&quot; (35140)
5 -&gt;    &quot;dix&quot; (30805)
6 -&gt;    &quot;deux&quot; (522598)
7 -&gt;
8 -&gt;
9 -&gt;
10 -&gt;   &quot;huit&quot; (546666)
11 -&gt;   &quot;cinq&quot; (518715)
12 -&gt;   &quot;sept&quot; (596204)
13 -&gt;
14 -&gt;   &quot;neuf&quot; (571710)
15 -&gt;</code></pre>
<p>Nous ne présenterons que quelques opérations, les autres sont laissées en exercice.</p>
<h3 id="idée-générale"><span class="header-section-number">3.2.2</span> Idée générale</h3>
<h4 id="répartition-en-alvéoles"><span class="header-section-number">3.2.2.1</span> Répartition en alvéoles</h4>
<ul>
<li><p>les chaînes de caractères qui font partie de l’ensemble sont réparties dans des “alvéoles”.</p></li>
<li><p>les alvéoles forment un tableau, ce qui permet un accès rapide par indice.</p></li>
<li><p>le numéro de l’alvéole dans laquelle se trouve (ou devrait se trouver) une chaîne de caractères est calculé à partir du contenu de cette chaîne, par ce qu’on appelle une <strong>fonction de hachage</strong>.</p></li>
<li><p>plus précisément, le numéro d’alvéole s’obtient comme reste (opération modulo) de la division de la valeur du hachage par le nombre d’alvéoles.</p></li>
</ul>
<p><strong>Intérêt :</strong> La répartition en alvéoles permet de diviser le nombre de comparaisons nécessaires pour tester la présence d’une chaîne : on ne regarde que celles présentes dans son alvéole.</p>
<p><strong>Dans l’idéal,</strong> la fonction de hachage serait parfaite, et conduirait à une alvéole où ne se trouve qu’une chaîne.</p>
<p><strong>En pratique,</strong> on pourra avoir plusieurs chaînes dans certaines alvéoles. On va donc :</p>
<ul>
<li>prévoir qu’une alvéole contient une <code>liste</code> de chaînes,</li>
<li>avoir un grand nombre d’alvéoles de façon à avoir statistiquement peu de chaînes par alvéole.</li>
</ul>
<h3 id="agrandissement-par-doublement"><span class="header-section-number">3.2.3</span> Agrandissement par doublement</h3>
<p>La stratégie choisie est de doubler le nombre d’alvéoles quand le nombre de chaînes présentes dans l’ensemble atteint certain seuil (3/4 du nombre d’alvéoles). Les chaînes sont alors redistribuées entre les alvéoles.</p>
<p>Le respect de ce seuil garantit qu’il a au maximum 0.75 chaînes par alvéole. Il y aura donc peu d’alvéoles avec plus d’une chaîne.</p>
<p>Comme pour les tableaux extensibles, la stratégie de doublement fait qu’en moyenne chaque alvéole est copiée au plus une fois.</p>
<h3 id="doublement-et-redistribution"><span class="header-section-number">3.2.4</span> Doublement et redistribution</h3>
<p>Le doublement a une autre propriété intéressante. Quand on redistribue les chaînes d’une alvéole,</p>
<ul>
<li><p>soit elles restent dans la même alvéole,</p></li>
<li><p>soit elles vont dans une alvéole “jumelle” qui vient d’être ajoutée.</p></li>
</ul>
<p><strong>Exemple :</strong> pour la chaîne <code>&quot;dix&quot;</code>, la fonction de hachage vaut 30805.</p>
<ul>
<li><p>Si il y a 4 alvéoles, elle se trouve dans l’alvéole <span class="math inline">30805 % 4 = 1</span>.</p></li>
<li><p>En passant à 8 alvéoles, elle va dans la nouvelle alvéole <span class="math inline">30805 % 8 = 5 = 4 + 1</span>.</p></li>
<li><p>En passant à 16, elle reste en <span class="math inline">30805 % 16 = 5</span>.</p></li>
<li><p>En passant à 32, elle va en <span class="math inline">30805 % 32 = 21 = 16 + 5</span>.</p></li>
<li><p>etc.</p></li>
</ul>
<p>Ceci nous autorise à redistribuer les chaînes en traitant les anciennes alvéoles une par une : on est sûr de ne pas avoir à déplacer chaque chaîne plus d’une fois.</p>
<h3 id="détails-dimplémentation"><span class="header-section-number">3.2.5</span> Détails d’implémentation</h3>
<h4 id="sémantique-de-valeur-pour-les-chaînes"><span class="header-section-number">3.2.5.1</span> Sémantique de valeur pour les chaînes</h4>
<p>Lorsqu’on appelle la fonction qui sert à ajouter une chaîne, ce qu’on veut c’est ajouter le contenu de la chaîne. Pour cela on ne peut pas se contenter de stocker l’adresse de la chaîne reçue, il faut en faire une copie.</p>
<p>Ci-dessous une erreur classique de programmation en C : si on fait ensuite afficher le tableau, on s’aperçoit qu’il ne contient pas ce qu’on pense y avoir mis :</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1">  <span class="dt">char</span> *joueurs[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="dt">char</span> nom[<span class="dv">100</span>];</a>
<a class="sourceLine" id="cb27-3" title="3">  <span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {</a>
<a class="sourceLine" id="cb27-4" title="4">    printf(<span class="st">&quot;donnez un nom :&quot;</span>);</a>
<a class="sourceLine" id="cb27-5" title="5">    scanf(<span class="st">&quot;%s&quot;</span>, nom);</a>
<a class="sourceLine" id="cb27-6" title="6">    joueurs[i] = nom;       <span class="co">// une erreur de débutant</span></a>
<a class="sourceLine" id="cb27-7" title="7">}</a></code></pre></div>
<p>puisqu’on a stocké 10 fois l’adresse de la même variable locale <code>nom</code>…</p>
<p>Lors de l’ajout d’une chaîne, on stocke donc en réalité <em>une copie</em> obtenue par <code>strdup()</code>. Cette copie est une ressource appartenant à l’ensemble, et sera libérée quand</p>
<ul>
<li><p>on retire une chaîne de l’ensemble</p></li>
<li><p>on libère l’ensemble</p></li>
</ul>
<h4 id="structure-des-alvéoles"><span class="header-section-number">3.2.5.2</span> Structure des alvéoles</h4>
<p>Nous choisissons de représenter les alvéoles, qui en principe ne contiendront que peu d’éléments (moins de <span class="math inline">0.75</span> en moyenne), par des <strong>listes chaînées non ordonnées</strong>.</p>
<h3 id="choix-de-la-fonction-de-hachage"><span class="header-section-number">3.2.6</span> Choix de la fonction de hachage</h3>
<p>Une fonction de hachage retourne un nombre non signé, parce qu’elle sert à calculer un indice (entier positif ou nul) comme reste d’une division entière.</p>
<p>Ce modulo (par une puissance de 2) fait qu’on utilise comme indice les bits de poids faible de la valeur retournée. Il est important que ces bits soient, autant que possible, dépendants de tous les caractères de la chaîne.</p>
<p>Un contre-exemple pour illustrer cette notion. Si le hachage était calculé ainsi</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="dt">unsigned</span> <span class="dt">int</span> hash = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-2" title="2">    <span class="cf">for</span> (<span class="dt">const</span> <span class="dt">char</span> *c = chaine; *c != '\<span class="dv">0</span>'; c++) {</a>
<a class="sourceLine" id="cb28-3" title="3">        hash = <span class="dv">16</span> * hash + *c;               <span class="co">// mauvais</span></a>
<a class="sourceLine" id="cb28-4" title="4">    }</a></code></pre></div>
<p>à cause du décalage produit par la multiplication par 16, les 4 bits de droite ne dépendraient que du dernier caractère de la chaîne; les 8 bits de droite des deux derniers, etc. Les chaînes <code>&quot;sept&quot;</code> et <code>&quot;huit&quot;</code> se retrouveraient toujours dans la même alvéole, pour les ensembles qui ont moins de 256 alvéoles. Idem pour <code>&quot;six&quot;</code> et <code>&quot;dix&quot;</code>. Et à partir d’une certaine taille, les premiers octets de la chaîne seront sans influence sur le résultat (ils seront perdus dans le débordement).</p>
<p>La multiplication par 17 (= 16 + 1) garantit que chaque octet de la chaîne a une influence sur les bits de poids faible du résultat de la fonction de hachage.</p>
<h3 id="code-source"><span class="header-section-number">3.2.7</span> Code source</h3>
<p><strong>Entête</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">// ens_chaines.h</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="pp">#ifndef ENS_CHAINE_H</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="pp">#define ENS_CHAINE_H</span></a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="kw">struct</span> ens_alveole;            <span class="co">// prédéclaration</span></a>
<a class="sourceLine" id="cb29-7" title="7"></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="kw">struct</span> ens_chaines {</a>
<a class="sourceLine" id="cb29-9" title="9">    <span class="dt">int</span> nb_alveoles;</a>
<a class="sourceLine" id="cb29-10" title="10">    <span class="dt">int</span> nb_elements;</a>
<a class="sourceLine" id="cb29-11" title="11">    <span class="kw">struct</span> ens_alveole *alveoles;</a>
<a class="sourceLine" id="cb29-12" title="12">};</a>
<a class="sourceLine" id="cb29-13" title="13"></a>
<a class="sourceLine" id="cb29-14" title="14"></a>
<a class="sourceLine" id="cb29-15" title="15"><span class="dt">void</span> ec_init   (<span class="kw">struct</span> ens_chaines *e);</a>
<a class="sourceLine" id="cb29-16" title="16"><span class="dt">void</span> ec_ajouter(<span class="kw">struct</span> ens_chaines *e,</a>
<a class="sourceLine" id="cb29-17" title="17">        <span class="dt">const</span> <span class="dt">char</span> *chaine);</a>
<a class="sourceLine" id="cb29-18" title="18"></a>
<a class="sourceLine" id="cb29-19" title="19"><span class="dt">int</span> ec_taille  (<span class="dt">const</span> <span class="kw">struct</span> ens_chaines *e);</a>
<a class="sourceLine" id="cb29-20" title="20"><span class="dt">void</span> ec_dump   (<span class="dt">const</span> <span class="kw">struct</span> ens_chaines *e);</a>
<a class="sourceLine" id="cb29-21" title="21"></a>
<a class="sourceLine" id="cb29-22" title="22"><span class="dt">void</span> ec_liberer(<span class="kw">struct</span> ens_chaines *e);</a>
<a class="sourceLine" id="cb29-23" title="23"></a>
<a class="sourceLine" id="cb29-24" title="24"><span class="pp">#endif</span></a></code></pre></div>
<p><strong>Code</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="pp">#include </span><span class="im">&quot;ens_chaines.h&quot;</span></a>
<a class="sourceLine" id="cb30-6" title="6"></a>
<a class="sourceLine" id="cb30-7" title="7"></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="kw">struct</span> ens_cellule {</a>
<a class="sourceLine" id="cb30-9" title="9">    <span class="dt">char</span> * chaine;</a>
<a class="sourceLine" id="cb30-10" title="10">    <span class="kw">struct</span> ens_cellule *suivant;</a>
<a class="sourceLine" id="cb30-11" title="11">};</a>
<a class="sourceLine" id="cb30-12" title="12"></a>
<a class="sourceLine" id="cb30-13" title="13"><span class="kw">struct</span> ens_alveole {</a>
<a class="sourceLine" id="cb30-14" title="14">    <span class="kw">struct</span> ens_cellule *premier;</a>
<a class="sourceLine" id="cb30-15" title="15">};</a>
<a class="sourceLine" id="cb30-16" title="16"></a>
<a class="sourceLine" id="cb30-17" title="17"></a>
<a class="sourceLine" id="cb30-18" title="18"><span class="pp">#define NOMBRE_MIN_ALVEOLES 4</span></a>
<a class="sourceLine" id="cb30-19" title="19"></a>
<a class="sourceLine" id="cb30-20" title="20"><span class="dt">void</span> ec_init(<span class="kw">struct</span> ens_chaines *e)</a>
<a class="sourceLine" id="cb30-21" title="21">{</a>
<a class="sourceLine" id="cb30-22" title="22">    e-&gt;nb_elements = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-23" title="23">    e-&gt;nb_alveoles = NOMBRE_MIN_ALVEOLES;</a>
<a class="sourceLine" id="cb30-24" title="24">    e-&gt;alveoles = malloc(e-&gt;nb_alveoles</a>
<a class="sourceLine" id="cb30-25" title="25">             * <span class="kw">sizeof</span> (<span class="kw">struct</span> ens_alveole));</a>
<a class="sourceLine" id="cb30-26" title="26">}</a>
<a class="sourceLine" id="cb30-27" title="27"></a>
<a class="sourceLine" id="cb30-28" title="28"><span class="dt">static</span> <span class="dt">unsigned</span> <span class="dt">int</span> ec_hash(<span class="dt">const</span> <span class="dt">char</span> * chaine)</a>
<a class="sourceLine" id="cb30-29" title="29">{</a>
<a class="sourceLine" id="cb30-30" title="30">    <span class="dt">unsigned</span> <span class="dt">int</span> hash = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-31" title="31">    <span class="cf">for</span> (<span class="dt">const</span> <span class="dt">char</span> *c = chaine; *c != '\<span class="dv">0</span>'; c++) {</a>
<a class="sourceLine" id="cb30-32" title="32">        hash = <span class="dv">17</span> * hash + *c;</a>
<a class="sourceLine" id="cb30-33" title="33">    }</a>
<a class="sourceLine" id="cb30-34" title="34">    <span class="cf">return</span> hash;</a>
<a class="sourceLine" id="cb30-35" title="35">}</a>
<a class="sourceLine" id="cb30-36" title="36"></a>
<a class="sourceLine" id="cb30-37" title="37"><span class="dt">static</span> <span class="dt">void</span> ec_doubler_nb_alveoles(<span class="kw">struct</span> ens_chaines *e)</a>
<a class="sourceLine" id="cb30-38" title="38">{</a>
<a class="sourceLine" id="cb30-39" title="39">    <span class="dt">int</span> na = e-&gt;nb_alveoles; <span class="co">// avant agrandissement</span></a>
<a class="sourceLine" id="cb30-40" title="40">    e-&gt;nb_alveoles *= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb30-41" title="41">    </a>
<a class="sourceLine" id="cb30-42" title="42">    <span class="dt">int</span> taille =</a>
<a class="sourceLine" id="cb30-43" title="43">    e-&gt;nb_alveoles * <span class="kw">sizeof</span> (<span class="kw">struct</span> ens_alveole); </a>
<a class="sourceLine" id="cb30-44" title="44">    e-&gt;alveoles = realloc(e-&gt;alveoles, taille);</a>
<a class="sourceLine" id="cb30-45" title="45">        </a>
<a class="sourceLine" id="cb30-46" title="46"></a>
<a class="sourceLine" id="cb30-47" title="47">    <span class="co">// initialisation de nouvelles alvéoles</span></a>
<a class="sourceLine" id="cb30-48" title="48">    <span class="cf">for</span> (<span class="dt">int</span> i = na; i &lt; e-&gt;nb_alveoles; i++) {</a>
<a class="sourceLine" id="cb30-49" title="49">        e-&gt;alveoles[i].premier = NULL;</a>
<a class="sourceLine" id="cb30-50" title="50">    }</a>
<a class="sourceLine" id="cb30-51" title="51"></a>
<a class="sourceLine" id="cb30-52" title="52">    <span class="co">// reclassement des éléments des anciennes alvéoles</span></a>
<a class="sourceLine" id="cb30-53" title="53">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; na; i++) {</a>
<a class="sourceLine" id="cb30-54" title="54">        <span class="kw">struct</span> ens_cellule *premier</a>
<a class="sourceLine" id="cb30-55" title="55">        = e-&gt;alveoles[i].premier;</a>
<a class="sourceLine" id="cb30-56" title="56">        e-&gt;alveoles[i].premier = NULL;</a>
<a class="sourceLine" id="cb30-57" title="57">    </a>
<a class="sourceLine" id="cb30-58" title="58">        <span class="cf">while</span> (premier != NULL) {</a>
<a class="sourceLine" id="cb30-59" title="59">            <span class="kw">struct</span> ens_cellule *c = premier;</a>
<a class="sourceLine" id="cb30-60" title="60">            premier = premier-&gt;suivant;</a>
<a class="sourceLine" id="cb30-61" title="61">            <span class="dt">int</span> num_alveole</a>
<a class="sourceLine" id="cb30-62" title="62">        = ec_hash(c-&gt;chaine) % (e-&gt;nb_alveoles);</a>
<a class="sourceLine" id="cb30-63" title="63">        <span class="kw">struct</span> ens_alveole *a</a>
<a class="sourceLine" id="cb30-64" title="64">        = &amp;( e-&gt;alveoles[num_alveole] );</a>
<a class="sourceLine" id="cb30-65" title="65">            c-&gt;suivant = a-&gt;premier;</a>
<a class="sourceLine" id="cb30-66" title="66">            a-&gt;premier = c;</a>
<a class="sourceLine" id="cb30-67" title="67">        }</a>
<a class="sourceLine" id="cb30-68" title="68">    }</a>
<a class="sourceLine" id="cb30-69" title="69">}</a>
<a class="sourceLine" id="cb30-70" title="70"></a>
<a class="sourceLine" id="cb30-71" title="71"><span class="dt">void</span> ec_ajouter(<span class="kw">struct</span> ens_chaines *e, <span class="dt">const</span> <span class="dt">char</span> *chaine)</a>
<a class="sourceLine" id="cb30-72" title="72">{</a>
<a class="sourceLine" id="cb30-73" title="73">    <span class="dt">int</span> num_alveole = ec_hash(chaine) % (e-&gt;nb_alveoles);</a>
<a class="sourceLine" id="cb30-74" title="74">    <span class="kw">struct</span> ens_alveole * a = &amp;(e-&gt;alveoles[num_alveole]);</a>
<a class="sourceLine" id="cb30-75" title="75"></a>
<a class="sourceLine" id="cb30-76" title="76">    <span class="co">// sortie si déjà present</span></a>
<a class="sourceLine" id="cb30-77" title="77">    <span class="cf">for</span> (<span class="kw">struct</span> ens_cellule *c = a-&gt;premier;</a>
<a class="sourceLine" id="cb30-78" title="78">     c != NULL;</a>
<a class="sourceLine" id="cb30-79" title="79">     c = c-&gt;suivant) {</a>
<a class="sourceLine" id="cb30-80" title="80">        <span class="cf">if</span> (strcmp(c-&gt;chaine, chaine) == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb30-81" title="81">            <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb30-82" title="82">        }</a>
<a class="sourceLine" id="cb30-83" title="83">    }</a>
<a class="sourceLine" id="cb30-84" title="84"></a>
<a class="sourceLine" id="cb30-85" title="85">    <span class="co">// Ajout nouvelle cellule avec copie de chaîne</span></a>
<a class="sourceLine" id="cb30-86" title="86">    <span class="kw">struct</span> ens_cellule *nc</a>
<a class="sourceLine" id="cb30-87" title="87">    = malloc(<span class="kw">sizeof</span> (<span class="kw">struct</span> ens_cellule));</a>
<a class="sourceLine" id="cb30-88" title="88">    nc-&gt;chaine = strdup(chaine);</a>
<a class="sourceLine" id="cb30-89" title="89">    nc-&gt;suivant = a-&gt;premier;</a>
<a class="sourceLine" id="cb30-90" title="90">    a-&gt;premier = nc;</a>
<a class="sourceLine" id="cb30-91" title="91">    e-&gt;nb_elements += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb30-92" title="92"></a>
<a class="sourceLine" id="cb30-93" title="93">    <span class="co">// besoin d'agrandir ?</span></a>
<a class="sourceLine" id="cb30-94" title="94">    <span class="cf">if</span> (e-&gt;nb_elements &gt;= (<span class="dv">3</span> * e-&gt;nb_alveoles) / <span class="dv">4</span>) {</a>
<a class="sourceLine" id="cb30-95" title="95">        ec_doubler_nb_alveoles(e);</a>
<a class="sourceLine" id="cb30-96" title="96">    }</a>
<a class="sourceLine" id="cb30-97" title="97">}</a>
<a class="sourceLine" id="cb30-98" title="98"></a>
<a class="sourceLine" id="cb30-99" title="99"><span class="dt">void</span> ec_liberer(<span class="kw">struct</span> ens_chaines *e)</a>
<a class="sourceLine" id="cb30-100" title="100">{</a>
<a class="sourceLine" id="cb30-101" title="101">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; e-&gt;nb_alveoles; i++) {</a>
<a class="sourceLine" id="cb30-102" title="102">        <span class="kw">struct</span> ens_cellule *premier</a>
<a class="sourceLine" id="cb30-103" title="103">        = e-&gt;alveoles[i].premier;</a>
<a class="sourceLine" id="cb30-104" title="104">        <span class="cf">while</span> (premier != NULL) {</a>
<a class="sourceLine" id="cb30-105" title="105">            <span class="kw">struct</span> ens_cellule *c = premier;</a>
<a class="sourceLine" id="cb30-106" title="106">            premier = premier-&gt;suivant;</a>
<a class="sourceLine" id="cb30-107" title="107">            free(c-&gt;chaine);</a>
<a class="sourceLine" id="cb30-108" title="108">            free(c);</a>
<a class="sourceLine" id="cb30-109" title="109">        }</a>
<a class="sourceLine" id="cb30-110" title="110">    }</a>
<a class="sourceLine" id="cb30-111" title="111">    free(e-&gt;alveoles);</a>
<a class="sourceLine" id="cb30-112" title="112">    <span class="co">// par précaution </span></a>
<a class="sourceLine" id="cb30-113" title="113">    e-&gt;nb_alveoles = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-114" title="114">    e-&gt;nb_elements = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-115" title="115">    e-&gt;alveoles = NULL;</a>
<a class="sourceLine" id="cb30-116" title="116">}</a>
<a class="sourceLine" id="cb30-117" title="117"></a>
<a class="sourceLine" id="cb30-118" title="118"><span class="dt">int</span> ec_taille(<span class="dt">const</span> <span class="kw">struct</span> ens_chaines *e)</a>
<a class="sourceLine" id="cb30-119" title="119">{</a>
<a class="sourceLine" id="cb30-120" title="120">    <span class="cf">return</span> e-&gt;nb_elements;</a>
<a class="sourceLine" id="cb30-121" title="121">}</a>
<a class="sourceLine" id="cb30-122" title="122"></a>
<a class="sourceLine" id="cb30-123" title="123"><span class="dt">void</span> ec_dump(<span class="dt">const</span> <span class="kw">struct</span> ens_chaines *e)</a>
<a class="sourceLine" id="cb30-124" title="124">{</a>
<a class="sourceLine" id="cb30-125" title="125">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; e-&gt;nb_alveoles; i++) {</a>
<a class="sourceLine" id="cb30-126" title="126">        printf(<span class="st">&quot;%d -&gt;&quot;</span>, i);</a>
<a class="sourceLine" id="cb30-127" title="127">        <span class="cf">for</span> (<span class="kw">struct</span> ens_cellule *c = e-&gt;alveoles[i].premier;</a>
<a class="sourceLine" id="cb30-128" title="128">                c != NULL; c = c-&gt;suivant) {</a>
<a class="sourceLine" id="cb30-129" title="129">            printf(<span class="st">&quot;</span><span class="sc">\t\&quot;</span><span class="st">%s</span><span class="sc">\&quot;</span><span class="st"> (%u)&quot;</span>,</a>
<a class="sourceLine" id="cb30-130" title="130">           c-&gt;chaine,</a>
<a class="sourceLine" id="cb30-131" title="131">           ec_hash(c-&gt;chaine));</a>
<a class="sourceLine" id="cb30-132" title="132">        }</a>
<a class="sourceLine" id="cb30-133" title="133">        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb30-134" title="134">    }</a>
<a class="sourceLine" id="cb30-135" title="135">}</a></code></pre></div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Presque toujours. Il y a des complications sur les machines dont les mots sont de 36 bits, etc.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Il a été nommé <code>char</code> à une époque où le codage d’un caractère tenait toujours sur un octet (codages ANSI, EBCDIC, ...). Si c’était à refaire, ce type s’appellerait certainement <code>byte</code>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Il s’agit ici des <em>adresses virtuelles</em>, dans l’espace mémoire où le système a chargé le processus.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Sur une machine qui supporte la notion de segmentation, évidemment. Ce n’est pas le cas des petits micro-contrôleurs dans le domaine de l’informatique embarquée<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>C’est une mesure de sécurité pour éviter l’exploitation de “débordements de tampon” et autres erreurs de programmation. Lors du chargement d’un programme, le système d’exploitation choisit des adresses aléatoires pour placer les segments dans l’espace mémoire virtuel du processus.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Ce terme est aussi (hélas) souvent employé par extension pour désigner les adresses elles-mêmes. Nous essaierons d’éviter ce regrettable manque de rigueur, source de confusions, qui permettrait d’écrire qu’un pointeur (au sens de variable) <em>contient</em> un pointeur (au sens d’adresse)…<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>le premier a l’indice 0...<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p>Ne pas confondre avec un pointeur non-initialisé, qui contient une valeur aléatoire<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p>à la place d’un indice<a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p>la valeur numérique du pointeur - celle qu’on voit avec <code>printf</code> - est augmentée de la taille du type pointé (ici 1, parce que c’est un <code>char</code>.<a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p>autre que les limitations de l’allocation dynamique<a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>pour les deux raisons évoquées plus haut : - c’est obligatoire pour les fonctions qui modifient le tableau - c’est souhaitable pour les autres, pour éviter de faire des copies. Dans ce cas on mettra un <code>const</code>.<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p>fini, donné par extension<a href="#fnref13" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
