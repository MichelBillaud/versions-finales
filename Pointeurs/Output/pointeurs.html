<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Michel Billaud" />
  <title>Pour en finir avec les pointeurs en C</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">a.sourceLine {
display: inline-block;
line-height: 1.25;
}
a.sourceLine {
pointer-events: none;
color: inherit;
text-decoration: inherit;
}
a.sourceLine:empty {
height: 1.2em;
}
.sourceCode {
overflow: visible;
}
code.sourceCode {
white-space: pre;
position: relative;
}
div.sourceCode {
margin: 1em 0;
}
pre.sourceCode {
margin: 0;
}
@media screen {
div.sourceCode {
overflow: auto;
}
}
@media print {
code.sourceCode {
white-space: pre-wrap;
}
a.sourceLine {
text-indent: -1em;
padding-left: 1em;
}
}
pre.numberSource a.sourceLine {
position: relative;
left: -4em;
}
pre.numberSource a.sourceLine::before {
content: attr(title);
position: relative;
left: -1em;
text-align: right;
vertical-align: baseline;
border: none;
pointer-events: all;
display: inline-block;
-webkit-touch-callout: none;
-webkit-user-select: none;
-khtml-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
padding: 0 4px;
width: 4em;
color: #aaaaaa;
}
pre.numberSource {
margin-left: 3em;
border-left: 1px solid #aaaaaa;
padding-left: 4px;
}
div.sourceCode {}
@media screen {
a.sourceLine::before {
text-decoration: underline;
}
}
code span.al {
color: #ff0000;
font-weight: bold;
}

code span.an {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.at {
color: #7d9029;
}

code span.bn {
color: #40a070;
}

code span.bu {}

code span.cf {
color: #007020;
font-weight: bold;
}

code span.ch {
color: #4070a0;
}

code span.cn {
color: #880000;
}

code span.co {
color: #60a0b0;
font-style: italic;
}

code span.cv {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.do {
color: #ba2121;
font-style: italic;
}

code span.dt {
color: #902000;
}

code span.dv {
color: #40a070;
}

code span.er {
color: #ff0000;
font-weight: bold;
}

code span.ex {}

code span.fl {
color: #40a070;
}

code span.fu {
color: #06287e;
}

code span.im {}

code span.in {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}

code span.kw {
color: #007020;
font-weight: bold;
}

code span.op {
color: #666666;
}

code span.ot {
color: #007020;
}

code span.pp {
color: #bc7a00;
}

code span.sc {
color: #4070a0;
}

code span.ss {
color: #bb6688;
}

code span.st {
color: #4070a0;
}

code span.va {
color: #19177c;
}

code span.vs {
color: #4070a0;
}

code span.wa {
color: #60a0b0;
font-weight: bold;
font-style: italic;
}


:root {
--title-color: #202080;
--source-bg-color: rgb(240, 240, 255);
}
h1, h2, h3, h4, h5, h6 {
border-bottom: solid 1px silver;
color: var(--title-color);
}
body {
font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}
div.sourceCode {
background-color: var(--source-bg-color);
padding: 1em;
}
#TOC {
padding: 0.5em;
border: solid 1px silver;
}
#TOC ul {
list-style-type: none;
padding-left: 1em;
}
nav:before {
text-indent: 2em;
content: "Sommaire";
color: var(--title-color);
font-weight: bold;
font-size: large;
}
#TOC a {
text-decoration: none;
}
header {
text-align: center;
}
.title {
}
.author, .date {
font-style: italic;
}
table, th, td {
border-collapse: collapse;
border: solid black 1px;
padding: 0.5em;
}
</style>
</head>
<body>
<header>
<h1 class="title">Pour en finir avec les pointeurs en C</h1>
<p class="author">Michel Billaud</p>
<p class="date">17-07-2021</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#les-bases-adresses-pointeurs-et-indirection"><span class="toc-section-number">1</span> Les bases : adresses, pointeurs et indirection</a><ul>
<li><a href="#notion-dadresse"><span class="toc-section-number">1.1</span> Notion d’adresse</a></li>
<li><a href="#les-adresses-comme-valeurs"><span class="toc-section-number">1.2</span> Les adresses comme valeurs</a></li>
<li><a href="#et-les-pointeurs"><span class="toc-section-number">1.3</span> Et les pointeurs ?</a></li>
<li><a href="#a-quoi-vont-me-servir-les-pointeurs"><span class="toc-section-number">1.4</span> A quoi vont me servir les pointeurs ?</a></li>
<li><a href="#létoile-opérateur-dindirection"><span class="toc-section-number">1.5</span> L’étoile <code>*</code>, opérateur d’indirection</a></li>
<li><a href="#relation-entre-usage-et-déclaration-de-variable"><span class="toc-section-number">1.6</span> Relation entre usage et déclaration de variable</a></li>
<li><a href="#la-constante-null"><span class="toc-section-number">1.7</span> La constante <code>NULL</code></a></li>
<li><a href="#petits-exercices"><span class="toc-section-number">1.8</span> Petits exercices</a><ul>
<li><a href="#échanger-deux-nombres-exercice-guidé"><span class="toc-section-number">1.8.1</span> Échanger deux nombres (exercice guidé)</a></li>
<li><a href="#ordonner-deux-variables"><span class="toc-section-number">1.8.2</span> Ordonner deux variables</a></li>
</ul></li>
<li><a href="#complément-pointeurs-vers-des-structures-la-notation-flèche"><span class="toc-section-number">1.9</span> Complément : pointeurs vers des structures, la notation “flèche”</a></li>
</ul></li>
<li><a href="#pointeurs-de-fonctions"><span class="toc-section-number">2</span> Pointeurs de fonctions</a><ul>
<li><a href="#la-logique"><span class="toc-section-number">2.1</span> La logique</a></li>
<li><a href="#déclarer-un-type-pour-les-fonctions-typedef"><span class="toc-section-number">2.2</span> Déclarer un type pour les fonctions (<code>typedef</code>)</a></li>
<li><a href="#fonctions-qui-retournent-des-fonctions"><span class="toc-section-number">2.3</span> Fonctions qui retournent des fonctions</a></li>
<li><a href="#une-application-table-dactions"><span class="toc-section-number">2.4</span> Une application : table d’actions</a></li>
</ul></li>
<li><a href="#les-pointeurs-et-les-tableaux"><span class="toc-section-number">3</span> Les pointeurs et les tableaux</a><ul>
<li><a href="#quest-ce-quun-tableau"><span class="toc-section-number">3.1</span> Qu’est-ce qu’un tableau ?</a></li>
<li><a href="#compatibilité-entre-tableaux-et-pointeurs"><span class="toc-section-number">3.2</span> Compatibilité entre tableaux et pointeurs</a></li>
<li><a href="#la-notation-pointeurentier"><span class="toc-section-number">3.3</span> La notation <em>pointeur+entier</em></a></li>
<li><a href="#larithmétique-des-pointeurs"><span class="toc-section-number">3.4</span> L’arithmétique des pointeurs</a></li>
<li><a href="#retour-sur-les-expressions-indicées"><span class="toc-section-number">3.5</span> Retour sur les expressions indicées</a></li>
<li><a href="#les-chaînes-de-caractères"><span class="toc-section-number">3.6</span> Les chaînes de caractères</a></li>
</ul></li>
<li><a href="#un-exemple-avec-tout-ça"><span class="toc-section-number">4</span> Un exemple avec tout ça</a><ul>
<li><a href="#objectif-gestion-de-stocks"><span class="toc-section-number">4.1</span> Objectif : gestion de stocks</a></li>
<li><a href="#les-fonctions-qui-agissent-sur-un-stock"><span class="toc-section-number">4.2</span> Les fonctions qui agissent sur un Stock</a></li>
<li><a href="#le-source"><span class="toc-section-number">4.3</span> Le source</a></li>
<li><a href="#travail-proposé"><span class="toc-section-number">4.4</span> Travail proposé</a></li>
<li><a href="#indications-pour-la-compilation-séparée"><span class="toc-section-number">4.5</span> Indications pour la compilation séparée</a></li>
</ul></li>
<li><a href="#pointeurs-et-typage"><span class="toc-section-number">5</span> Pointeurs et typage</a><ul>
<li><a href="#les-pointeurs-sont-typés"><span class="toc-section-number">5.1</span> Les pointeurs sont typés</a></li>
<li><a href="#pointeurs-génériques"><span class="toc-section-number">5.2</span> Pointeurs génériques</a><ul>
<li><a href="#exemple-dutilisation"><span class="toc-section-number">5.2.1</span> Exemple d’utilisation</a></li>
<li><a href="#comment-afficher-en-hexadécimal-le-contenu-dune-zone-mémoire"><span class="toc-section-number">5.2.2</span> Comment afficher en hexadécimal le contenu d’une zone mémoire ?</a></li>
<li><a href="#pointeurs-génériques-le-type-void"><span class="toc-section-number">5.2.3</span> Pointeurs génériques : le type <code>void*</code></a></li>
</ul></li>
<li><a href="#conversions-explicites-de-pointeurs-transtypage-typecast"><span class="toc-section-number">5.3</span> Conversions explicites de pointeurs (transtypage, <em>typecast</em>)</a></li>
</ul></li>
<li><a href="#lallocation-dynamique"><span class="toc-section-number">6</span> L’allocation dynamique</a><ul>
<li><a href="#préliminaires-durée-de-vie-des-variables"><span class="toc-section-number">6.1</span> Préliminaires, durée de vie des variables</a></li>
<li><a href="#allocation-et-libération-en-c"><span class="toc-section-number">6.2</span> Allocation et libération en C</a></li>
<li><a href="#un-exemple-fabrication-dune-table"><span class="toc-section-number">6.3</span> Un exemple : fabrication d’une table</a></li>
<li><a href="#détection-derreur-stratégies-de-récupération."><span class="toc-section-number">6.4</span> Détection d’erreur, stratégies de récupération.</a></li>
</ul></li>
<li><a href="#une-application-de-lallocation-dynamique-un-tableau-extensible"><span class="toc-section-number">7</span> Une application de l’allocation dynamique : un tableau extensible</a><ul>
<li><a href="#quest-ce-que-cest"><span class="toc-section-number">7.1</span> Qu’est-ce que c’est ?</a></li>
<li><a href="#définition-du-type-fonctions-de-base"><span class="toc-section-number">7.2</span> Définition du type, fonctions de base</a></li>
<li><a href="#re-dimensionnement"><span class="toc-section-number">7.3</span> Re-dimensionnement</a></li>
<li><a href="#exercice-écrire-un-test"><span class="toc-section-number">7.4</span> Exercice : écrire un test</a></li>
<li><a href="#exercice-écrire-la-fonction-array_resize-sans-realloc."><span class="toc-section-number">7.5</span> Exercice : écrire la fonction <code>array_resize</code> sans <code>realloc</code>.</a></li>
</ul></li>
<li><a href="#chaînages"><span class="toc-section-number">8</span> Chaînages</a><ul>
<li><a href="#notions-de-base-les-listes-simples"><span class="toc-section-number">8.1</span> Notions de base : les listes simples</a></li>
<li><a href="#pour-parcourir-une-liste"><span class="toc-section-number">8.2</span> Pour parcourir une liste</a></li>
<li><a href="#pour-construire-une-chaîne-vide"><span class="toc-section-number">8.3</span> Pour construire une chaîne vide</a></li>
<li><a href="#pour-ajouter-un-élément-en-tête"><span class="toc-section-number">8.4</span> Pour ajouter un élément en tête</a></li>
<li><a href="#pour-retirer-le-premier-élément"><span class="toc-section-number">8.5</span> Pour retirer le premier élément</a></li>
</ul></li>
<li><a href="#réalisation-dune-pile-par-chaînages"><span class="toc-section-number">9</span> Réalisation d’une pile par chaînages</a><ul>
<li><a href="#quest-ce-que-cest-1"><span class="toc-section-number">9.1</span> Qu’est-ce que c’est ?</a></li>
<li><a href="#quel-rapport-avec-les-chaînages"><span class="toc-section-number">9.2</span> Quel rapport avec les chaînages ?</a></li>
<li><a href="#travail-à-faire"><span class="toc-section-number">9.3</span> Travail à faire</a></li>
<li><a href="#limites-pratiques-de-cette-représentation"><span class="toc-section-number">9.4</span> Limites pratiques de cette représentation</a></li>
</ul></li>
<li><a href="#réalisation-dune-file-queue-par-chaînage"><span class="toc-section-number">10</span> Réalisation d’une file (Queue) par chaînage</a><ul>
<li><a href="#structures-de-données"><span class="toc-section-number">10.1</span> Structures de données</a></li>
<li><a href="#initialiser-une-file"><span class="toc-section-number">10.2</span> Initialiser une file</a></li>
<li><a href="#pour-connaître-la-valeur-de-lélement-de-tête"><span class="toc-section-number">10.3</span> Pour connaître la valeur de l’élement de tête</a></li>
<li><a href="#pour-tester-si-la-pile-est-vide"><span class="toc-section-number">10.4</span> Pour tester si la pile est vide</a></li>
<li><a href="#pour-ajouterenlever-un-élément"><span class="toc-section-number">10.5</span> Pour ajouter/enlever un élément</a></li>
<li><a href="#code-de-test"><span class="toc-section-number">10.6</span> Code de test</a></li>
<li><a href="#liste-à-double-chaînage"><span class="toc-section-number">10.7</span> Liste à double chaînage</a></li>
</ul></li>
<li><a href="#liste-ordonnée-priorityqueue"><span class="toc-section-number">11</span> Liste ordonnée (<em>PriorityQueue</em>)</a><ul>
<li><a href="#un-peu-dordre-dans-les-pensées"><span class="toc-section-number">11.1</span> Un peu d’ordre dans les pensées</a></li>
<li><a href="#a-la-recherche-du-dernier-élément-inférieur"><span class="toc-section-number">11.2</span> A la recherche du dernier élément inférieur</a></li>
<li><a href="#insertion"><span class="toc-section-number">11.3</span> Insertion</a></li>
</ul></li>
<li><a href="#conclusion"><span class="toc-section-number">12</span> Conclusion</a></li>
</ul>
</nav>
<p><strong>Pourquoi ce document ?</strong> Les débutants se prennent souvent la tête avec les pointeurs, un sujet considéré comme “avancé” et “difficile”.</p>
<p>Il y a souvent une bonne raison à cela : de trop nombreux cours et tutoriels en ligne (je vais éviter de donner des noms pour me fâcher avec personne) prenne ça par le mauvais bout. C’est très mal expliqué, au mauvais moment, et en mélangeant différents aspects :</p>
<ul>
<li>ce que c’est,</li>
<li>les opérations qu’on peut faire dessus en C,</li>
<li>l’usage qu’on en a pour constituer des structures de données (chaînages),</li>
<li>les difficultés d’ordre algorithmique qui s’en suivent.</li>
</ul>
<p>En réalité, les pointeurs ne sont pas intrinsèquement “difficiles”. La définition, c’est simplement</p>
<blockquote>
<p>un pointeur est une donnée qui contient l’adresse d’une autre donnée.</p>
</blockquote>
<p>Le problème, c’est qu’on s’en sert pour faire beaucoup de choses (presque tout, en fait, quand on programme en C), et donc qu’il faut toucher à pas mal de choses qui font usage des pointeurs. C’est un sujet <em>riche</em>.</p>
<p><strong>Orientation</strong> : Je n’ai pas voulu faire un cours de C pour débutants complets. Je suppose que le lecteur a commencé à apprendre C (variables, tableaux, fonctions, boucles, structures….), et qu’il veut des explications sur les pointeurs : le sujet est assez vaste comme ça, sans avoir besoin de reprendre tout à zéro.</p>
<p><strong>Contact</strong> : Vous pouvez me contacter (<a href="mailto:michel.billaud@laposte.net">michel.billaud@laposte.net</a>) pour toutes remarques, critiques, questions, propositions (honnêtes), contributions, etc.</p>
<p><strong>Copyright</strong> : il faut que je me mette à jour sur les différents copyrights. Disons que si vous utilisez une partie significative d’un document, ça parait normal que vous le citiez en référence l’auteur, le titre et le lien où vous l’avez trouvé <a href="https://www.labri.fr/perso/billaud/travaux/Pointeurs/pointeurs.html" class="uri">https://www.labri.fr/perso/billaud/travaux/Pointeurs/pointeurs.html</a>, <a href="https://www.mbillaud.fr/dernieres-versions/Pointeurs" class="uri">https://www.mbillaud.fr/dernieres-versions/Pointeurs</a>,…</p>
<p>Je n’ai pas l’intention de devenir riche en vendant mes oeuvres, c’est juste que si vous trouvez qu’un bout est suffisamment intéressant pour que vous vous en inspiriez largement, votre lecteur aura peut-être envie, lui aussi, d’aller voir le document en entier.</p>
<p>Amusez-vous bien !</p>
<p><strong>Versions</strong></p>
<ul>
<li>initiale : 25 septembre 2017</li>
<li>corrections typos : 3-4 février 2019</li>
<li>corrections : 29 décembre 2020</li>
<li>corrections : 24 juin 2021 (remerciements à Valentin Morel).</li>
</ul>
<h1 id="les-bases-adresses-pointeurs-et-indirection"><span class="header-section-number">1</span> Les bases : adresses, pointeurs et indirection</h1>
<h2 id="notion-dadresse"><span class="header-section-number">1.1</span> Notion d’adresse</h2>
<p>Vous comprenez certainement le programme suivant</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1-4" title="4">{</a>
<a class="sourceLine" id="cb1-5" title="5">    printf(<span class="st">&quot;quel est votre âge ?</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="dt">int</span> age;</a>
<a class="sourceLine" id="cb1-7" title="7">    scanf(<span class="st">&quot;%d&quot;</span>, &amp; age);</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="dt">int</span> annee = <span class="dv">2018</span> - age;</a>
<a class="sourceLine" id="cb1-10" title="10">    printf(<span class="st">&quot;vous etes né en %d</span><span class="sc">\n</span><span class="st">&quot;</span>, annee);</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-13" title="13">}</a></code></pre></div>
<p>Si ce n’est pas le cas, désolé, ce document n’est pas fait pour vous. Ne perdez pas votre temps, trouvez-vous un cours d’initiation à la programmation en C (ou mieux sur un langage avec lequel la programmation est plus facile à apprendre).</p>
<p>Vous savez donc que <code>scanf</code> sert à lire des données, et <code>printf</code> à afficher leur valeur. Et on vous a dit qu’il fallait mettre <code>&amp;</code> pour les variables lues par <code>scanf</code> (sauf si ce sont des chaînes), et ne pas en mettre dans la liste d’arguments de <code>printf</code>. C’est tout-à-fait vrai, on ne vous a pas menti.</p>
<p>Pour être plus précis, <code>printf</code> prend comme arguments une chaîne de caractères (le <em>format</em>) et une liste de <em>valeurs</em> à afficher.</p>
<p>Du reste on aurait pu se passer de la variable et écrire directement :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1">    printf(<span class="st">&quot;vous êtes né en %d</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">2018</span> - age);</a></code></pre></div>
<p>parce qu’on fournirait directement la valeur calculée.</p>
<p>Pour ce qui est de <code>scanf</code>, on ne lui donne évidemment pas en argument la <em>valeur</em> à lire, puisque cette valeur est fournie par l’utilisateur qui tape la réponse. Ce qu’on indique, c’est l’<em>endroit</em> où il faut la mettre. Pour cela, on transmet l’<strong>adresse</strong> de cet endroit.</p>
<p>Et la notation <code>&amp; age</code> désigne exactement ceci : l’adresse de la zone mémoire qui correspond à la variable <code>age</code>.</p>
<p>Parce que, comme vous le savez aussi, quand on déclare une variable dans une fonction, ça veut dire que quand on exécutera cette fonction, il y aura un petit bout de mémoire réservé pour cette variable.</p>
<p>Donc résumons :</p>
<ol type="1">
<li>Vous avez déjà vu, et utilisé dans vos programmes, des adresses</li>
<li>Une variable correspond à un emplacement dans la mémoire de l’ordinateur. Par exemple pour un <code>int</code>, on aura une zone de 4 ou 8 octets, sur les machines actuelles. Un <code>char</code> occupera un octet.</li>
<li>L’opérateur <code>&amp;</code> (on peut l’appeler <em>address-of</em>) retourne l’adresse d’une variable.</li>
</ol>
<h2 id="les-adresses-comme-valeurs"><span class="header-section-number">1.2</span> Les adresses comme valeurs</h2>
<p>Quand vous avez commencé à utiliser <code>scanf</code> et <code>printf</code>, vous êtes peut-être arrivé à la conclusion qu’il fallait toujours mettre <code>&amp;</code> dans un <code>scanf</code>, et jamais dans un <code>printf</code>.</p>
<p>C’était vrai pour ce que vous en faisiez, mais en fait, vous pouvez parfaitement écrire :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1">    printf(<span class="st">&quot;adresse de age =  %p&quot;</span>, &amp; age);   <span class="co">// voir note ci-dessous</span></a></code></pre></div>
<p>ce qui fait afficher l’<strong>adresse</strong> (pas la valeur) de la variable <code>age</code>.</p>
<pre><code>quel est votre âge ?
12
vous etes né en 2006
adresse de age =  0x7ffdef4accf8</code></pre>
<p>L’expression <code>&amp; age</code>, si vous préférez, c’est la <strong>valeur de l’adresse</strong>. Une adresse, c’est une position en mémoire, c’est-à-dire un numéro d’octet (la mémoire est composée d’octets repérés par leur numéro).</p>
<p>Ici, comme on a utilisé la spécification de format <code>&quot;%p&quot;</code> (avec un <code>p</code> comme pointeur), l’adresse (qui est un nombre) est affichée en hexadécimal, sous la forme “<code>0x.....</code>”. On aurait pu l’afficher en décimal <code>&quot;%ld&quot;</code>, mais en général, quand on s’intéresse à ce genre de choses, l’hexadécimal est plus pratique à utiliser.</p>
<p><strong>Note :</strong> pour se conformer strictement à la norme du langage C, il faudrait écrire</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">    printf(<span class="st">&quot;adresse de age =  %p&quot;</span>, (<span class="dt">void</span> *) &amp; age);</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="co">//                             --------</span></a></code></pre></div>
<p>pour <em>transtyper</em> explicitement l’adresse en “pointeur sur <code>void</code>”.</p>
<p>Explication : c’est nécessaire parce que la conversion de type pointeur ne se fait pas automatiquement avec la fonction <code>printf</code>, parce qu’elle est <em>variadique</em>.</p>
<p>Conseil : ne vous inquiétez pas si vous ne comprenez rien au paragraphe précédent. C’est une formule magique qui me permet d’échapper aux malédictions des puristes, qui m’accuseraient de vous fourvoyer dans des “<em>undefined behaviours</em>”. Point n’est mon intention. Vous verrez des transtypages (dont l’utilité vous apparaîtra mieux) plus loin dans ce document.</p>
<h2 id="et-les-pointeurs"><span class="header-section-number">1.3</span> Et les pointeurs ?</h2>
<p><strong>Définition :</strong> Un pointeur, c’est une variable (ou une donnée) qui contient une adresse. Ou plutôt, <em>peut</em> en contenir, parce que si le pointeur n’est pas initialisé, il contient n’importe quoi, qui n’est pas forcément une adresse <em>valide</em>.</p>
<p>On déclare un pointeur en précédant son nom par le symbole <code>*</code>. Exemple</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1">    <span class="dt">int</span> *adresse_age;</a></code></pre></div>
<p>déclare que la variable <code>adresse_age</code> est susceptible de <strong>contenir l’adresse</strong> d’un emplacement mémoire contenant lui-même un <code>int</code>.</p>
<p>On peut modifier le programme précédent pour employer cette variable :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">    <span class="dt">int</span> *adresse_age  = &amp; age;</a>
<a class="sourceLine" id="cb7-2" title="2">    ... </a>
<a class="sourceLine" id="cb7-3" title="3">    scanf(<span class="st">&quot;%d&quot;</span>, adresse_age);</a>
<a class="sourceLine" id="cb7-4" title="4">    ...</a>
<a class="sourceLine" id="cb7-5" title="5">    printf(<span class="st">&quot;adresse de age =  %p&quot;</span>, adresse_age);</a></code></pre></div>
<p>Ci-dessous une représentation des deux variables :</p>
<figure>
<img src="data:image/png;base64,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" alt="Deux variables" /><figcaption>Deux variables</figcaption>
</figure>
<p>Les rectangles figurent les emplacements occupés par des variables, et leur valeur est marquée de dedans. Pour le pointeur, au lieu d’y mettre le nombre <code>0x7ffdef4accf</code> qui n’aura pas de grande signification pour nous, on dessine une flèche vers l’emplacement qu’il désigne (l’emplacement numéro <code>0x7ffdef4accf</code>, justement).</p>
<p>On dit alors que la variable <code>adresse_age</code> <strong>pointe sur</strong> <code>age</code>. Ça veut dire qu’elle contient son adresse.</p>
<h2 id="a-quoi-vont-me-servir-les-pointeurs"><span class="header-section-number">1.4</span> A quoi vont me servir les pointeurs ?</h2>
<p>Un premier usage, c’est pour écrire des fonctions qui modifient des données. Pour cela, ces fonctions reçoivent l’adresse de la donnée à modifier.</p>
<p>Par exemple, une fonction qui demande à taper un entier compris entre deux valeurs. Exemple d’utilisation :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">    <span class="dt">int</span> age;</a>
<a class="sourceLine" id="cb8-2" title="2">    demander_entier(<span class="st">&quot;donnez votre age&quot;</span>, &amp; age, <span class="dv">0</span>, <span class="dv">150</span>);</a></code></pre></div>
<p>C’est cohérent avec la manière d’utiliser <code>scanf</code> : on fournit l’adresse de la variable <code>age</code>, que la fonction est chargée de remplir avec une valeur demandée à l’utilisateur.</p>
<p>Dans la déclaration de la fonction, le paramètre correspondant est donc un pointeur d’entier :</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> demander_entier(<span class="dt">char</span> message[], <span class="dt">int</span> *adr_variable, <span class="dt">int</span> min, <span class="dt">int</span> max);</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">//                                   ----^------------</span></a></code></pre></div>
<p>Il ne reste plus qu’à écrire cette fonction. Une première version</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">void</span> demander_entier(<span class="dt">char</span> message[], <span class="dt">int</span> *adr_variable, <span class="dt">int</span> min, <span class="dt">int</span> max)</a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">   printf (<span class="st">&quot;%s (entre %d et %d)&quot;</span>, message, min, max);</a>
<a class="sourceLine" id="cb10-4" title="4">   scanf(<span class="st">&quot;%d&quot;</span>, adr_variable);</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">//             ------------     pas de &quot;&amp;&quot;, c'est une adresse</span></a>
<a class="sourceLine" id="cb10-6" title="6">}</a></code></pre></div>
<h2 id="létoile-opérateur-dindirection"><span class="header-section-number">1.5</span> L’étoile <code>*</code>, opérateur d’indirection</h2>
<p>Pendant qu’on y est, on peut se demander comment faire afficher la valeur de l’âge <em>à partir du pointeur</em> qui contient l’adresse de la variable.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1">   <span class="dt">int</span> age;</a>
<a class="sourceLine" id="cb11-2" title="2">   <span class="dt">int</span> *adresse_age  = &amp; age;</a>
<a class="sourceLine" id="cb11-3" title="3">   ...</a>
<a class="sourceLine" id="cb11-4" title="4">   printf(<span class="st">&quot;l'age est %d</span><span class="sc">\n</span><span class="st">&quot;</span>, *adresse_age);</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co">//                          ^-----------</span></a></code></pre></div>
<p>C’est ce qu’on appelle faire une <strong>indirection</strong>. On ne veut pas faire afficher la valeur du pointeur, mais <em>la valeur de la donnée dont le pointeur contient l’adresse.</em></p>
<p><strong>Exercice</strong> : modifiez la fonction précédente pour qu’elle</p>
<ul>
<li>vérifie que le nombre tapé est bien compris dans les valeurs limites,</li>
<li>repose la question tant que ce n’est pas le cas.</li>
</ul>
<p>Indication : on mettra <code>*adr_variable</code> là où on aurait mis un entier.</p>
<h2 id="relation-entre-usage-et-déclaration-de-variable"><span class="header-section-number">1.6</span> Relation entre usage et déclaration de variable</h2>
<p>Un principe fondamental de C (et C++) est que <strong>la déclaration d’une variable ressemble à la manière de l’employer</strong>.</p>
<p>Quand on compare la variable, on écrit quelque chose comme :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1">    <span class="cf">if</span> ( *adr_variable &lt; min ) {</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="co">//   ^------------</span></a>
<a class="sourceLine" id="cb12-3" title="3">       printf(<span class="st">&quot;erreur ...&quot;</span>);</a>
<a class="sourceLine" id="cb12-4" title="4">    }</a></code></pre></div>
<p>on y emploie <code>*adr_variable</code> qui est un <code>int</code>. Donc elle est déclarée ainsi : <code>int *adr_variable</code>. C’est simple, finalement, quand on connaît le principe.</p>
<p>Si on avait un tableau <code>t</code> de 10 adresses d’entiers, <code>t[2]</code> désignerait une adresse d’entiers, et <code>*t[2]</code> un entier. Donc le tableau serait déclaré</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1">    <span class="dt">int</span> *t[<span class="dv">10</span>];</a></code></pre></div>
<p><strong>À quoi ça sert de savoir ça ?</strong> En fait, c’est lié à une erreur dans laquelle les débutants tombent souvent. C’est de considérer que la déclaration</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">int</span> * a;</a></code></pre></div>
<p>déclare <code>a</code> comme un pointeur d’entiers, et que “donc” dans</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">int</span> * a, b;</a></code></pre></div>
<p><code>b</code> serait aussi un pointeur d’entiers. Hé non, perdu. La lecture correcte, c’est que</p>
<ul>
<li><code>*a</code> et <code>b</code> sont des <code>int</code>,</li>
<li>et donc <code>a</code> est un pointeur d’entier,</li>
<li>mais pas <code>b</code>, qui est un <code>int</code>.</li>
</ul>
<p>Pour éviter les confusions, le plus sage est donc d’écrire en collant l’étoile du côté de la variable, voire de déclarer les deux variables séparément (c’est recommandé par certaines “normes de programmation”).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">int</span> *a;</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="dt">int</span> b;</a></code></pre></div>
<p>En réalitén le compilateur ne s’intéresse pas à savoir si c’est collé à gauche ou à droite, ça lui est complètement égal. Le nombre d’espaces n’est pas significatif. Si on met des espaces, c’est pour faciliter la vie de celui qui doit relire le programme. Et l’heureux gagnant qui bénéficie de votre délicate attention, ça risque d’être vous un certain temps, tant que votre programme ne marche pas. Et aussi plus tard quand il faudra le modifier.</p>
<h2 id="la-constante-null"><span class="header-section-number">1.7</span> La constante <code>NULL</code></h2>
<p>Un pointeur sert à contenir l’adresse d’une donnée. Parfois on a besoin de savoir que le pointeur ne contient <strong>pas encore</strong> (ou ne contient plus) une adresse valide.</p>
<p>Une constante spéciale, appelée <code>NULL</code> sert à représenter “l’adresse de rien du tout”. C’est utile par exemple pour initialiser un pointeur.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">int</span> *pointeur = NULL;</a>
<a class="sourceLine" id="cb17-2" title="2">...</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="cf">if</span> (pointeur != NULL) {</a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="co">// faire quelque chose avec *pointeur</span></a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb17-7" title="7">}</a></code></pre></div>
<p>Bien entendu, les choses se passeront mal si on tente de “déréférencer” (faire une indirection avec) un pointeur <code>NULL</code>. En général, le programme s’arrête avec une “violation mémoire”.</p>
<p>Nous aurons l’usage de <code>NULL</code> avec les structures de données chaînées.</p>
<h2 id="petits-exercices"><span class="header-section-number">1.8</span> Petits exercices</h2>
<h3 id="échanger-deux-nombres-exercice-guidé"><span class="header-section-number">1.8.1</span> Échanger deux nombres (exercice guidé)</h3>
<p>Vous connaissez la séquence pour échanger les valeurs contenues dans deux variables <code>a</code> et <code>b</code> :</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1">    <span class="dt">int</span> tmp = a;</a>
<a class="sourceLine" id="cb18-2" title="2">    a = b;</a>
<a class="sourceLine" id="cb18-3" title="3">    b = tmp;</a></code></pre></div>
<p>Faîtes-en une fonction qui échange deux nombres, et qui aura comme paramètres les adresses de ces nombres :</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> echanger(<span class="dt">int</span> *adr_a, <span class="dt">int</span> *adr_b)</a>
<a class="sourceLine" id="cb19-2" title="2">{</a>
<a class="sourceLine" id="cb19-3" title="3">   <span class="dt">int</span> tmp =                               <span class="co">// complétez</span></a>
<a class="sourceLine" id="cb19-4" title="4">                                </a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7">}</a></code></pre></div>
<p>Idée : dans la séquence montrée plus haut, remplacez simplement <code>a</code> par <code>*adr_a</code>, et pareil pour <code>b</code>.</p>
<p>Pour tester la fonction, faites un <code>main</code> qui déclare et affecte deux variables, les échange, et affiche leurs valeurs.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb20-2" title="2">{</a>
<a class="sourceLine" id="cb20-3" title="3">   <span class="dt">int</span> premier = <span class="dv">111</span>;</a>
<a class="sourceLine" id="cb20-4" title="4">   <span class="dt">int</span> second  = <span class="dv">222</span>;</a>
<a class="sourceLine" id="cb20-5" title="5"></a>
<a class="sourceLine" id="cb20-6" title="6">   echanger (        ,         );</a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8">   print(<span class="st">&quot;premier=%d, second=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, premier, second);</a>
<a class="sourceLine" id="cb20-9" title="9">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-10" title="10">}</a></code></pre></div>
<h3 id="ordonner-deux-variables"><span class="header-section-number">1.8.2</span> Ordonner deux variables</h3>
<p>Le bout de programme suivant doit</p>
<ul>
<li>lire deux entiers,</li>
<li>les <strong>ordonner</strong> pour les faire afficher dans l’ordre</li>
</ul>
<p>Par exemple si on rentre 11 et 22, ou 22 et 11, ça écrira “<code>min=11, max=22</code>”.</p>
<p>A compléter</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">void</span> ordonner(     ,      )</a>
<a class="sourceLine" id="cb21-2" title="2">{</a>
<a class="sourceLine" id="cb21-3" title="3">   <span class="cf">if</span> (            ) {</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"></a>
<a class="sourceLine" id="cb21-7" title="7">   }</a>
<a class="sourceLine" id="cb21-8" title="8">}</a>
<a class="sourceLine" id="cb21-9" title="9">   </a>
<a class="sourceLine" id="cb21-10" title="10"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb21-11" title="11">   <span class="dt">int</span> a, b;</a>
<a class="sourceLine" id="cb21-12" title="12">   printf(<span class="st">&quot;donnez deux entiers : &quot;</span>);</a>
<a class="sourceLine" id="cb21-13" title="13">   scanf(<span class="st">&quot;%d%d&quot;</span>,       ,          );</a>
<a class="sourceLine" id="cb21-14" title="14">   ordonner(    ,    );</a>
<a class="sourceLine" id="cb21-15" title="15">   printf(<span class="st">&quot;min=%d, max=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, a, b);</a>
<a class="sourceLine" id="cb21-16" title="16">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb21-17" title="17">}</a></code></pre></div>
<p><strong>Suite</strong> : dans la fonction <code>ordonner</code>, utilisez - si ce n’est pas fait - la fonction <code>echanger</code>.</p>
<h2 id="complément-pointeurs-vers-des-structures-la-notation-flèche"><span class="header-section-number">1.9</span> Complément : pointeurs vers des structures, la notation “flèche”</h2>
<p>Lorsqu’on utilise des pointeurs vers des structures, par exemple</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">struct</span> Fraction {</a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="dt">int</span> numerateur, denominateur;</a>
<a class="sourceLine" id="cb22-3" title="3">};</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="dt">void</span> normaliser(<span class="kw">struct</span> Fraction *adr_fraction);</a></code></pre></div>
<p>on a souvent besoin d’accéder à un champ de la structure dont l’adresse est dans un pointeur.</p>
<p>Par exemple, pour normaliser une fraction, il faut d’abord ramener le dénominateur à une valeur positive. On peut écrire</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> normaliser(<span class="kw">struct</span> Fraction *pf)    <span class="co">// pointeur de fraction</span></a>
<a class="sourceLine" id="cb23-2" title="2">{</a>
<a class="sourceLine" id="cb23-3" title="3">   <span class="co">// rectification éventuelle des signes</span></a>
<a class="sourceLine" id="cb23-4" title="4">   <span class="cf">if</span> (pf-&gt;denominateur &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb23-5" title="5">       pf-&gt;denominateur = - pf-&gt;denominateur;</a>
<a class="sourceLine" id="cb23-6" title="6">       pf-&gt;numerateur   = - pf-&gt;numerateur;</a>
<a class="sourceLine" id="cb23-7" title="7">   }</a>
<a class="sourceLine" id="cb23-8" title="8">   <span class="co">// diviser aussi les deux champs par leur pgcd</span></a>
<a class="sourceLine" id="cb23-9" title="9">   <span class="co">// ...</span></a>
<a class="sourceLine" id="cb23-10" title="10">}</a></code></pre></div>
<p>La notation <code>adresse-&gt;champ</code> est simplement une abréviation commode de <code>(*adresse).champ</code>.</p>
<h1 id="pointeurs-de-fonctions"><span class="header-section-number">2</span> Pointeurs de fonctions</h1>
<p>Vous en avez peut-être entendu parler comme quelque chose d’extraordinaire, relevant quasiment de la magie noire. En fait ça n’a rien de compliqué :</p>
<ul>
<li>un pointeur d’entier, c’est un truc qui indique où se trouve la valeur d’un entier</li>
<li>un pointeur de fonction, ça indique où se trouve le code d’une fonction !</li>
</ul>
<p>Ça sert à plein de choses :</p>
<ul>
<li>en “programmation système”<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, pour gérer les signaux (indiquer la fonction à lancer quand un signal sera reçu), pour la programmation parallèle (la fonction qu’un <em>thread</em> devra exécuter…),</li>
<li>au niveau de la bibliothèque standard, la fonction “générique” <code>qsort</code> permet de trier un tableau de données de n’importe quel type, à condition de lui fournir une fonction qui permet de comparer,</li>
<li>pour écrire du code générique, utiliser des “<em>callbacks</em>” etc.</li>
</ul>
<h2 id="la-logique"><span class="header-section-number">2.1</span> La logique</h2>
<p>En fait, c’est assez logique, en appliquant les principes déjà vus. Il n’y a pas grand chose de nouveau.</p>
<p>Voyons sur un exemple : une fonction qui applique une même fonction à tous les éléments d’un tableau.</p>
<ol type="1">
<li>Pour afficher les éléments d’un tableau d’entiers, on peut faire comme ceci</li>
</ol>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb24-2" title="2">{</a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="dt">int</span> tableau[] = { <span class="dv">111</span>, <span class="dv">22</span>, <span class="dv">3333</span>};</a>
<a class="sourceLine" id="cb24-4" title="4">    </a>
<a class="sourceLine" id="cb24-5" title="5">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb24-6" title="6">        printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, tableau[i]);  <span class="co">// 1</span></a>
<a class="sourceLine" id="cb24-7" title="7">    }</a>
<a class="sourceLine" id="cb24-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-9" title="9">}</a></code></pre></div>
<ol start="2" type="1">
<li>soyons sérieux, remplaçons l’action 1 par un appel de fonction. Pour cela on définit une fonction, appelée dans le <code>main()</code></li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="dt">void</span> afficher(<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb25-2" title="2">{</a>
<a class="sourceLine" id="cb25-3" title="3">    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, n);</a>
<a class="sourceLine" id="cb25-4" title="4">}</a>
<a class="sourceLine" id="cb25-5" title="5"></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb25-7" title="7">{</a>
<a class="sourceLine" id="cb25-8" title="8">    ...</a>
<a class="sourceLine" id="cb25-9" title="9">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb25-10" title="10">        afficher(tableau[i]);    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb25-11" title="11">    }</a>
<a class="sourceLine" id="cb25-12" title="12">    ...</a>
<a class="sourceLine" id="cb25-13" title="13">}</a></code></pre></div>
<ol start="3" type="1">
<li>Imaginons que nous ayons réussi de mettre l’adresse de la fonction <code>afficher</code> dans un pointeur de fonction. Il serait cohérent avec les épisodes précédents de remplacer <code>afficher</code> par <code>*adr_fonction</code> dans la boucle :</li>
</ol>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1">adr_fonction = &amp; afficher;</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb26-4" title="4">    (*adr_fonction)(tableau[i]);    <span class="co">// 2</span></a>
<a class="sourceLine" id="cb26-5" title="5">}</a></code></pre></div>
<ol start="4" type="1">
<li>Maintenant, rappelez-vous que la déclaration d’une variable ressemble à son utilisation. Puisque <code>(*adr_fonction)</code> a pour but de remplacer <code>afficher</code> qui a comme prototype</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">void</span> afficher(<span class="dt">int</span> n);</a></code></pre></div>
<p>la variable peut être déclarée</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="dt">void</span> (*adr_fonction)(<span class="dt">int</span> n);</a></code></pre></div>
<ol start="5" type="1">
<li>En pratique, dans un prototype de fonction, on indique les types des paramètres mais pas forcément leur nom. Et voila le code qui en résulte :</li>
</ol>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="dt">void</span> (*adr_fonction)(<span class="dt">int</span>);    <span class="co">// adr_fonction : pointeur de fonction</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3">adr_fonction = &amp; afficher;    <span class="co">// adresse du code d' afficher</span></a>
<a class="sourceLine" id="cb29-4" title="4"></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb29-6" title="6">    (*adr_fonction)(tableau[i]);        <span class="co">// appel</span></a>
<a class="sourceLine" id="cb29-7" title="7">}   </a></code></pre></div>
<p><strong>Note</strong> on peut aussi écrire</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1">    adr_fonction =  afficher;       <span class="co">// sans le &amp;     </span></a>
<a class="sourceLine" id="cb30-2" title="2">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) {</a>
<a class="sourceLine" id="cb30-3" title="3">        adr_fonction(tableau[i]);   <span class="co">// sans l'étoile </span></a>
<a class="sourceLine" id="cb30-4" title="4">    }</a></code></pre></div>
<p>Dans le premier cas, c’est une histoire de compatibilité entre plusieurs compilateurs avant l’établissement d’un standard pour C. Du coup, <code>afficher</code> ou <code>&amp; afficher</code>, ce sont des expressions qui retournent une adresse de fonction, qu’on peut affecter dans un pointeur.</p>
<p>Dans le second cas, c’est que la forme d’un appel de fonction est plus générale que ce à quoi vous êtes habitué.</p>
<ul>
<li><p>Avant de lire ce cours, vous connaissiez <em>nom_de_fonction(paramètre, paramètre, …)</em></p></li>
<li>et puis maintenant, <code>*</code><em>pointeur_de_fonction(paramètre, paramètre, …)</em>,</li>
<li><p>et aussi <em>pointeur_de_fonction(paramètre, paramètre, …)</em>.</p></li>
</ul>
<p>En fait la forme générale, c’est <em>expression_qui_retourne_une_fonction(paramètre, paramètre, ….)</em></p>
<p>Jusqu’icin on mettait “<code>&amp;</code>” et les “<code>*</code>” dans les utilisations de pointeurs de fonctions parce que ça permet de bien en voir la logique. Maintenant que vous avez compris comment ça marche, on va laisser tomber ces opérateurs superflus.</p>
<h2 id="déclarer-un-type-pour-les-fonctions-typedef"><span class="header-section-number">2.2</span> Déclarer un type pour les fonctions (<code>typedef</code>)</h2>
<p>Pour jouer avec les fonctions, on a tout intérêt à déclarer un type. Exemple</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">typedef</span> <span class="dt">bool</span> (*PredicatEntier) (<span class="dt">int</span>);</a></code></pre></div>
<p>pour les fonctions qui prennent un paramètre de type entier et répondent vrai ou faux.</p>
<p>Il y a deux raisons :</p>
<ol type="1">
<li>d’abord la syntaxe pour décrire une fonction est un peu longue, avec le type de retour et ceux des paramètres, c’est fastidieux à relire autant qu’à écrire</li>
<li>ensuite c’est parfois impossible à formuler directement, le compilateur ne voulant pas d’une déclaration bizarre au milieu d’une autre.</li>
</ol>
<p>En reprenant l’exemple précédent, on peut écrire une fonction qui applique la même action à tous les éléments d’un tableau d’entiers. La ligne</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">typedef</span>  <span class="dt">void</span> (* ActionEntier)(<span class="dt">int</span>);</a></code></pre></div>
<p>définit le type <code>ActionEntier</code> : les fonctions qui prennent comme paramètre un <code>int</code> et ne retournent rien. Et on utilise ce type pour un des paramètres de <code>appliquer_action</code> :</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">void</span> appliquer_action(<span class="dt">int</span> tableau[], <span class="dt">int</span> taille, ActionEntier action)</a>
<a class="sourceLine" id="cb33-2" title="2"><span class="co">//                                               ------------</span></a>
<a class="sourceLine" id="cb33-3" title="3">{</a>
<a class="sourceLine" id="cb33-4" title="4">   <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; taille; i++) {</a>
<a class="sourceLine" id="cb33-5" title="5">       action(tableau[i]);</a>
<a class="sourceLine" id="cb33-6" title="6"><span class="co">//     ------</span></a>
<a class="sourceLine" id="cb33-7" title="7">   }</a>
<a class="sourceLine" id="cb33-8" title="8">}</a></code></pre></div>
<p>Le <code>main</code> devient</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb34-2" title="2">{</a>
<a class="sourceLine" id="cb34-3" title="3">    <span class="dt">int</span> tableau[] = { <span class="dv">111</span>, <span class="dv">22</span>, <span class="dv">3333</span>};</a>
<a class="sourceLine" id="cb34-4" title="4">    appliquer_action(tableau, <span class="dv">3</span>, afficher);</a>
<a class="sourceLine" id="cb34-5" title="5">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb34-6" title="6">}</a></code></pre></div>
<h2 id="fonctions-qui-retournent-des-fonctions"><span class="header-section-number">2.3</span> Fonctions qui retournent des fonctions</h2>
<p>On peut même jouer avec des fonctions qui retournent des fonctions.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb35-2" title="2"></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="dt">void</span> manger() { printf(<span class="st">&quot;miam miam</span><span class="sc">\n</span><span class="st">&quot;</span>); }</a>
<a class="sourceLine" id="cb35-4" title="4"><span class="dt">void</span> dormir() { printf(<span class="st">&quot;rrrr zzz</span><span class="sc">\n</span><span class="st">&quot;</span>); }</a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="co">// définition d'un type Action = &quot;fonction void sans paramètre&quot;</span></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="kw">typedef</span> <span class="dt">void</span> (*Action)();   </a>
<a class="sourceLine" id="cb35-8" title="8"></a>
<a class="sourceLine" id="cb35-9" title="9">Action que_faire(<span class="dt">int</span> heure)</a>
<a class="sourceLine" id="cb35-10" title="10">{</a>
<a class="sourceLine" id="cb35-11" title="11">    <span class="cf">if</span> (heure == <span class="dv">12</span> || heure == <span class="dv">20</span>) {</a>
<a class="sourceLine" id="cb35-12" title="12">        <span class="cf">return</span> manger;</a>
<a class="sourceLine" id="cb35-13" title="13">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb35-14" title="14">        <span class="cf">return</span> dormir;</a>
<a class="sourceLine" id="cb35-15" title="15">    }</a>
<a class="sourceLine" id="cb35-16" title="16">}</a>
<a class="sourceLine" id="cb35-17" title="17">    </a>
<a class="sourceLine" id="cb35-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb35-19" title="19">{</a>
<a class="sourceLine" id="cb35-20" title="20">    printf(<span class="st">&quot;quelle heure est-il (0..24) ?&quot;</span>);</a>
<a class="sourceLine" id="cb35-21" title="21">    <span class="dt">int</span> heure = <span class="dv">12</span>;</a>
<a class="sourceLine" id="cb35-22" title="22">    scanf(<span class="st">&quot;%d&quot;</span>, &amp; heure);</a>
<a class="sourceLine" id="cb35-23" title="23">    que_faire(heure) ();  <span class="co">// lance la fonction retournée par que_faire(heure)</span></a>
<a class="sourceLine" id="cb35-24" title="24">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-25" title="25">}</a></code></pre></div>
<p>mais bon, il faut en avoir l’usage.</p>
<p><strong>Ce qu’on en retiendra</strong>, c’est que l’appel de fonction a une forme générale</p>
<blockquote>
<p><em>expr_1</em> <code>(</code><em>arg_1</em><code>,</code> <em>arg_2</em><code>,</code> …<code>)</code></p>
</blockquote>
<p>dans laquelle l’<strong>expr_1</strong> peut être n’importe quelle expression qui retourne un pointeur de fonction. Dans le cas le plus courant, c’est le nom d’une fonction, mais ça peut être autre chose.</p>
<h2 id="une-application-table-dactions"><span class="header-section-number">2.4</span> Une application : table d’actions</h2>
<p>Ici on utilise une table d’actions, contenant des adresses de fonctions.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="dt">void</span> aller_au_restaurant() </a>
<a class="sourceLine" id="cb36-2" title="2">{</a>
<a class="sourceLine" id="cb36-3" title="3">    printf(<span class="st">&quot;Miam</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb36-4" title="4">}</a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="dt">void</span> retourner_dormir()  </a>
<a class="sourceLine" id="cb36-7" title="7">{</a>
<a class="sourceLine" id="cb36-8" title="8">    printf(<span class="st">&quot;Zzzz</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb36-9" title="9">}</a>
<a class="sourceLine" id="cb36-10" title="10"></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="dt">void</span> aller_au_boulot()   </a>
<a class="sourceLine" id="cb36-12" title="12">{</a>
<a class="sourceLine" id="cb36-13" title="13">    printf(<span class="st">&quot;Bof</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb36-14" title="14">}</a>
<a class="sourceLine" id="cb36-15" title="15"></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="dt">void</span> (*actions[<span class="dv">3</span>])()                <span class="co">// tableau de 3 fonctions</span></a>
<a class="sourceLine" id="cb36-17" title="17">      = { aller_au_restaurant, </a>
<a class="sourceLine" id="cb36-18" title="18">          aller_au_boulot, </a>
<a class="sourceLine" id="cb36-19" title="19">          retourner_dormir };</a>
<a class="sourceLine" id="cb36-20" title="20"></a>
<a class="sourceLine" id="cb36-21" title="21"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb36-22" title="22">{</a>
<a class="sourceLine" id="cb36-23" title="23">    <span class="cf">for</span> (;;) {</a>
<a class="sourceLine" id="cb36-24" title="24">       printf(<span class="st">&quot;Action entre 0 et 2 : &quot;</span>);</a>
<a class="sourceLine" id="cb36-25" title="25">       <span class="dt">int</span> n;</a>
<a class="sourceLine" id="cb36-26" title="26">       scanf(<span class="st">&quot;%d&quot;</span>, &amp;n);              <span class="co">// choix de l'action</span></a>
<a class="sourceLine" id="cb36-27" title="27">       </a>
<a class="sourceLine" id="cb36-28" title="28">       actions[n] ();                <span class="co">// exécution de la fonction correspondante        </span></a>
<a class="sourceLine" id="cb36-29" title="29">    }</a>
<a class="sourceLine" id="cb36-30" title="30">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb36-31" title="31">}</a></code></pre></div>
<h1 id="les-pointeurs-et-les-tableaux"><span class="header-section-number">3</span> Les pointeurs et les tableaux</h1>
<h2 id="quest-ce-quun-tableau"><span class="header-section-number">3.1</span> Qu’est-ce qu’un tableau ?</h2>
<p>En C, vous avez peut être remarqué que les tableaux n’étaient pas des variables comme les autres. Par exemple vous pouvez déclarer deux tableaux de même type et de même taille :</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="dt">int</span> a[<span class="dv">10</span>], b[<span class="dv">10</span>]; </a></code></pre></div>
<p>mais vous ne pouvez pas copier l’un dans l’autre par <code>a = b</code>;</p>
<pre><code>test.c:12:4: error: assignment to expression with array type</code></pre>
<p>La raison, c’est que <code>a</code>, ce n’est pas vraiment une variable <em>contenant</em> 10 entiers. C’est un emplacement où il y a 10 entiers.</p>
<p>Quand vous écrivez <code>a = b;</code>, vous demandez de mettre une adresse dans une autre. Ce n’est pas vraiment ce que vous voulez faire.</p>
<h2 id="compatibilité-entre-tableaux-et-pointeurs"><span class="header-section-number">3.2</span> Compatibilité entre tableaux et pointeurs</h2>
<p>Bref, il vous faut voir le tableau comme <strong>l’adresse</strong> du premier entier, d’une zone qui en contient 10. Et logiquement vous avez le droit d’écrire :</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="dt">int</span> tableau[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb39-2" title="2"><span class="dt">int</span> *pointeur;</a>
<a class="sourceLine" id="cb39-3" title="3"></a>
<a class="sourceLine" id="cb39-4" title="4">pointeur = tableau;</a></code></pre></div>
<p>ce qui met dans <code>pointeur</code> l’adresse de <code>tableau[0]</code>.</p>
<p>Inversement, vous pouvez aussi utiliser avec les pointeurs la <em>notation indicée</em> que vous connaissez sur les tableaux.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb40-1" title="1">printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, pointeur[<span class="dv">3</span>]);</a></code></pre></div>
<p>Bref, un tableau en C, c’est <em>comme</em> un pointeur (non modifiable) vers un espace qui a été réservé pendant la déclaration.</p>
<p><strong>Exercice</strong>: que fait afficher la séquence suivante ?</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1">pointeur = &amp; tableau[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb41-2" title="2">printf(<span class="st">&quot;%d&quot;</span>, pointeur[<span class="dv">3</span>]);</a></code></pre></div>
<p><strong>Complément</strong> : Cette interchangeabilité explique pourquoi vous pouvez utiliser indifféremment les deux versions (pointeurs / tableaux) pour déclarer les fonctions qui ont des tableaux en paramètres</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1"><span class="dt">void</span> afficher_tableau(<span class="dt">int</span>  tableau[], <span class="dt">int</span> nombre);</a>
<a class="sourceLine" id="cb42-2" title="2"><span class="dt">void</span> afficher_tableau(<span class="dt">int</span> *tableau  ,  <span class="dt">int</span> nombre);</a></code></pre></div>
<h2 id="la-notation-pointeurentier"><span class="header-section-number">3.3</span> La notation <em>pointeur+entier</em></h2>
<p>Si on a un tableau <code>t</code> d’entiers (par exemple), la notation <code>t+k</code> désigne la position du k-ième entier après celui qui est désigné par <code>t</code></p>
<p>Illustration : le dessin ci-dessous représente la mémoire occupée par un <strong>tableau de trois entiers</strong> déclaré par</p>
<blockquote>
<p><code>int t[3];</code></p>
</blockquote>
<p>en supposant que chaque <code>int</code> est représenté sur 4 octets (les petites cases), ce qui est le cas des machines à architecture 32 bits.</p>
<figure>
<img src="data:image/png;base64,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" alt="Tableau de 3 entiers" /><figcaption>Tableau de 3 entiers</figcaption>
</figure>
<p>En haut, on voit les positions désignées par <code>t, t+1</code>, … (à partir de <code>t+3</code>, elles sont en dehors du tableau !), et en bas, les contenus correspondant à <code>t[0]</code>, <code>t[1]</code>, …</p>
<p>Bref, la notation <code>tableau+entier</code> ou <code>pointeur+entier</code> a un sens en C, c’est la base de ce qu’on appelle <strong>l’arithmétique des pointeurs</strong>.</p>
<h2 id="larithmétique-des-pointeurs"><span class="header-section-number">3.4</span> L’arithmétique des pointeurs</h2>
<p>Exemple, les deux expressions</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb43-1" title="1">pointeur++;</a>
<a class="sourceLine" id="cb43-2" title="2">pointeur = pointeur + <span class="dv">1</span>;</a></code></pre></div>
<p>signifient toutes deux “mettre dans <code>pointeur</code> l’adresse qui est un <code>int</code> plus loin que ce que désignait <code>pointeur</code> juste avant”.</p>
<p>Autrement dit, si <code>pointeur</code> désignait une case d’un tableau, maintenant il désigne la case suivante.</p>
<p>Il faut comprendre un peu ce qui se passe en dessous : si un pointeur <code>p</code> contient l’adresse d’un objet de type <code>T</code>, et que <code>k</code> est un entier, <code>p+k</code> contient l’adresse de <code>p</code>, augmentée de <code>k</code> fois <code>sizeof(T)</code></p>
<p>Une démonstration ? Voici un code qui fait afficher la valeur d’un pointeur (de <code>double</code>), à qui on ajoute des entiers</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb44-2" title="2">{</a>
<a class="sourceLine" id="cb44-3" title="3">    <span class="dt">double</span> un_double = <span class="fl">1234.56</span>;</a>
<a class="sourceLine" id="cb44-4" title="4">    </a>
<a class="sourceLine" id="cb44-5" title="5">    printf(<span class="st">&quot;adresse de un_double = %p</span><span class="sc">\n\n</span><span class="st">&quot;</span>, &amp; un_double);</a>
<a class="sourceLine" id="cb44-6" title="6">    </a>
<a class="sourceLine" id="cb44-7" title="7">    <span class="dt">double</span> * p = &amp; un_double;</a>
<a class="sourceLine" id="cb44-8" title="8">    </a>
<a class="sourceLine" id="cb44-9" title="9">    <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; <span class="dv">4</span>; k++) {</a>
<a class="sourceLine" id="cb44-10" title="10">        printf(<span class="st">&quot;       valeur de p+%d = %p</span><span class="sc">\n</span><span class="st">&quot;</span>, k, p+k);</a>
<a class="sourceLine" id="cb44-11" title="11">    }</a>
<a class="sourceLine" id="cb44-12" title="12">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb44-13" title="13">}</a></code></pre></div>
<p>Ce qu’on voit à l’exécution :</p>
<pre><code>adresse de un_double = 0x7ffce909aae8

       valeur de p+0 = 0x7ffce909aae8
       valeur de p+1 = 0x7ffce909aaf0
       valeur de p+2 = 0x7ffce909aaf8
       valeur de p+3 = 0x7ffce909ab00</code></pre>
<p><strong>Commentaire</strong> : même si les adresses sont affichées en hexadécimal, il n’est pas trop difficile de voir qu’elles progressent de 8 en 8. La raison, c’est que ce sont des adresses de <code>double</code>s, qui occupent chacun 8 octets sur cette machine.</p>
<p><strong>Exercice</strong> : que pensez-vous de ce qui suit ?</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb46-1" title="1">printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>,  *(pointeur + <span class="dv">4</span>));</a></code></pre></div>
<p><strong>Exercice</strong> : c’est quoi le problème avec ce code (qui plante) ?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="dt">int</span> nombre    = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb47-2" title="2"><span class="dt">int</span> *pointeur = nombre;</a>
<a class="sourceLine" id="cb47-3" title="3">*pointeur     = <span class="dv">1234</span>;</a>
<a class="sourceLine" id="cb47-4" title="4">printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, *pointeur);</a></code></pre></div>
<p>(Conseil: activer les avertissements du compilateur).</p>
<h2 id="retour-sur-les-expressions-indicées"><span class="header-section-number">3.5</span> Retour sur les expressions indicées</h2>
<p>Avant de lire ce document, vous connaissiez évidemment la notation indicée sur les tableaux !</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb48-1" title="1"><span class="dt">int</span> tableau[<span class="dv">12</span>];</a>
<a class="sourceLine" id="cb48-2" title="2">tableau[<span class="dv">4</span>] = <span class="dv">23</span>;</a></code></pre></div>
<p>et vous venez d’apprendre que ça marchait aussi avec les pointeurs</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="dt">int</span> *pointeur = &amp;(tableau[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb49-2" title="2">pointeur[<span class="dv">5</span>] = <span class="dv">9</span>;</a></code></pre></div>
<p>ce qui vous conduit à vous demander si il y a d’autres formes possibles. En fait oui et non, il y en a une seule pour les expressions indicées, qui est plus générale</p>
<blockquote>
<p><em>expression_1</em> <code>[</code> <em>expression_2</em> <code>]</code></p>
</blockquote>
<p>et qui permet de faire beaucoup de choses. Elle marche quand</p>
<ul>
<li>l’expression_1 fournit une adresse</li>
<li>l’expression_2 fournit un entier.</li>
</ul>
<p><strong>Un exemple amusant</strong> (?) est celui de la conversion d’un nombre (de 0 à 15) en chiffre en hexadécimal</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1"><span class="dt">int</span> nombre = <span class="dv">11</span>;</a>
<a class="sourceLine" id="cb50-2" title="2"><span class="dt">char</span> chiffre = <span class="st">&quot;0123456789ABCDEF&quot;</span>[nombre]; </a></code></pre></div>
<p>qui mettra un ‘B’ dans <code>chiffre</code> (je vous laisse y réfléchir).</p>
<p><strong>Un autre exemple</strong></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1"><span class="dt">char</span> * messages_fr[] = { <span class="st">&quot;bonjour&quot;</span>, <span class="st">&quot;au revoir&quot;</span> };</a>
<a class="sourceLine" id="cb51-2" title="2"><span class="dt">char</span> * messages_en[] = { <span class="st">&quot;hello&quot;</span>,   <span class="st">&quot;good bye&quot;</span>};</a>
<a class="sourceLine" id="cb51-3" title="3"></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="dt">char</span> ** messages(<span class="dt">int</span> code_langue) {</a>
<a class="sourceLine" id="cb51-5" title="5">    <span class="cf">if</span> (code_langue == <span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb51-6" title="6">       <span class="cf">return</span> messages_fr;</a>
<a class="sourceLine" id="cb51-7" title="7">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb51-8" title="8">       <span class="cf">return</span> messages_en;</a>
<a class="sourceLine" id="cb51-9" title="9">    }</a>
<a class="sourceLine" id="cb51-10" title="10">}</a>
<a class="sourceLine" id="cb51-11" title="11"></a>
<a class="sourceLine" id="cb51-12" title="12"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb51-13" title="13">   printf(<span class="st">&quot;%s&quot;</span>,  messages(<span class="dv">1</span>)[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb51-14" title="14">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb51-15" title="15">}</a></code></pre></div>
<p>ici l’<em>expression_1</em> est un appel de fonction, qui retourne un pointeur (en fait un tableau de chaînes).</p>
<h2 id="les-chaînes-de-caractères"><span class="header-section-number">3.6</span> Les chaînes de caractères</h2>
<p>En C, il n’existe pas de type spécifique pour les chaînes de caractères. En fait une chaîne, c’est une suite d’octets en mémoire, terminée par un caractère nul (<code>'\0'</code>).</p>
<p>Et pour désigner une chaîne de caractères, on donne simplement l’adresse de son premier octet.</p>
<p>Le compilateur offre simplement quelques raccourcis. Une chaîne notée entre guillemets représente un tableau de caractères.</p>
<p>Les deux notations sont équivalentes</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb52-1" title="1"><span class="dt">char</span> chaine[] = <span class="st">&quot;hello&quot;</span>;</a>
<a class="sourceLine" id="cb52-2" title="2"><span class="dt">char</span> chaine[] = { <span class="ch">'h'</span>, <span class="ch">'e'</span>, <span class="ch">'l'</span>, <span class="ch">'l'</span>, <span class="ch">'o'</span>, '\<span class="dv">0</span>' };</a></code></pre></div>
<p>elles réservent 6 octets pour le contenu de la chaîne et le caractère nul qui sert de terminateur.</p>
<p>Mais pas tout-à-fait équivalentes à</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1"><span class="dt">char</span> *pointeur = <span class="st">&quot;world&quot;</span>;</a></code></pre></div>
<p>qui réserve de la place</p>
<ul>
<li>dans un espace mémoire pour <code>&quot;world&quot;</code></li>
<li>pour un pointeur contenant initialement l’adresse de cette chaîne</li>
</ul>
<p>Notez qu’on pourra faire <code>chaine[0] = 'H';</code> mais pas <code>pointeur[0] = 'W'</code> : la place pour <code>&quot;world&quot;</code> a été réservée dans un espace protégé en écriture. C’est une constante.</p>
<p>Bref, une chaîne de caractère est décrite par l’adresse de son premier caractère, son contenu va de cette adresse jusqu’au premier caractère nul qui suit.</p>
<p>Traditionnellement, l’écriture de fonctions sur les chaînes de caractères est souvent faite par le biais de pointeurs plutôt que d’indices.</p>
<p>Pour reprendre un exemple éculé, le calcul de la taille d’une chaîne peut s’écrire ainsi (avec des indices) :</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb54-1" title="1"><span class="dt">int</span> longueur(<span class="dt">char</span> chaine[])</a>
<a class="sourceLine" id="cb54-2" title="2">{</a>
<a class="sourceLine" id="cb54-3" title="3">    <span class="dt">int</span> i = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb54-4" title="4">    <span class="cf">while</span> (chaine[i] != '\<span class="dv">0</span>') {</a>
<a class="sourceLine" id="cb54-5" title="5">        i++;</a>
<a class="sourceLine" id="cb54-6" title="6">    }</a>
<a class="sourceLine" id="cb54-7" title="7">    <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb54-8" title="8">}</a></code></pre></div>
<p>ou, avec un pointeur</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="dt">int</span> longueur(<span class="dt">char</span> chaine[])</a>
<a class="sourceLine" id="cb55-2" title="2">{</a>
<a class="sourceLine" id="cb55-3" title="3">    <span class="dt">char</span> *p = chaine;</a>
<a class="sourceLine" id="cb55-4" title="4">    <span class="cf">while</span> (*p != '\<span class="dv">0</span>') {</a>
<a class="sourceLine" id="cb55-5" title="5">        p++;</a>
<a class="sourceLine" id="cb55-6" title="6">    }</a>
<a class="sourceLine" id="cb55-7" title="7">    <span class="cf">return</span> p - chaine;</a>
<a class="sourceLine" id="cb55-8" title="8">}</a></code></pre></div>
<p>mais plutôt sous la forme idiomatique (boucle <code>for</code>) du parcours d’une chaîne</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb56-1" title="1"><span class="dt">int</span> longueur(<span class="dt">char</span> chaine[])</a>
<a class="sourceLine" id="cb56-2" title="2">{</a>
<a class="sourceLine" id="cb56-3" title="3">    <span class="cf">for</span> (<span class="dt">char</span> *p = chaine; *p != '\<span class="dv">0</span>; p++) {</a>
<a class="sourceLine" id="cb56-4" title="4">    };</a>
<a class="sourceLine" id="cb56-5" title="5">    <span class="cf">return</span> p - chaine;</a>
<a class="sourceLine" id="cb56-6" title="6">}</a></code></pre></div>
<p>Dans tous les cas, l’opération “<code>p++</code>” fait glisser le pointeur vers le caractère suivant. L’expression <code>p - chaine</code> indique la “distance” (nombre d’octets) entre le début de la chaîne et le caractère nul qui la termine .</p>
<h1 id="un-exemple-avec-tout-ça"><span class="header-section-number">4</span> Un exemple avec tout ça</h1>
<h2 id="objectif-gestion-de-stocks"><span class="header-section-number">4.1</span> Objectif : gestion de stocks</h2>
<p>Ci-dessous vous trouverez un début de programme dont le prétexte est la gestion d’un stock d’articles.</p>
<p>Chaque article est enregistré dans une structure qui regroupe une référence (un numéro), une description, et un nombre d’articles.</p>
<p>Le stock est enregistré dans un tableau d’articles, plus précisément dans une structure qui contient à la fois un tableau, et le nombre d’articles (les articles enregistrés seront en début de tableau).</p>
<h2 id="les-fonctions-qui-agissent-sur-un-stock"><span class="header-section-number">4.2</span> Les fonctions qui agissent sur un Stock</h2>
<p>Pour agir sur le stock, on a écrit un certain nombre de fonctions qui ont donc un &quot;<code>struct Stock *&quot;</code> en paramètre. On passe un <strong>pointeur</strong> pour plusieurs raisons :</p>
<ul>
<li><strong>parce qu’on ne peut pas faire autrement</strong> pour les opérations qui ont pour but de modifier le stock. Avec un passage par valeur, la fonction modifierait une copie et pas le stock qu’on lui indique.</li>
<li><strong>efficacité</strong> parce si on passe une <code>struct Stock</code> par valeur, on en ferait une copie. Faites afficher <code>sizeof(struct Sock)</code> pour voir combien d’octets seraient copiés à chaque appel. Attention, <code>sizeof</code> retourne un entier non signé (type <code>size_t</code>) pour lequel il faut utiliser la spécification de format <code>&quot;%zu&quot;</code> (merci à Marc Mongenet de me l’avoir rappelé).</li>
<li><strong>par homogénéité</strong> pour que tous les appels se ressemblent, et que le programmeur d’application ne doive pas faire d’effort de mémoire pour retrouver les noms.</li>
</ul>
<p>C’est la même situation que quand vous utilisez des <code>FILE *</code> comme paramètres de diverses fonctions : <code>fprintf</code>, <code>fscanf</code>, <code>fclose</code>, <code>feof</code>, <code>fread</code>, <code>fwrite</code>….</p>
<h2 id="le-source"><span class="header-section-number">4.3</span> Le source</h2>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb57-2" title="2"></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb57-5" title="5"></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="pp">#define TAILLE_MAX_STOCK         100</span></a>
<a class="sourceLine" id="cb57-7" title="7"><span class="pp">#define LONGUEUR_MAX_DESCRIPTION 50</span></a>
<a class="sourceLine" id="cb57-8" title="8"></a>
<a class="sourceLine" id="cb57-9" title="9"><span class="kw">struct</span> Article {</a>
<a class="sourceLine" id="cb57-10" title="10">    <span class="dt">int</span> reference;</a>
<a class="sourceLine" id="cb57-11" title="11">    <span class="dt">char</span> description[LONGUEUR_MAX_DESCRIPTION];</a>
<a class="sourceLine" id="cb57-12" title="12">    <span class="dt">int</span> quantite;           <span class="co">// alternative : unsigned à la place de int</span></a>
<a class="sourceLine" id="cb57-13" title="13">};</a>
<a class="sourceLine" id="cb57-14" title="14"></a>
<a class="sourceLine" id="cb57-15" title="15"><span class="kw">struct</span> Stock {</a>
<a class="sourceLine" id="cb57-16" title="16">    <span class="dt">int</span> nombre_articles;                       <span class="co">// ici aussi</span></a>
<a class="sourceLine" id="cb57-17" title="17">    <span class="kw">struct</span> Article articles[TAILLE_MAX_STOCK];</a>
<a class="sourceLine" id="cb57-18" title="18">};</a>
<a class="sourceLine" id="cb57-19" title="19"></a>
<a class="sourceLine" id="cb57-20" title="20"></a>
<a class="sourceLine" id="cb57-21" title="21"><span class="dt">void</span> initialiser_stock(<span class="kw">struct</span> Stock *adr_stock)</a>
<a class="sourceLine" id="cb57-22" title="22">{</a>
<a class="sourceLine" id="cb57-23" title="23">    adr_stock-&gt;nombre_articles = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb57-24" title="24">}</a>
<a class="sourceLine" id="cb57-25" title="25"></a>
<a class="sourceLine" id="cb57-26" title="26"><span class="dt">bool</span> stock_est_plein(<span class="kw">struct</span> Stock *adr_stock)</a>
<a class="sourceLine" id="cb57-27" title="27">{</a>
<a class="sourceLine" id="cb57-28" title="28">    <span class="cf">return</span> adr_stock-&gt;nombre_articles == TAILLE_MAX_STOCK;</a>
<a class="sourceLine" id="cb57-29" title="29">}</a>
<a class="sourceLine" id="cb57-30" title="30"></a>
<a class="sourceLine" id="cb57-31" title="31"><span class="co">/**</span></a>
<a class="sourceLine" id="cb57-32" title="32"><span class="co"> * cherche dans un stock un article à partir de sa référence.</span></a>
<a class="sourceLine" id="cb57-33" title="33"><span class="co"> * retourne un pointeur sur l'article si présent, NULL sinon.</span></a>
<a class="sourceLine" id="cb57-34" title="34"><span class="co"> */</span></a>
<a class="sourceLine" id="cb57-35" title="35"><span class="kw">struct</span> Article *chercher_par_reference(<span class="kw">struct</span> Stock *adr_stock, </a>
<a class="sourceLine" id="cb57-36" title="36">                                       <span class="dt">int</span> reference)</a>
<a class="sourceLine" id="cb57-37" title="37">{</a>
<a class="sourceLine" id="cb57-38" title="38">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; adr_stock-&gt;nombre_articles; i++) {</a>
<a class="sourceLine" id="cb57-39" title="39">        <span class="cf">if</span> (adr_stock-&gt;articles[i].reference == reference) {</a>
<a class="sourceLine" id="cb57-40" title="40">            <span class="cf">return</span> adr_stock-&gt;articles + i;              <span class="co">// trouvé</span></a>
<a class="sourceLine" id="cb57-41" title="41">        }</a>
<a class="sourceLine" id="cb57-42" title="42">    }</a>
<a class="sourceLine" id="cb57-43" title="43">    <span class="cf">return</span> NULL;                                         <span class="co">// pas trouvé </span></a>
<a class="sourceLine" id="cb57-44" title="44">}</a>
<a class="sourceLine" id="cb57-45" title="45"></a>
<a class="sourceLine" id="cb57-46" title="46"><span class="co">/**</span></a>
<a class="sourceLine" id="cb57-47" title="47"><span class="co"> * ajoute un article dans le stock.</span></a>
<a class="sourceLine" id="cb57-48" title="48"><span class="co"> * on transmet l'adresse pour éviter de faire une copie</span></a>
<a class="sourceLine" id="cb57-49" title="49"><span class="co"> * </span></a>
<a class="sourceLine" id="cb57-50" title="50"><span class="co"> * PRECAUTIONS, il est de la responsabilité de l'utilisateur de la </span></a>
<a class="sourceLine" id="cb57-51" title="51"><span class="co"> * fonction de vérifier</span></a>
<a class="sourceLine" id="cb57-52" title="52"><span class="co"> * - que le stock n'est pas plein.</span></a>
<a class="sourceLine" id="cb57-53" title="53"><span class="co"> * - que la référence n'est pas déjà présente.</span></a>
<a class="sourceLine" id="cb57-54" title="54"><span class="co"> * - que la description n'est pas trop longue</span></a>
<a class="sourceLine" id="cb57-55" title="55"><span class="co"> */</span></a>
<a class="sourceLine" id="cb57-56" title="56"> </a>
<a class="sourceLine" id="cb57-57" title="57"><span class="dt">void</span> ajouter_article(<span class="kw">struct</span> Stock *adr_stock,</a>
<a class="sourceLine" id="cb57-58" title="58">                     <span class="kw">struct</span> Article *adr_article)</a>
<a class="sourceLine" id="cb57-59" title="59">{</a>
<a class="sourceLine" id="cb57-60" title="60">    adr_stock-&gt;articles[adr_stock-&gt;nombre_articles++] = *adr_article;</a>
<a class="sourceLine" id="cb57-61" title="61">}</a>
<a class="sourceLine" id="cb57-62" title="62"></a>
<a class="sourceLine" id="cb57-63" title="63"><span class="co">/**</span></a>
<a class="sourceLine" id="cb57-64" title="64"><span class="co">* définition du type &quot;fonction qui agit sur un article&quot;</span></a>
<a class="sourceLine" id="cb57-65" title="65"><span class="co">* la fonction reçoit l'adresse de l'article à traiter</span></a>
<a class="sourceLine" id="cb57-66" title="66"><span class="co">*/</span></a>
<a class="sourceLine" id="cb57-67" title="67"></a>
<a class="sourceLine" id="cb57-68" title="68"><span class="kw">typedef</span> <span class="dt">void</span> (*ActionSurArticle)(<span class="kw">struct</span> Article *);</a>
<a class="sourceLine" id="cb57-69" title="69"></a>
<a class="sourceLine" id="cb57-70" title="70"><span class="co">/**</span></a>
<a class="sourceLine" id="cb57-71" title="71"><span class="co">* pour_tout_article</span></a>
<a class="sourceLine" id="cb57-72" title="72"><span class="co">* applique une même action à tous les articles d'un stock</span></a>
<a class="sourceLine" id="cb57-73" title="73"><span class="co">*/</span></a>
<a class="sourceLine" id="cb57-74" title="74"></a>
<a class="sourceLine" id="cb57-75" title="75"><span class="dt">void</span> pour_tout_article(<span class="kw">struct</span> Stock *stock, ActionSurArticle action)</a>
<a class="sourceLine" id="cb57-76" title="76">{</a>
<a class="sourceLine" id="cb57-77" title="77">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; stock-&gt;nombre_articles; i++) {</a>
<a class="sourceLine" id="cb57-78" title="78">        printf(<span class="st">&quot;%3d &quot;</span>, i);</a>
<a class="sourceLine" id="cb57-79" title="79">        action(stock-&gt;articles + i);               <span class="co">// c'est une adresse</span></a>
<a class="sourceLine" id="cb57-80" title="80">    }</a>
<a class="sourceLine" id="cb57-81" title="81">}</a>
<a class="sourceLine" id="cb57-82" title="82"></a>
<a class="sourceLine" id="cb57-83" title="83"><span class="co">/**</span></a>
<a class="sourceLine" id="cb57-84" title="84"><span class="co">* affichage d'un article (passé par pointeur)</span></a>
<a class="sourceLine" id="cb57-85" title="85"><span class="co">*/</span></a>
<a class="sourceLine" id="cb57-86" title="86"></a>
<a class="sourceLine" id="cb57-87" title="87"><span class="dt">void</span> action_afficher_article(<span class="kw">struct</span> Article *adr_article)</a>
<a class="sourceLine" id="cb57-88" title="88">{</a>
<a class="sourceLine" id="cb57-89" title="89">    printf(<span class="st">&quot;%06d %6d %s</span><span class="sc">\n</span><span class="st">&quot;</span>, adr_article-&gt;reference,</a>
<a class="sourceLine" id="cb57-90" title="90">                            adr_article-&gt;quantite,</a>
<a class="sourceLine" id="cb57-91" title="91">                            adr_article-&gt;description);   </a>
<a class="sourceLine" id="cb57-92" title="92">}</a>
<a class="sourceLine" id="cb57-93" title="93"></a>
<a class="sourceLine" id="cb57-94" title="94"><span class="co">// --- les tests ------------------------------------------</span></a>
<a class="sourceLine" id="cb57-95" title="95"></a>
<a class="sourceLine" id="cb57-96" title="96"><span class="dt">void</span> test_recherche(<span class="kw">struct</span> Stock *adr_stock, <span class="dt">int</span> reference)</a>
<a class="sourceLine" id="cb57-97" title="97">{</a>
<a class="sourceLine" id="cb57-98" title="98">    printf(<span class="st">&quot;- Recherche de la réference %d</span><span class="sc">\n</span><span class="st">&quot;</span>, reference);</a>
<a class="sourceLine" id="cb57-99" title="99">    </a>
<a class="sourceLine" id="cb57-100" title="100">    <span class="kw">struct</span> Article *adr_article</a>
<a class="sourceLine" id="cb57-101" title="101">                    = chercher_par_reference(adr_stock, reference);</a>
<a class="sourceLine" id="cb57-102" title="102">    <span class="cf">if</span> (adr_article == NULL) {</a>
<a class="sourceLine" id="cb57-103" title="103">        printf(<span class="st">&quot;absente</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb57-104" title="104">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb57-105" title="105">        action_afficher_article(adr_article);</a>
<a class="sourceLine" id="cb57-106" title="106">    }</a>
<a class="sourceLine" id="cb57-107" title="107">}</a>
<a class="sourceLine" id="cb57-108" title="108"></a>
<a class="sourceLine" id="cb57-109" title="109"><span class="dt">void</span> test_1 ()</a>
<a class="sourceLine" id="cb57-110" title="110">{</a>
<a class="sourceLine" id="cb57-111" title="111">    <span class="kw">struct</span> Stock stock;</a>
<a class="sourceLine" id="cb57-112" title="112">    <span class="kw">struct</span> Article article_patates = { </a>
<a class="sourceLine" id="cb57-113" title="113">        .reference = <span class="dv">123</span>,</a>
<a class="sourceLine" id="cb57-114" title="114">        .quantite = <span class="dv">20</span>,     </a>
<a class="sourceLine" id="cb57-115" title="115">        .description = <span class="st">&quot;Sac 3kg de patates&quot;</span></a>
<a class="sourceLine" id="cb57-116" title="116">    };</a>
<a class="sourceLine" id="cb57-117" title="117">    <span class="co">// initialisation de structure style C99, voir</span></a>
<a class="sourceLine" id="cb57-118" title="118">    <span class="co">// http://en.cppreference.com/w/c/language/struct_initialization</span></a>
<a class="sourceLine" id="cb57-119" title="119">    </a>
<a class="sourceLine" id="cb57-120" title="120">    <span class="kw">struct</span> Article article_chaussettes = {</a>
<a class="sourceLine" id="cb57-121" title="121">        .reference = <span class="dv">234</span>,</a>
<a class="sourceLine" id="cb57-122" title="122">        .description = <span class="st">&quot;Paire de chaussettes vertes&quot;</span>,</a>
<a class="sourceLine" id="cb57-123" title="123">        .quantite = <span class="dv">12</span></a>
<a class="sourceLine" id="cb57-124" title="124">    };</a>
<a class="sourceLine" id="cb57-125" title="125">    </a>
<a class="sourceLine" id="cb57-126" title="126">    <span class="kw">struct</span> Article article_logiciel = {</a>
<a class="sourceLine" id="cb57-127" title="127">        .reference = <span class="dv">89</span>,</a>
<a class="sourceLine" id="cb57-128" title="128">        .description = <span class="st">&quot;Compilateur C ANSI en solde&quot;</span>,</a>
<a class="sourceLine" id="cb57-129" title="129">        .quantite  = <span class="dv">5</span></a>
<a class="sourceLine" id="cb57-130" title="130">    };</a>
<a class="sourceLine" id="cb57-131" title="131">    </a>
<a class="sourceLine" id="cb57-132" title="132">    printf(<span class="st">&quot;* Initialisation et ajouts</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb57-133" title="133"></a>
<a class="sourceLine" id="cb57-134" title="134">    initialiser_stock(&amp; stock);</a>
<a class="sourceLine" id="cb57-135" title="135">    ajouter_article(&amp; stock, &amp;article_patates);</a>
<a class="sourceLine" id="cb57-136" title="136">    ajouter_article(&amp; stock, &amp;article_chaussettes);</a>
<a class="sourceLine" id="cb57-137" title="137">    ajouter_article(&amp; stock, &amp;article_logiciel);</a>
<a class="sourceLine" id="cb57-138" title="138">    </a>
<a class="sourceLine" id="cb57-139" title="139">    printf(<span class="st">&quot;* Parcours</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb57-140" title="140">    </a>
<a class="sourceLine" id="cb57-141" title="141">    pour_tout_article(&amp; stock, action_afficher_article);</a>
<a class="sourceLine" id="cb57-142" title="142"></a>
<a class="sourceLine" id="cb57-143" title="143">    printf(<span class="st">&quot;* Tests de recherche</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb57-144" title="144">    </a>
<a class="sourceLine" id="cb57-145" title="145">    test_recherche(&amp; stock, <span class="dv">234</span>);</a>
<a class="sourceLine" id="cb57-146" title="146">    test_recherche(&amp; stock, <span class="dv">999</span>);</a>
<a class="sourceLine" id="cb57-147" title="147">    }</a>
<a class="sourceLine" id="cb57-148" title="148"></a>
<a class="sourceLine" id="cb57-149" title="149"><span class="co">// ---------------------------------------------</span></a>
<a class="sourceLine" id="cb57-150" title="150"></a>
<a class="sourceLine" id="cb57-151" title="151"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb57-152" title="152">{</a>
<a class="sourceLine" id="cb57-153" title="153">    test_1();</a>
<a class="sourceLine" id="cb57-154" title="154">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb57-155" title="155">}</a></code></pre></div>
<h2 id="travail-proposé"><span class="header-section-number">4.4</span> Travail proposé</h2>
<ul>
<li>Essayer de comprendre.</li>
<li>Compléter avec des fonctions qui permettent de consulter la quantité disponible pour une référence donnée, la modifier, etc.</li>
<li>Écrire un programme qui dialoguera avec l’utilisateur pour gérer un stock.</li>
<li>Faire une bibliothèque, compilée séparément.</li>
</ul>
<h2 id="indications-pour-la-compilation-séparée"><span class="header-section-number">4.5</span> Indications pour la compilation séparée</h2>
<p>Si on part sur l’idée d’une compilation séparée, le fichier source contiendra un “<code>include</code>” de la bibliothèque, et les fonctions qui sont particulières au test :</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb58-2" title="2"><span class="pp">#include </span><span class="im">&quot;stock.h&quot;</span></a>
<a class="sourceLine" id="cb58-3" title="3"></a>
<a class="sourceLine" id="cb58-4" title="4"><span class="dt">void</span> test_recherche(<span class="kw">struct</span> Stock *adr_stock, <span class="dt">int</span> reference)</a>
<a class="sourceLine" id="cb58-5" title="5">{</a>
<a class="sourceLine" id="cb58-6" title="6">    printf(<span class="st">&quot;- Recherche de la référence %d</span><span class="sc">\n</span><span class="st">&quot;</span>, reference);</a>
<a class="sourceLine" id="cb58-7" title="7">    ...</a>
<a class="sourceLine" id="cb58-8" title="8">}</a>
<a class="sourceLine" id="cb58-9" title="9"></a>
<a class="sourceLine" id="cb58-10" title="10"><span class="dt">void</span> test_1()</a>
<a class="sourceLine" id="cb58-11" title="11">{</a>
<a class="sourceLine" id="cb58-12" title="12">    ....</a>
<a class="sourceLine" id="cb58-13" title="13">}</a>
<a class="sourceLine" id="cb58-14" title="14"></a>
<a class="sourceLine" id="cb58-15" title="15"><span class="dt">void</span> main()</a>
<a class="sourceLine" id="cb58-16" title="16">{</a>
<a class="sourceLine" id="cb58-17" title="17">    test_1();</a>
<a class="sourceLine" id="cb58-18" title="18">    ...</a>
<a class="sourceLine" id="cb58-19" title="19">}</a></code></pre></div>
<p>Le fichier “<code>stock.h</code>” contient les constantes, les déclarations de type et les prototypes des fonctions</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1"><span class="pp">#ifndef STOCK_H</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="pp">#define STOCK_H</span></a>
<a class="sourceLine" id="cb59-3" title="3"></a>
<a class="sourceLine" id="cb59-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb59-5" title="5"></a>
<a class="sourceLine" id="cb59-6" title="6"><span class="pp">#define TAILLE_MAX_STOCK         100</span></a>
<a class="sourceLine" id="cb59-7" title="7">...</a>
<a class="sourceLine" id="cb59-8" title="8"></a>
<a class="sourceLine" id="cb59-9" title="9"><span class="kw">struct</span> Article {</a>
<a class="sourceLine" id="cb59-10" title="10">    ...</a>
<a class="sourceLine" id="cb59-11" title="11">};</a>
<a class="sourceLine" id="cb59-12" title="12"></a>
<a class="sourceLine" id="cb59-13" title="13"><span class="kw">struct</span> Stock {</a>
<a class="sourceLine" id="cb59-14" title="14">    ...</a>
<a class="sourceLine" id="cb59-15" title="15">};</a>
<a class="sourceLine" id="cb59-16" title="16"></a>
<a class="sourceLine" id="cb59-17" title="17"><span class="dt">void</span> initialiser_stock(<span class="kw">struct</span> Stock *adr_stock);</a>
<a class="sourceLine" id="cb59-18" title="18"><span class="dt">bool</span> stock_est_plein(<span class="kw">struct</span> Stock *adr_stock);</a>
<a class="sourceLine" id="cb59-19" title="19">...</a>
<a class="sourceLine" id="cb59-20" title="20"></a>
<a class="sourceLine" id="cb59-21" title="21"><span class="pp">#endif</span></a></code></pre></div>
<p>Quant au fichier &quot;<code>stock.c</code>, il fait une inclusion du fichier d’en-tête, et contient le code des fonctions</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb60-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb60-3" title="3"><span class="pp">#include </span><span class="im">&quot;stock.h&quot;</span></a>
<a class="sourceLine" id="cb60-4" title="4"></a>
<a class="sourceLine" id="cb60-5" title="5"><span class="dt">void</span> initialiser_stock(<span class="kw">struct</span> Stock *adr_stock)</a>
<a class="sourceLine" id="cb60-6" title="6">{</a>
<a class="sourceLine" id="cb60-7" title="7">    adr_stock-&gt;nombre_articles = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb60-8" title="8">}</a>
<a class="sourceLine" id="cb60-9" title="9"></a>
<a class="sourceLine" id="cb60-10" title="10"><span class="dt">bool</span> stock_est_plein(<span class="kw">struct</span> Stock *adr_stock)</a>
<a class="sourceLine" id="cb60-11" title="11">{</a>
<a class="sourceLine" id="cb60-12" title="12">    <span class="cf">return</span> adr_stock-&gt;nombre_articles == TAILLE_MAX_STOCK;</a>
<a class="sourceLine" id="cb60-13" title="13">}</a></code></pre></div>
<h1 id="pointeurs-et-typage"><span class="header-section-number">5</span> Pointeurs et typage</h1>
<h2 id="les-pointeurs-sont-typés"><span class="header-section-number">5.1</span> Les pointeurs sont typés</h2>
<p>Jusqu’ici nous avons utilisé des pointeurs “sur des entiers”, des pointeurs “sur des structures”, etc.</p>
<p>Ces <strong>pointeurs sont typés</strong>, c’est-à-dire que le compilateur connaît le type des objets pointés. Il y a deux raisons pour cela</p>
<ol type="1">
<li>D’une part le compilateur vérifie qu’on ne se mélange pas les pinceaux en écrivant</li>
</ol>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="dt">int</span>   *p1, *p2;</a>
<a class="sourceLine" id="cb61-2" title="2"><span class="dt">float</span> *p3;</a>
<a class="sourceLine" id="cb61-3" title="3"></a>
<a class="sourceLine" id="cb61-4" title="4">p1 = p2;    <span class="co">// oui</span></a>
<a class="sourceLine" id="cb61-5" title="5">p2 = p3;    <span class="co">// erreur, types incompatibles</span></a></code></pre></div>
<ol start="2" type="1">
<li>D’autre part le compilateur a besoin de connaitre la longueur du type pointé pour pouvoir traduire les expressions avec indices et l’arithmétique des pointeurs.</li>
</ol>
<p>En effet, que fait <code>p = p + 1</code>, si p est un pointeur d’entiers (<code>int</code>) ?</p>
<p>Supposons que <code>p</code> contienne l’adresse <code>0x7ffce90901234</code>. C’est l’adresse (sur 64 bits, les zéros non significatifs ne sont pas indiqués) d’un <code>int</code> qui occupe 32 bits, soit 4 octets. (Les chiffres sont donnés pour mon PC à architecture 64 bits, ils peuvent varier selon les machines, les systèmes et les compilateurs).</p>
<p><code>p+1</code> pointe “un <code>int</code> plus loin” en mémoire, donc correspond à la valeur <code>0x7ffce90901234 + 4 = 0x7ffce90901238</code>. L’opération <code>p++</code> consiste donc à ajouter 4 (le nombre d’octets d’un <code>int</code>) à l’adresse contenue dans <code>p</code>.</p>
<p><strong>En résumé</strong> avec la déclaration</p>
<blockquote>
<p><em>T</em> <code>*ptr;</code></p>
</blockquote>
<p>l’instruction <code>ptr++</code> ajoute en réalité <code>sizeof(T)</code> à l’adresse contenue dans <code>ptr</code>.</p>
<h2 id="pointeurs-génériques"><span class="header-section-number">5.2</span> Pointeurs génériques</h2>
<p>Quand on programme “à bas niveau” (ce qui est le créneau spécifique du langage C), on a parfois besoin d’écrire des fonctions qui agissent sur des paramètres de différents types.</p>
<p>Par exemple, je voudrais voir comment sont codées les données, et pour cela faire afficher leur contenu en hexadécimal.</p>
<h3 id="exemple-dutilisation"><span class="header-section-number">5.2.1</span> Exemple d’utilisation</h3>
<p>Pour cela, je vais définir une fonction <code>afficher_en_hexa</code> que j’appellerai ainsi</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1">   <span class="dt">int</span>   un_entier   = <span class="dv">1789</span>;</a>
<a class="sourceLine" id="cb62-2" title="2">   <span class="dt">float</span> un_flottant = <span class="fl">3.14</span>;</a>
<a class="sourceLine" id="cb62-3" title="3">   afficher_en_hexa(&amp; un_entier,   <span class="kw">sizeof</span>(un_entier));</a>
<a class="sourceLine" id="cb62-4" title="4">   afficher_en_hexa(&amp; un_flottant, <span class="kw">sizeof</span>(un_flottant));</a></code></pre></div>
<p>Le premier paramètre sera l’adresse du premier octet de la donner à afficher, le second sa longueur.</p>
<p>Remarquez que dans le premier cas l’argument donné est un <code>int*</code>, dans le second un <code>float*</code>. Il va y avoir un souci de compatibilité de types.</p>
<h3 id="comment-afficher-en-hexadécimal-le-contenu-dune-zone-mémoire"><span class="header-section-number">5.2.2</span> Comment afficher en hexadécimal le contenu d’une zone mémoire ?</h3>
<p>Ce n’est pas difficile si la zone est considérée comme un tableau d’octets (en C, octet = <code>char</code>)</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="dt">char</span> *tableau = ....</a>
<a class="sourceLine" id="cb63-2" title="2"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; longueur; i++) {</a>
<a class="sourceLine" id="cb63-3" title="3">   printf(<span class="st">&quot;%x02&quot;</span>, tableau[i]);</a>
<a class="sourceLine" id="cb63-4" title="4">}</a></code></pre></div>
<p>La spécification de format <code>%x02</code> s’analyse comme suit</p>
<ul>
<li><code>x</code> : afficher en hexadécimal</li>
<li><code>0</code> : en mettant éventuellement des 0 non significatifs</li>
<li><code>2</code> : sur une largeur de 2 caractères</li>
</ul>
<h3 id="pointeurs-génériques-le-type-void"><span class="header-section-number">5.2.3</span> Pointeurs génériques : le type <code>void*</code></h3>
<p>Pour déclarer la fonction, nous allons utiliser le type spécial <code>void*</code>, qui signifie “pointeur sur un type inconnu”.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb64-1" title="1"><span class="dt">void</span> afficher_en_hexa(<span class="dt">void</span> *adresse, <span class="dt">int</span> longueur);</a></code></pre></div>
<p>Ce type est compatible, pour l’affectation, avec les autres pointeurs. C’est ce qu’on appelle un <strong>pointeur générique</strong>.</p>
<ol type="1">
<li><p>d’une part ça permet l’appel de la fonction avec n’importe quel type d’adresse : <code>afficher_en_hexa(&amp; un_truc, ....)</code></p></li>
<li><p>d’autre part ça autorise l’affectation <code>tableau = adresse</code> dans le corps de la fonction.</p></li>
</ol>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="dt">void</span> afficher_en_hexa(<span class="dt">void</span> *adresse, <span class="dt">int</span> longueur)</a>
<a class="sourceLine" id="cb65-2" title="2">{</a>
<a class="sourceLine" id="cb65-3" title="3">    <span class="dt">char</span> *tableau = adresse;</a>
<a class="sourceLine" id="cb65-4" title="4">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; longueur; i++) {</a>
<a class="sourceLine" id="cb65-5" title="5">        printf(<span class="st">&quot;%x02&quot;</span>, tableau[i]);</a>
<a class="sourceLine" id="cb65-6" title="6">    }</a>
<a class="sourceLine" id="cb65-7" title="7">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb65-8" title="8">}</a></code></pre></div>
<ol start="3" type="1">
<li>Par contre un pointeur générique ne peut évidemment pas être dé-référencé, et on ne peut pas faire d’arithmétique des pointeurs avec, puis qu’on ne connaît ni le type, ni la longueur de ce qu’il pointe.</li>
</ol>
<h2 id="conversions-explicites-de-pointeurs-transtypage-typecast"><span class="header-section-number">5.3</span> Conversions explicites de pointeurs (transtypage, <em>typecast</em>)</h2>
<p>Une autre façon de faire “à l’ancienne” aurait été de définir la fonction avec un paramètre “pointeur d’octet” :</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="dt">void</span> afficher_hexa(<span class="dt">char</span> *adresse, <span class="dt">int</span> longueur)</a>
<a class="sourceLine" id="cb66-2" title="2">{</a>
<a class="sourceLine" id="cb66-3" title="3">  ...</a>
<a class="sourceLine" id="cb66-4" title="4">}</a></code></pre></div>
<p>ce qui interdit l’appel</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb67-1" title="1">afficher_hexa(&amp; un_entier,        <span class="co">// Erreur: types incompatibles</span></a>
<a class="sourceLine" id="cb67-2" title="2">              <span class="kw">sizeof</span>(un_entier));  </a></code></pre></div>
<p>parce que les types <code>int*</code> et <code>char*</code> sont incompatibles.</p>
<p>Dans ce cas, la solution est de forcer la conversion de type (“<em>typecast</em>”)</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb68-1" title="1">afficher_hexa((<span class="dt">char</span> *) &amp;un_entier,</a>
<a class="sourceLine" id="cb68-2" title="2">              <span class="kw">sizeof</span>(un_entier));  </a></code></pre></div>
<p>en précédant l’adresse par “<code>(char *)</code>” qui signifie “considéré comme pointeur de <code>char</code>”.</p>
<p>Vous verrez ça dans de nombreux exemples que vous trouverez sur Internet. Il faut savoir que nombreuses bibliothèques (allocation dynamique, réseau, …) ont été écrites à une époque où le type <code>void*</code> n’avait pas encore été introduit en C (C89). La pratique normale était alors d’utiliser des <code>char*</code>, ce qui imposait d’avoir à faire un “transtypage” explicite.</p>
<p>Nous sommes au XXIe siècle, Les bibliothèques ont été modifiées depuis, mais les exemples préhistoriques sont restés.</p>
<p><strong>Résumé</strong> : si <strong>expr</strong> est une expression de type “pointeur sur type <em>T</em>”, alors</p>
<blockquote>
<p><code>(</code><em>T</em>) <em>expr</em></p>
</blockquote>
<p>est de type “pointeur sur <em>T</em>”.</p>
<h1 id="lallocation-dynamique"><span class="header-section-number">6</span> L’allocation dynamique</h1>
<h2 id="préliminaires-durée-de-vie-des-variables"><span class="header-section-number">6.1</span> Préliminaires, durée de vie des variables</h2>
<p>Considérons un programme simple, avec une variable globale</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb69-2" title="2"></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="dt">int</span> nombre_appels_carre = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb69-4" title="4"></a>
<a class="sourceLine" id="cb69-5" title="5"><span class="dt">double</span> carre(<span class="dt">double</span> nombre)</a>
<a class="sourceLine" id="cb69-6" title="6">{</a>
<a class="sourceLine" id="cb69-7" title="7">    nombre_appels_carre++;</a>
<a class="sourceLine" id="cb69-8" title="8">    <span class="dt">double</span> tmp = nombre * nombre;</a>
<a class="sourceLine" id="cb69-9" title="9">    <span class="cf">return</span> tmp;</a>
<a class="sourceLine" id="cb69-10" title="10">}</a>
<a class="sourceLine" id="cb69-11" title="11"></a>
<a class="sourceLine" id="cb69-12" title="12"><span class="dt">void</span> test(<span class="dt">double</span> x)</a>
<a class="sourceLine" id="cb69-13" title="13">{</a>
<a class="sourceLine" id="cb69-14" title="14">    <span class="dt">float</span> c = carre(x);</a>
<a class="sourceLine" id="cb69-15" title="15">    printf(<span class="st">&quot;le carré de %f est %f</span><span class="sc">\n</span><span class="st">&quot;</span>, x, c);</a>
<a class="sourceLine" id="cb69-16" title="16">}</a>
<a class="sourceLine" id="cb69-17" title="17">    </a>
<a class="sourceLine" id="cb69-18" title="18"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb69-19" title="19">{</a>
<a class="sourceLine" id="cb69-20" title="20">    test(<span class="fl">12.0</span>);</a>
<a class="sourceLine" id="cb69-21" title="21">    test(<span class="fl">3.14</span>);</a>
<a class="sourceLine" id="cb69-22" title="22">    printf(<span class="st">&quot;fonction carre appelée %d fois</span><span class="sc">\n</span><span class="st">&quot;</span>, nombre_appels_carre);</a>
<a class="sourceLine" id="cb69-23" title="23">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb69-24" title="24">}</a></code></pre></div>
<p>On y voit plusieurs catégories de variables</p>
<ul>
<li>la variable <code>nombre_appels_carre</code> qui est <strong>globale</strong>,</li>
<li>les paramètres <code>nombre</code> et <code>xxx</code>, qui sont des noms pour les valeurs reçues lors d’un appel</li>
<li>les variables <strong>locales</strong> <code>tmp</code> et <code>c</code></li>
</ul>
<p>et vous savez qu’elles n’ont pas la même visibilité :</p>
<ul>
<li>la variable globale est accessible depuis toutes les fonctions</li>
<li>alors que les variables locales (et les paramètres) n’existent que dans leur fonction (le même nom peut être utilisé dans plusieurs fonctions) ;</li>
</ul>
<p>et surtout, pas la même durée de vie :</p>
<ul>
<li>la variable globale existe pendant toute la durée d’exécution du programme : sa place a été réservée au début de l’exécution. C’est ce qu’on appelle une variable <strong>statique</strong>.</li>
<li>une variable locale, n’existe que pendant l’exécution de la fonction : de l’espace est réservé <em>automatiquement</em> (sur la pile des appels) pour loger la variable quand la fonction est appelé, et rendu <em>automatiquement</em> au retour de la fonction (exécution de <code>return</code>, ou de la dernière instruction). C’est ce qu’on appelle une variable <strong>automatique</strong>.</li>
</ul>
<p>Le dessin ci-dessous (<strong>pile des appels</strong>) représente l’évolution (le temps va de gauche à droite) du contenu de la mémoire au cours de appels et des retours. En haut figure la pile d’exécution, avec dans chaque <strong>contexte</strong> les variables et leur valeur. En bas, la variable globale.</p>
<figure>
<img src="data:image/png;base64,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Xl1dHULo27fvE088MXjw4BDCihUrRo0atXbt2hBCIpGorKwsKSlJrb/77rvvuHkikVi5cmVq25UrV5522mmpbVObv/322/vvv38IYdCgQY8//viBBx4YQti0adNRRx319ttv77TPiUR2Xt7bs9929ll9MyAf65tFpaXFL71U+9Wvbv+ujz226N57t/XtmwwhbN4cTjml6KWXalOrpQNhCOGYY4ruv3/bgAHJEMKbbybGjClctKiR1dJfNthLtvj7G23qG20lJcXGCQFaJHXGH0LYbbfdPv3009TjysrKAw44IPW4X79+GzZsSK+fCgyp9ZvaPL1t3759628bQujdu3fqwTvvvDNw4MBEIpFIJHr27Pnee++169tIJLb/q2/OnHDCCaFLl1BaGn70o/C3vzWyYTIZrroq7L136NYtXH11iNz7idGob+Jz9RvnzJlzwgkndOnSpbS09Ec/+tHfGqtvMpm86qqr9t57727dul199dXeL+4ovXp98ZOsqEiMGFGUmiY6dGhxZWXjn1aycWNi//23b1VWlqyq2vmHmtTfC0AbyIRARGTl0+BKS0vLy8tTj9euXdurV69WbZ7etry8vMG26dP63r17r1+/Pvm5bdu2tavHyWQjce6228LkyWHz5vDKK6GoKFxwQSMb3nVXmD8/LF8eli0Lc+eG3/2uXd3IE3lX39STNGi87bbbJk+evHnz5ldeeaWoqOiCxup71113zZ8/f/ny5cuWLZs7d+7v4lHfDKj/utSrV3Lx4trUNNHKypqKipod1wkh9OyZfOed7U3r1ydKSrYX9CtfCZ+/2xD++tcm9wLQBjIhEBHJ5BdjYBk7Qzr33HMvvfTSioqKioqKSy+99Nxzz23V5pMmTdqwYcOGDRsmTZo0evToRteZOHHiuHHjVq1atXXr1tdff/2cc87piI5/2dy54eSTQ9euYd99w8yZ4bnnGlnn/vvDtGmhrCyUlYVp08J993V8N3JPNOo7d+7ck08+uWvXrvvuu+/MmTOfa6y+999/f+pWN2VlZdOmTbsvHvXNsAsuqJs8uXDNmkRNTVi1KjFhwvYLBbt1C2vWfPGaNWpU8rrrCquqElVVialTC0eN2p4JDzkk+atfFVRXh3ffTVx55c4vMgRoOZkQiI7UGFjqX2by4ZQpUwYNGjR8+PDhw4cPGTLk2muvbdXmJ5xwwrBh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9pvf3DlhwqQVKyrnzVtSVFR06aVjd3yqBx747XPPPT137ktPPbX4mWfm/eEP96YXjRx5Ztxes3KE+kab+kab+kL+anD8/vrXt48b9+PXXnvvuedW9O5ddtFF5ze6VaPHeMq///vPLrhgfIPGGB6/MiFsl0gkwufvJKVa6urq7rhjxlFH9R80qMekSeOqq7ek2v/ylwUnnnhkWdmeRx7Z7z//857w+ZtY9bd99dVlhx9+9E53+l//9eQ3v/nt3Xfv2r37vtdd9/PFi/+y4zoPP/x/rrrqht69+/Tu3eeqq2546KHfpxcdeeTXXnllSbu+7dhQ32hT32hTX8hfnXr8PvLI3JNPPm3PPf+pa9c9xo+/bNmyxa3q25o1by5cOPdf//XSBu0xPH5lQtguNeen/jtJd989a9GiZx95ZN6LL75ZW1szc+YNqfZLLvnhpZdevXr15sce+3Pq1Se1Sf1t//rXTT169GxVB55/fuHgwYfs2P7WW28ceujw1OOhQw9fvfqN9KIePUo2bqxq1V5iS32jTX2jTX0hf2Xm+K2u3nLvvb/8+te/0aq+/exnV11xxb995Su7NmiP4fErE0KTHnzwdzfdNKt37z577bX31Kk3z579x1R7YWHhpk2V77+/uVev/W699TeNbtvauzetWPHKNdf8eNq023dctGXL/+yxx16px3vu+U9btnzSqmemKeobbeobbeoL+avDj9/S0l369dv7rrtm/exnt7a8G88+O/+DD94fNep7bfgWokcmhCZVVLw7YsRBqRkLQ4fuV1lZkWq/995H//KXP3/rW0d8/euDFyyY0+i2PXr03LSppe8wLVr0zAUXnP4f//H7IUOG7rh09927fvLJx6nHf//7R7vvvkd60aZNVa19t5s09Y029Y029YX81eHHb2Xl1tWr37/ggvGTJo1reTduuOHK66+/JTW1tYEYHr8yIXmmtLRdd0NuXoPXhV699lu8eE1qxkJl5daKis9S7QcffNg99/zfFSsqb7jh33/yk39tdNuhQw9/6aVFLdnpf//3IxdddP5vf/vw0UePaHSFAQMGv/LK0tTjV19dduCBg9OLXnpp0aGHHtGybw71jTj1jTb1hfyVgeN3jz32/Nd/vfT1119uea9WrVoxatTx6YsV6996NIbHr0xInqmsrCktLU7/69gn79at+5o1b6a/vOCC8ZMnT1iz5s2amq2rVq2YMGF0qn3ixB+89daq2tqaUO+lqsG23/rWd9NzIZrxm9/cceONP3344acOO6zhS0/6temss35w883Xv/vu2++++/bNN1//ve99cU+t2bP/eOKJ323LtxpL6htt6htt6gv5q/OO3x//+Idr1rxZU1NTWVnx859P/drXjksv2ukHYKRDafqqxfSiGO3EWnkAACAASURBVB6/RdnuALRaZeUXn3xaPxbWb2+biy++YuTIY//+949SrwtjxlxUUFAwduxZ7777dt++/a+8cvs10N/+9qljx55VUfFu//4Df/GL+xvd9pRTTv+3f7uivHzNAQf0/7yru9R/kFrthhuuDCEcd9wXty5Ys+aD3XfvWr9X55037t1315944pGpx+ee+8NU+7p1b7388pK77vpDO7/r+FDfaFPfaFNfyF+dd/x+61vfnTBh9Nq1q//5n/c94YSTZ826p9EONHqMNyWex2+itVdax1xVVXtTB50kHQ7b8xvd5vq258NYaZX2vGSpb+5T32hT32jLSn3JjJKSds3McvzmPuOE5LEGg4SlpcVZfIvD2ysZ0OiF4JmhvhmgvtGmvtGWxfoSbY7fDEgkEjIheabRyaKpawsrK2tC6MQ70AAAQPTIhOSHdBTc8aLBz9MgAADQajIhua6ZNBgEQgAAaB+ZkNyVSoNNRb7mlwIAAC0hE5Jzmh8YTK8jDQIAQPvJhOSWloz+CYQAANBRZEJyRcvnggqEAADQUVqaCROJtn+6fXu2Jfe1f9TOlYEAAJAtzWVCWY7OJg0CAEB2FTSzTCCkUwmEAACQda4nJAukQQAAyBEFIYREInHLLbf06NFjn332ufjii7du3Zpalkgkdtygrq5u2rRpZWVl3bp1GzNmzJYtW3ZcZ+vWrRdddNE+++zTs2fPmTNn7nTbp59+etiwYV26dOnTp89vf/vbjv8u4628PDFuXOHgwcUHHlg8dmzhBx9sby8tLf7lLwsOOaR48ODia68trKnZSXtdXbjjjoKjjioaNKh40qTC6uo29kcgBACA3LF97ui8efOWL1/+2muvrV69+qabbmpmgzvuuGPhwoULFixYt25dTU3N1KlTd1xnxowZb7311muvvbZ06dI//elPO932vPPOu/baaz/66KNnn332xRdf7LjvjhBCGDeu8MIL65Yvr1mypKZnzzBjRmF60TPPFMydW7tgQe3atYlZswqab7/77oJFiwoeeWTbiy/W1NaGmTMLG+6pBVI3pBEIAQAgRySSyWQikVi5cuXgwYNDCCtXrjzttNPWrl0bvnyPmfTjQYMGPf744wceeGAIYdOmTUcdddTbb7/d4En79ev33//936knXLFixcEHH9z8tr17977iiitGjRq13377Zej7bquqqvwOM598Er7xjaJly2pDCKWlxQsX1g4YkAwhrF6d+OEPCxctaq792GOL7r13W9++yRDC5s3hlFOKXnpp+/otzHgZ+FzBkpLi9mze5vqWlu7i+tsMaOeNr9Q3x6lvtKlvtGWrvmSG86toSyQS268nPOCAA1IP+vbtu2HDhma2eeeddwYOHJj+sqCgkbvUbNiwIf2E/fr12+m2jz/++I033njDDTd069btzjvvPPnkk9vy3dCEV19NTJ9e+PrriY8/DiGEwnrDe/vvv/0w69MnWVWVaL69oiIxYsQXF6A2VvkmmS8KAAC5aft5fXl5efpBr169mtmgd+/e69evT35u27ZtO67Tq1ev9BOuW7dup9sOGzbsscce27x58+233z5mzJj2f1fUN3Fi4Vln1b3wQs1779W88UZN/Yq9804i/aCkJNl8e69eycWLa1MzPysrayoqWhrwBEIAAMhZ2zPhpEmTNmzYsGHDhkmTJo0ePbqZDSZOnDhu3LhVq1Zt3br19ddfP+ecc3Zc5/vf/376CS+77LKdbnvuuee+8cYbNTU1oYmBR9qjujqxxx5ht91CRUXiiiu+dBHg9dcXbtyY2Lgxcf31hWeckWy+/YIL6iZPLlyzJlFTE1atSkyY0KLrCQVCAADIZdunAp5wwgnDhg2rqak555xzrrnmmmY2uOSSSwoKCs4444z169cPGDDgxhtv3HGda6+99rLLLjv44IOLi4snT548f/785rc97bTTzjjjjHfeeWfQoEEPPPBAh36DhFtvrf23fyscP75w332TEyfWzZ79xaIRI+pOPLGopiaMGlX34x9va759zJi6goIwdmzhu+8m+vZNXnll3U53LRACAECO236PGZdvtlCUroFu6o4vHXUnmKwEQtdAt1yjHzaTGW3+WblHRcupb8upb6uobwaoL7nG+VXL5enx6zPr6RRGCPNCVl5ns/haGTfqG23qG23qC/krH49fF+/R8QRCAADIFwUhS1mWrGsqs7UzywmEAACQR4wT0pEEQgAAyC8yIR1MIAQAgDwiE9JhOuqGpQAAQMZ0WCZsz71u3OcqAgRCAADIR8YJ6QCpywgBAIC8UxBCqK2tnTp16v7777/33nvfeuutqQX/+Mc/Lrvssp49e/bs2fOyyy77xz/+kWpPJBK//vWv+/Tp06VLl2OOOWbFihXh84G+RCKRHvGrq6ubNm1aWVlZt27dxowZs2XLlhDCxIkT77333vS+77nnnokTJ7Zw2xDC008/PWzYsC5duvTp0+e3v/1t5/9waAWDhAAAkI8KQgg333zzc889t2DBgvLy8oqKitSC6dOnr1y5cunSpUuXLn3ttddmzJiR3uapp55auHDh+++/f/LJJ0+YMCF8/mkWyWQy/bEWd9xxx8KFCxcsWLBu3bqampqpU6eGEO6888777rvv4YcfDiE89NBD999//6xZs1q4bQjhvPPOu/baaz/66KNnn332xRdfzMjPh50zaxQAAPJXIplM9u/f/7HHHjvooIPqL+jbt+8TTzwxePDgEMKKFStGjRq1du3aEEIikaiqqurZs2cIobq6unv37tXV1an2+p9zOGjQoMcff/zAAw8MIWzatOmoo456++23U4+POeaY733vew899NALL7zQo0ePlm/bu3fvK664YtSoUfvtt18n/1iaVFUl/HxJrgXCkpJ2zWJtc31LS3fJu8/5bHDc5cV+29ln9c3x/apvy6lvy6lvZvabrfpmRq6d7WSe86uWy9PjtyCEUFFR0a9fvwbLKisrDzjggNTjfv36bdiwIb0oFQhDCLvtttunn37a6FO/8847AwcOTM0I7dmz53vvvZdq79Gjx3nnnffzn//8oosuSgXClm/7+OOPL1iw4LDDDhswYMCf/vSntn3PAAAApBWEEPbbb7/UGGB9paWl5eXlqcdr167t1atX80/U4N6hvXv3Xr9+ffJz27ZtS7W/+uqr99xzzx//+Mfbb789vdMWbjts2LDHHnts8+bNt99++5gxY9ry7dKhvG3WIRq9zjaL/aFjqW+0qW+0qW/klZYW33VXweGHF/XqVRxCqKsLd9xRcNRRRYMGFU+aVFhdvX2d1P/pO+pt3RqmTi0cOrR46NDiqVMLt2794tkaPHmjeyEzHL+tUhBCuPDCCy+55JLy8vIPP/xw0qRJqQXnnnvupZdeWlFRUVFRcemll5577rnNP1H37t1XrVqV/nLixInjxo1btWrV1q1bX3/99XPOOSeEsGXLlvPOO+/BBx88/fTTf/WrX5199tmpYcaWbJvq0htvvFFTUxNCKChwx9QsEwg7SqPX2Wa7U3QY9Y029Y029Y2DF15IPPnktg0bakIId99dsGhRwSOPbHvxxZra2jBzZmH4/C56lZU16dOeO+8sXL06MWdO7Zw5tatWJWbNKmzVXsgMx2+rFIUQrrjiii1bthx33HFbtmy57rrrUgumTJly5ZVXDh8+PIRw9tlnX3vttc0/0U9/+tOvfe1rH330UWom6yWXXFJQUHDGGWesX79+wIABN954Ywjhf//v/33JJZcce+yxIYSRI0euXbv2oosuuueee1qybQjhtNNOO+OMM955551BgwY98MADnfUjgczaZZddHn744WOOOebll19OXWdbXOx9xOhQ32jLtfqm593Uv6pkzpw5M2fOXLRo0d577/2d73zn5ptv3meffRpsmEwmf/rTn951112JRGL8+PEzZszw0cEh9+pLZ7jxxroePbYfLw8+WHDvvdt6906GEKZO3XbKKUXXX9/IJn/8Y+L++7eVlCRDCDfeuG3MmMLJk1uxFzLD8dsqBSGE4uLi6dOnv/feex988EF6nHDXXXedNWvWxo0bN27cOGvWrF133TXV3uDixfSXP/nJTz788MP0lwUFBZdccsmqVas+++yz11577bTTTgsh3H///ePGjUtvO2nSpHvuuaeF24YQzjnnnDfffPPTTz9dvnz58ccf3zk/EFrEIGHHasl1tpmTSGz/V9+cOeGEE0KXLqG0NPzoR+Fvf2tkw2QyXHVV2Hvv0K1buPrqkG8XhXeenKpv4nP1G+fMmXPCCSd06dKltLT0Rz/60d8aq28ymbzqqqv23nvvbt26XX311Xl30X/nyan61r+Jd9ptt902efLkzZs3v/LKK0VFRRdccMGOG951113z589fvnz5smXL5s6d+7vf/S4j/c0DOVVfx29n6NXri59GRUVixIii1DTRoUOLKysbf2dk48bE/vtv36qsLFlVtfM3UOrvhYzJoeP3ySfDcceFXXcNpaXhwgvDpk2Nr9boOVjK+++H3r0bX9QRzMCE7Gv0OtusSSYbiXO33RYmTw6bN4dXXglFRaGxc8pw111h/vywfHlYtizMnRucU34up+orM3S4nKpvo+bOnXvyySd37dp13333nTlz5nPPPbfjOvfff3/qk4HLysqmTZt23333ZbybOSqn6uv47Qz1z7F79UouXlybmiZaWVlTUVGz4zohhJ49k++8s71p/fpEasAwhPCVr4T0vRf/+tcm9xI9Ofvd5dDx++//Hi67LGzcGFavDgccEL7//cZXa/QcLOX660NnXg9Z1HlPTVQZJOxY6etsjz322KKiorPPPvv555/v0qVLtvv1ZXPnbn/QtWuYOTN89auNrHP//WHatFBWFkII06aF6dPDj36UuR7mqryo79zP69u1a9eZM2d+tbH6pjNDCGHatGnTp0//kfrmSX3rW7BgwdChQ3dsX7ly5RFHHJF6PHz48JUrV2a2XzkqL+rr+O1AF1xQN3ly4bRp2/r0Sa5dm7jzzoJf/3pbCKFbt7BmTaJ//+0n66NGJa+7rvCOO7aFEKZOLRw1anv7IYckf/WrggkT6t5/PzF1aozGXZLJL8XCHBmHzq3jd8GCLx7/5Cfh5ptbt/mqVeGpp8KKFeGaazq2X2kx+n2F3NTgOtvzzjvvoosuynanmrVgQWjsnDKsXBk+P6cMw4cH55QhhDysr8zQKvlV35dffvniiy9u9C4L//M//7PXXnulHv/TP/3TJ598ktmu5aj8qm9w/LbbmDF1J51UN3ZsYf/+xRdfXHj66dvDzcUXbxs5sih9H9HLLtvWv3/y298u+va3iwYMSF566fY75N9887Y//7lgyJDiM88sPP743AhGmZIa30r9S89/zO74YY4ev1u2hF/8IrT2IrjJk8PPfhY+v5SvM2TnQxXzV45/pmoG5Pggoc9UbbmdfLZpItH4G30vvxxOPTU88UQ49NCGiwoLw2efhdQF3DU1oUuXUFvb6v22p887o747Xfryyy+feuqpTzzxxKE71LewsPCzzz5LXaBfU1PTpUuXWvXNnjbUd+HChem3zHfcZK+99lq3bl337t1DCJs3bx4wYMCHH37Y2v22p887pb47XZrXx2+j4SGXzzfipm3nV+mytrmUUTt+Uz+RffcNzz8fdvhw+C+tVv8Z5s0LU6aEF1/cnrObePIO+Mx6gBZZuDCcemp48MFGAmEIoWvX8PHH2x9/9FHYY49Mdo32W7hw4amnnvrggw/ueEIZQujatevHn9f3o48+2kN988pDDz00evToRx99tNFAGEIY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" alt="Pile des appels" /><figcaption>Pile des appels</figcaption>
</figure>
<p>Au delà de ces deux espaces mémoire, la zone statique et la pile, il en existe un autre qu’on appelle “le tas” (<em>heap</em>), qui est géré différemment.</p>
<ul>
<li>dans la zone statique, les données existent pendant toute la durée du programme;</li>
<li>dans la pile, les données apparaissent et disparaissent automatiquement au fil des appels et retours de fonctions,</li>
<li>pour le tas, c’est le programmeur qui demande au système, quand il le souhaite, - de lui prêter une zone d’une certaine taille (<strong>allocation</strong>), - de la récupérer (<strong>libération</strong>).</li>
</ul>
<h2 id="allocation-et-libération-en-c"><span class="header-section-number">6.2</span> Allocation et libération en C</h2>
<p>Les deux fonctions intéressantes sont</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="dt">void</span> *malloc(<span class="dt">size_t</span> size);   <span class="co">// allocation</span></a>
<a class="sourceLine" id="cb70-2" title="2"><span class="dt">void</span> free(<span class="dt">void</span> *pointer);    <span class="co">// libération</span></a></code></pre></div>
<ul>
<li>La première <code>malloc</code> (<em>memory allocation</em>) reçoit en argument la taille voulue (en nombre d’octets), elle retourne un pointeur contenant l’adresse du premier octet obtenu;</li>
<li>la seconde prend comme argument l’adresse d’une zone ainsi allouée, et demande au système de la récupérer.</li>
</ul>
<p>Pour utiliser ces fonctions, il faut</p>
<blockquote>
<p><code>#include &lt;stdlib.h&gt;</code></p>
</blockquote>
<p><strong>Attention</strong></p>
<ul>
<li><code>malloc</code> peut retourner <code>NULL</code>, si la taille<code>size</code> est 0, ou si il n’y a plus de place disponible pour l’allocation</li>
<li><code>free</code> doit recevoir comme paramètre l’adresse d’une zone
<ul>
<li>qui a été allouée précédemment par <code>malloc</code></li>
<li>qui n’a pas déjà été libérée par <code>free</code></li>
</ul></li>
<li>la valeur <code>NULL</code> est aussi acceptée par <code>free</code>.</li>
</ul>
<p>Le programmeur doit donc être particulièrement attentif</p>
<ul>
<li>à vérifier que le <code>malloc</code> qu’il demande a réussi</li>
<li>à libérer les zones allouées quand il n’en a plus besoin (sinon il risque d’y avoir une <em>fuite mémoire</em>)</li>
<li>à ne pas tenter de libérer une seconde fois une zone qui a déjà été libérée (problème de <em>double libération</em>)</li>
</ul>
<h2 id="un-exemple-fabrication-dune-table"><span class="header-section-number">6.3</span> Un exemple : fabrication d’une table</h2>
<p>Un exemple simple : on veut une fonction qui fabrique une table des carrés des nombres entiers de 1 à n (exemple idiot)</p>
<p>D’abord, voici comment on va l’utiliser</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb71-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb71-2" title="2">{</a>
<a class="sourceLine" id="cb71-3" title="3">    <span class="dt">int</span> *table = table_carres(<span class="dv">10</span>);  <span class="co">// création de la table</span></a>
<a class="sourceLine" id="cb71-4" title="4"></a>
<a class="sourceLine" id="cb71-5" title="5">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++) {  <span class="co">// affichage</span></a>
<a class="sourceLine" id="cb71-6" title="6">        printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, table[i]);</a>
<a class="sourceLine" id="cb71-7" title="7">    }</a>
<a class="sourceLine" id="cb71-8" title="8"></a>
<a class="sourceLine" id="cb71-9" title="9">    free(table);                    <span class="co">// libération</span></a>
<a class="sourceLine" id="cb71-10" title="10">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb71-11" title="11">}</a></code></pre></div>
<p>La fonction aura deux étapes : réserver un espace assez grand, et y mettre les carrés. et bien sûr retourner l’adresse de la table :</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1"><span class="dt">int</span> *table_carres(<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb72-2" title="2">{</a>
<a class="sourceLine" id="cb72-3" title="3">    <span class="dt">int</span> *table = malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));   <span class="co">// allocation</span></a>
<a class="sourceLine" id="cb72-4" title="4">    </a>
<a class="sourceLine" id="cb72-5" title="5">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {           <span class="co">// remplissage</span></a>
<a class="sourceLine" id="cb72-6" title="6">        table[i] = (i+<span class="dv">1</span>)*(i+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb72-7" title="7">    }</a>
<a class="sourceLine" id="cb72-8" title="8">    <span class="cf">return</span> table;</a>
<a class="sourceLine" id="cb72-9" title="9">}</a></code></pre></div>
<p>Remarques:</p>
<ul>
<li>puisqu’on veut une table de <code>n</code> entiers, le paramètre de <code>malloc</code> est logiquement</li>
</ul>
<blockquote>
<p><code>n * sizeof(int)</code></p>
</blockquote>
<ul>
<li><p>la situation est asymétrique : l’espace est réservé pendant l’exécution de la fonction <code>table_carres</code>, il lui survit quand la fonction est terminée. La libération se fait ailleurs (dans <code>main</code>).</p></li>
<li><p>Vous avez remarqué qu’on ne teste pas si <code>malloc</code> a échoué. Vous avez raison, on devrait. C’est vrai qu’il n’y a aucun risque avec <strong>ce</strong> programme sur un <em>PC</em> ou un Mac, ou… Par contre, pour un programme qui utiliserait des données beaucoup plus grosses (une séquence vidéo, par exemple, peut occuper quelques giga-octets), ou sur un processeur beaucoup plus petit (micro-contrôleurs en informatique embarquée, avec quelques kilo-octets de mémoire), c’est une autre histoire.</p></li>
</ul>
<h2 id="détection-derreur-stratégies-de-récupération."><span class="header-section-number">6.4</span> Détection d’erreur, stratégies de récupération.</h2>
<p>Donc il va falloir tester le résultat de <code>malloc</code>. Mais pour faire quoi ?</p>
<p><strong>Une première stratégie</strong> possible est de faire mourir le programme de suite, après avoir émis un message d’adieu déchirant sur la sortie d’erreur :</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb73-1" title="1"><span class="dt">int</span> *table_carres(<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb73-2" title="2">{</a>
<a class="sourceLine" id="cb73-3" title="3">    <span class="dt">int</span> *table = malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));   <span class="co">// allocation</span></a>
<a class="sourceLine" id="cb73-4" title="4"></a>
<a class="sourceLine" id="cb73-5" title="5">    <span class="cf">if</span> (table == NULL) {</a>
<a class="sourceLine" id="cb73-6" title="6">        fprintf(stderr, <span class="st">&quot;ERREUR FATALE : table_carres(%d), échec allocation&quot;</span>, n);</a>
<a class="sourceLine" id="cb73-7" title="7">        exit(EXIT_FAILURE);</a>
<a class="sourceLine" id="cb73-8" title="8">    }</a>
<a class="sourceLine" id="cb73-9" title="9">    ...</a>
<a class="sourceLine" id="cb73-10" title="10">}</a></code></pre></div>
<p><strong>Une seconde stratégie</strong> est de “faire remonter” l’erreur, en retournant <code>NULL</code> à l’appelant</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb74-1" title="1"><span class="dt">int</span> *table_carres(<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb74-2" title="2">{</a>
<a class="sourceLine" id="cb74-3" title="3">    <span class="dt">int</span> *table = malloc(n * <span class="kw">sizeof</span>(<span class="dt">int</span>));   <span class="co">// allocation</span></a>
<a class="sourceLine" id="cb74-4" title="4"></a>
<a class="sourceLine" id="cb74-5" title="5">    <span class="cf">if</span> (table == NULL) {</a>
<a class="sourceLine" id="cb74-6" title="6">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb74-7" title="7">    }</a>
<a class="sourceLine" id="cb74-8" title="8">    ...</a>
<a class="sourceLine" id="cb74-9" title="9">}</a></code></pre></div>
<p>qui se voit refiler le mistigri : à lui de vérifier le résultat de <code>table_carre</code>, et d’agir en conséquence</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb75-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb75-2" title="2">{</a>
<a class="sourceLine" id="cb75-3" title="3">    <span class="dt">int</span> *table = table_carres(<span class="dv">10</span>);  <span class="co">// création de la table</span></a>
<a class="sourceLine" id="cb75-4" title="4"></a>
<a class="sourceLine" id="cb75-5" title="5">    <span class="cf">if</span> (table == NULL) {</a>
<a class="sourceLine" id="cb75-6" title="6">        printf(<span class="st">&quot;Il semblerait qu'on manque de mémoire</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb75-7" title="7">        printf(<span class="st">&quot;alors on arrête tout</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb75-8" title="8">        <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb75-9" title="9">    }</a>
<a class="sourceLine" id="cb75-10" title="10"></a>
<a class="sourceLine" id="cb75-11" title="11">    ...</a></code></pre></div>
<p>éventuellement, “agir en conséquence”, ça veut dire fermer proprement des fichiers, libérer d’autres variables, terminer des connexions réseau, etc. Ou se contenter d’une table plus petite. Ça dépend du problème.</p>
<h1 id="une-application-de-lallocation-dynamique-un-tableau-extensible"><span class="header-section-number">7</span> Une application de l’allocation dynamique : un tableau extensible</h1>
<p>Un bon exercice est la constitution d’un type de données pour les tableaux extensibles.</p>
<h2 id="quest-ce-que-cest"><span class="header-section-number">7.1</span> Qu’est-ce que c’est ?</h2>
<p>Un tableau extensible, c’est un “conteneur” qui, comme un tableau, regroupe des cases repérées par un “indice”. Mais à la différence des tableaux ordinaires, il peut être re-dimensionné (agrandi ou rétréci).</p>
<p>Les opérations de base sur un tableau extensible :</p>
<ul>
<li>l’initialiser avec une certaine taille,</li>
<li>consulter la valeur de l’élément d’indice <code>i</code>,</li>
<li>changer la valeur de l’élément d’indice <code>i</code>,</li>
<li>changer la taille du tableau,</li>
<li>consulter sa taille,</li>
<li>et enfin, restituer l’espace qu’il occupe.</li>
</ul>
<p>On va ici définir un type “<code>Array</code>” pour les tableaux de nombres flottants. Ça nous changera des <code>int</code>, mais bien sûr c’est adaptable pour n’importe quel type de données.</p>
<h2 id="définition-du-type-fonctions-de-base"><span class="header-section-number">7.2</span> Définition du type, fonctions de base</h2>
<p><strong>Comment on fait ?</strong> c’est assez simple : un <code>Array</code>, c’est une structure avec</p>
<ul>
<li>un tableau de <code>float</code></li>
<li>un entier qui mémorise le nombre d’éléments du tableau</li>
</ul>
<p>Le tableau sera alloué dynamiquement, parce qu’on ne connait pas <em>a priori</em> sa taille, et qu’elle pourra changer, donc il sera repéré par un pointeur :</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb76-1" title="1"><span class="kw">struct</span> Array {</a>
<a class="sourceLine" id="cb76-2" title="2">     <span class="dt">int</span>    size;</a>
<a class="sourceLine" id="cb76-3" title="3">     <span class="dt">float</span> *data;   <span class="co">// alloué dynamiquement</span></a>
<a class="sourceLine" id="cb76-4" title="4">};</a></code></pre></div>
<p>et on va définir une série de fonctions, dont le nom commencera par <code>array_</code>, et qui prendront comme premier paramètre un pointeur sur une telle structure.</p>
<p><strong>Pour l’initialiser</strong>, on définit une fonction <code>array_init</code></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb77-1" title="1"><span class="dt">void</span> array_init (<span class="kw">struct</span> Array *array_ptr, <span class="dt">int</span> size) </a>
<a class="sourceLine" id="cb77-2" title="2">{</a>
<a class="sourceLine" id="cb77-3" title="3">    array_ptr-&gt;size = size;</a>
<a class="sourceLine" id="cb77-4" title="4">    array_ptr-&gt;data = malloc(size * <span class="kw">sizeof</span>(<span class="dt">float</span>));</a>
<a class="sourceLine" id="cb77-5" title="5">}</a></code></pre></div>
<p>et pour le libérer :</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1">voir array_free(<span class="kw">struct</span> Array *array_ptr)</a>
<a class="sourceLine" id="cb78-2" title="2">{</a>
<a class="sourceLine" id="cb78-3" title="3">    free(array_ptr-&gt;data);</a>
<a class="sourceLine" id="cb78-4" title="4">    array_ptr-&gt;data = NULL;    <span class="co">// précaution contre double array_free</span></a>
<a class="sourceLine" id="cb78-5" title="5">    array_ptr-&gt;size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb78-6" title="6">}</a></code></pre></div>
<p><strong>pour changer une valeur dans le tableau</strong></p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="dt">void</span> array_set(<span class="kw">struct</span> Array *array_ptr, <span class="dt">int</span> index, <span class="dt">float</span> new_value)</a>
<a class="sourceLine" id="cb79-2" title="2">{</a>
<a class="sourceLine" id="cb79-3" title="3">    array_ptr-&gt;data[index] = new_value;</a>
<a class="sourceLine" id="cb79-4" title="4">}</a></code></pre></div>
<p><strong>pour connaitre la taille du tableau</strong>, je vous laisse faire</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="dt">int</span> array_size(                             )</a>
<a class="sourceLine" id="cb80-2" title="2">{</a>
<a class="sourceLine" id="cb80-3" title="3">    <span class="cf">return</span></a>
<a class="sourceLine" id="cb80-4" title="4">}</a></code></pre></div>
<p><strong>pour lire une valeur</strong> dans le tableau, vous y arriverez très bien</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb81-1" title="1"><span class="dt">float</span> array_get(                  ,            )</a>
<a class="sourceLine" id="cb81-2" title="2">{</a>
<a class="sourceLine" id="cb81-3" title="3">    <span class="cf">return</span></a>
<a class="sourceLine" id="cb81-4" title="4">}</a></code></pre></div>
<p>Avec tout ça, vous pouvez constituer un programme de test</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb82-1" title="1"><span class="dt">void</span> test()</a>
<a class="sourceLine" id="cb82-2" title="2">{</a>
<a class="sourceLine" id="cb82-3" title="3">    <span class="kw">struct</span> Array a;</a>
<a class="sourceLine" id="cb82-4" title="4">    printf(<span class="st">&quot;quelle taille ? &quot;</span>);</a>
<a class="sourceLine" id="cb82-5" title="5">    <span class="dt">int</span> taille;</a>
<a class="sourceLine" id="cb82-6" title="6">    scanf(<span class="st">&quot;%d&quot;</span>, &amp;taille);</a>
<a class="sourceLine" id="cb82-7" title="7">    </a>
<a class="sourceLine" id="cb82-8" title="8">    array_init(&amp;a, taille);</a>
<a class="sourceLine" id="cb82-9" title="9"></a>
<a class="sourceLine" id="cb82-10" title="10">    <span class="co">// test nombre éléments</span></a>
<a class="sourceLine" id="cb82-11" title="11">    printf(<span class="st">&quot;le tableau contient %d flottants</span><span class="sc">\n</span><span class="st">&quot;</span>, array_size(&amp;a));</a>
<a class="sourceLine" id="cb82-12" title="12"></a>
<a class="sourceLine" id="cb82-13" title="13">    <span class="co">// écriture (de 100 en 100);</span></a>
<a class="sourceLine" id="cb82-14" title="14">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; array_size(&amp;a); i++) {</a>
<a class="sourceLine" id="cb82-15" title="15">        array_set(&amp;a, i,  <span class="dv">100</span>*i);</a>
<a class="sourceLine" id="cb82-16" title="16">    }</a>
<a class="sourceLine" id="cb82-17" title="17"></a>
<a class="sourceLine" id="cb82-18" title="18">    <span class="co">// consultation</span></a>
<a class="sourceLine" id="cb82-19" title="19">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; array_size(&amp;a); i++) {</a>
<a class="sourceLine" id="cb82-20" title="20">        printf(<span class="st">&quot;%d -&gt; %f</span><span class="sc">\n</span><span class="st">&quot;</span>, i, array_get(&amp;a, i));</a>
<a class="sourceLine" id="cb82-21" title="21">    }</a>
<a class="sourceLine" id="cb82-22" title="22"></a>
<a class="sourceLine" id="cb82-23" title="23">    <span class="co">// libération</span></a>
<a class="sourceLine" id="cb82-24" title="24">    array_free(&amp;a);</a>
<a class="sourceLine" id="cb82-25" title="25">}</a></code></pre></div>
<p>auquel il ne manque plus que le re-dimensionnement. Voir plus loin.</p>
<p>Ci-dessous, une illustration de ce qui se passe en mémoire (pile des appels et tas) au début de l’exécution du <code>main</code>, pendant l’appel de <code>array_init</code>. La zone réservée pour l’allocation dynamique est en bas. On voit que l’objet réservé par <code>malloc</code> survit à la sortie de la fonction <code>array_init</code> qui demandé son allocation.</p>
<figure>
<img src="data:image/png;base64,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8546O+vIhVwHH3KtFACgSBy0+y772I472iLXwQFCHQBQbA7afQdtkevgAKEOACha9tTRPtfDBAAAiJtcBwAAEDe5DgAAIG5yHQAAQNzkOgAAgLjJdQAAAHGT6wAAAOIm1wEAAMRNrgMAAIibXAcAABA3uQ4AACBuch0AAEDc5DoAAIC4yXUAAABxk+sAAADiJtcBAADETa4DAACIW5e0GwCUlyRJ0m4ClDU1CFCS5Dqgs2UymVSWu3nznlSWS4769z8m7SaUCzVIq9QgRM1xmAAAAHGT6wAAAOIm1wEAAMRNrgMAAIibXAcAABA3uQ4AACBuch0AAEDc5DoAAIC4yXWkbMmSb/zJn1yeffzlL1/2939/d7rtgXzoz5AuNQj5W7hw4YQJE7KPv/CFL3zjG99Itz3kKMlkMmm3geK1efOeo552wIBj33mnqf1xdu5sPPfc0x977NmhQ08LIdTVvXnFFRe/9FJd166VR73cstK//zFpN+GIJUlqHzv6c5GLsT/HSA3SFjVY8nIp/8bGxiFDhvz6178+/fTTQwhvvPHGhRde2NDQUFmpjoqd/XV0lMN+AYcQnnhi6TnnnJf9Ag4hnHbasDFjzv7lLx/r4KbBEdOfIV1qEPKXy286jzzyyAUXXJANdSGE4cOHn3POOT/72c86uGkUgFxHmp566t8mTpzccsjEiZN9BxMp/RnSpQYhf4899tiUKVNaDvnSl77085//PK32kDu5jvYMGHDs97//3fPOO+Pkk/9o/PhPvvjicz/60Q8+/emRQ4f2mDjxv9fVvRlCWLfurZqaK0eO7Dd8+El/+qdTtm3b2jxty/n84Af3nXvuadkJ33hjdXb4q6++fPbZ57Vc4rnnXvC7373UWetHedGfIV1qEPKXJMk//dM/nXLKKccdd9yZZ575H//xH9/73vfOOOOMysrK888//4033gghrFmzZvLkyb179+7Zs2dVVdXWrVubp205n+985ztDhgzJTrhq1ars8BUrVpx//vktl/jpT3/6xRdf7Kz14+jJdRzG008/+S//8ova2i1XXFH95S9f9uSTS//3/3589erN/+N/fPHWW2eGEGpqqq+9dsYrr9S/+GJdv34DFy68o9X5LF/+f37606dXr948fvznsxOGEH7/+y19+/ZrOVrfvv3ffXdzR68UZUt/hnSpQcjf448//tRTT23btu2qq676whe+8Oijj/7iF7/YunXrxIkTr7/++hDClClTZs6cuXHjxoaGhoEDB86dO7fV+fzyl79cvnz51q1bL7300uyEIYR33323f//+LUcbMGDAO++809ErRf5cN4X2JEny29829O3bP4Swa9fOU0/t+bvfvf3xj/fLPh01qv+6df/Zcvz/+q8dn/nMmJdfrg8fPZs7Nv8AACAASURBVMd9wIBjW51w6NAer7/+bmVlt+Y57Nq188wzB6xd+15nrWLcYjzHPcVrNujPRS7G/hwjNUhb1GAUkiR55513stFr586d3bt337x5c79+/bJP+/Tps3Pnzpbj79ixY9SoURs2bAgfLf8kSVqdsLKy8v/9v//XrduHdbRz586TTjqpsbGxs1aRo2R/HYeR/QIOIWS/KbPfo9mn77+/K4Tw6qsvf+lLnx8xou+AAccOG9bn979/t9X5HDphCKFv335btnzkl9R3333n4x/v2wHrASHoz5A2NQj5a96flk1f2WyWfbpr164QwooVKy655JJevXolSXLCCSds3tz6XutDJ8zO/KC9c5s2bWoek2Im15GvGTOmTZly9fPP127YsKu2dsu+fftyn3bMmLNffPHXLYe8+OKvP/nJTxW6jZAr/RnSpQYhf9XV1ddcc01dXd3evXu3bdt2RHV0zjnnPPfccy2HPPfcc+eee26h20jhyXXka+fOnccf36Nbt+4bN759883XH9G0n/3sFx9//JGWQx5//JHPfW5CQRsIR0B/hnSpQchfY2Njjx49unfv3tDQUFNTc0TTTpgw4Sc/+UnLIT/5yU8mTpxY0AbSIeQ68nXPPd/9+tdvP/30XpMnf/b88y88omknTKh6+eXfrFv3Vvbp2rVrfvvbly69dFIHNBNyoj9DutQg5O+BBx647bbbjj/++PHjx1900UVHNO3kyZNfeOGFNWvWZJ+++eabL7744hVXXNEBzaTAXDeFNrW8GC5FK7oSTuuaDfpzFKLrzzFSg7RDDRY5dRSFtOqoSypLJRY+34ucz/cjoj8XOf255KnBIqcGo6COilyKdeQ4TAAAgLjJdQAAAHGT6wAAAOIm1wEAAMRNrgMAAIibXAcAABA3uQ4AACBuch0AAEDc5DoAAIC4yXUAAABxk+sAAADiJtfRUdasWTN58uTevXv37Nmzqqpq69atabcIjp7+DOlSg5A/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9KA138G5059zpz/TEdRg7gr5Xr39dhgzJmzf3tnLpWOoo9wV8L16++23x4wZs73o6+jAcZj19fXZB+vWrRs4cGA7EwwePLi+vr75JMJWd0oOHDiweYZr16497LRjx4599NFH//CHPyxatGj69On5rxXEyJlIlBL9GYpCRUXo2jXtRkDcKioqusZQRwdy3Zw5czZt2rRp06bDXr5sxowZNTU1tbW1TU1NK1eurK6uPnScq666qnmGs2fPPuy0U6dOff311/fs2RPcNI8ypvNTSvRnSM3UqWHVqtDUFGprw3XXhSlT0m4QxGfq1KmrVq1qamqqra297rrrpsRQR12y/7v44ovHjh27Z8+e6urq22+/vZ0JZs2aVVFRUVVVVV9ff8YZZyxYsODQcebNmzd79uzRo0cfc8wxt9xyy7//+7+3P+2kSZOqqqoaGhpGjBjx8MMPF3QFAQDKSVVVmDYtvPlm+MQnQnV1uOOOtBsE8amqqpo2bdqbb775iU98orq6+o4Y6ujA+XXRHTJLJ3AMd+7SKiLFmzv9OXf6Mx1BDeZODdIWdZS7Mqwj9yUHAACIm1wHAAAQt4oQ4X5VAAAAmtlfBwAAEDe5DgAAIG5yHQAAQNwKluvyuQWt29cCAAAcNfvrAAAA4lYRQti7d+/8+fNPPvnkE0888Z577sm+sHv37tmzZ/fv379fv36zZ8/evXt3dniSJN/5zneGDBlSWVl5/vnnr1q1Knywwy1JkuY9b/v371+wYMHQoUN79eo1ffr0xsbGEMKMGTP++Z//uXnZDz744A033JDjtCGEp59+euzYsZWVlUOGDLn//vs7/s0BAACIQEUI4W//9m9/9atfLVu2bN26dRs3bsy+8PWvf3316tUvvfTSihUrXnvttYULFzZP88tf/nL58uVbt2699NJLr7/++vDBnRIymUzzLRMWL168fPnyZcuWrV27ds+ePfPnzw8hLFmy5Hvf+96Pf/zjEMKPf/zj73//+/fee2+O04YQrr766nnz5r333nvPPvvsCy+80CnvDwAAQLFLMpnM6aef/uijj5555pktXzj11FMfe+yxkSNHhhBWrVp1+eWX19XVhRCSJNm8eXO/fv1CCDt37uzTp8/OnTuzw1veB2/EiBFLly4dNmxYCGHLli3jxo1bv3599vH5559/5ZVX/uhHP3r++ef79u2b+7SD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vTfffHPza9XV1ddcc01dXd3evXu3bdu2b9++7PC2bmzQ1vghhPr6+uyDdevWDRw48NBpBw8eXF9fn/lA87Rjx4599NFH//CHPyxatGj69OkFWGMAAIDSUhFC+NznPrdjx46/+7u/+6M/+qOzzjqr+bXGxsYePXp07969oaGhpqbmsPNqZ/w5c+Zs2rRp06ZNc+bMmTZt2qHTzpgxo6ampra2tqmpaeXKldXV1dnhU6dOff311/fs2RPcKA8AAKA1B65pOXv27NmzZ99yyy0tX3vggQduu+22448/fvz48RdddNFh59XO+Bf//+3df2zU9f3A8c9VFlcILSssFL3RpAAAG7tJREFUKzQyfqlQ5A87poiZhPGHcSjtLmWj7QyGhE3GCNTErQiyxOCZ6ab+N7NI9v2DjiUaQU2HxkmYk41oYzJ+zo5SO9uijoGSFMOv3veP2y4dpZWWo597l8fjH6+f+/TT1zX3jvfkc/fpt79dUVExZ86c6dOnP/LII32/d82aNUuWLEkmk0VFRXV1dbW1tZntlZWVyWSyuLj40UcfbWxsHOKjBAAAGLni+9AnQfDZ3DznM+6D4vmc5zyfh4frptAfa/CyuW4K/Yrxuilx/WAAAAByQtcBAACETdcBAACETdcBAACEbaCuu5y/KzDYvz3gbxUAAADklvN1AAAAYdN1AAAAYdN1AAAAYSuIoujMmTOrVq0qKSkpLS198sknL/kRuDNnzqxbt27ixImlpaXr1q07c+ZM9q4nn3zya1/72vjx43/yk5+cPXs2s7GlpaW6unr8+PHjxo1LJpPHjx+/6IA9PT2bN2+eOnVqSUnJihUruru7M9vffPPNioqKwsLCKVOmPP/881flQQMAAIwgBVEUbd68ub29/cCBA++9996bb755yf0ef/zxgwcPvvvuu83Nzfv27UulUtm73njjjffee2/fvn3vv//+E088kdm4dOnS1atXd3R0tLe3l5WVrV+//qIDPvvss7t37961a1dra+u5c+c2bdqU2X7//fdv2LDh008/feutt/bu3Zv7RwwAADCyJNLp9PTp05uammbOnBlF0aFDh2bPnp1Op6MoSiQSmRtRFE2fPv3VV18tLy+PoujAgQNVVVVHjhzJ7HPw4MHM9oMHD1ZWVma293bq1KnZs2d/+OGHvY85a9asHTt23HzzzVEUffzxx7ff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ug4AACBsug4AACBsug4AACBsug4AACBsug4AACBsug4AACBsBVHcfxkdAACAK+F8HQAAQNgKMifrEolE9qxdS0tLdXX1+PHjx40bl0wmjx8/ntn+5ptvVlRUFBYWTpky5fnnn49tZAAAAHopSKfTURSl0+nMjSiKli5dunr16o6Ojvb29rKysvXr12e233///Rs2bPj000/feuutvXv3xjYyAAAAvVzifZh/+9vfFi5cWFhYWFxc/Pjjj7/22muZ7aNGjerq6vrkk08mT57sfB0AQF/btm0rLy8vLCysqKjYs2dP3ONAkKyjIbhE1zU3Ny9atKikpCSRSBQXFx87diyzfceOHbt27br11ltvuummnTt3Du+cAAAB2Lp1a2Nj48mTJ+vr6+vq6uIeB4JkHQ3BqKjP9TCXLVu2adOmF154obi4+NSpUyUlJZntFRUV27dvT6fTf/jDH1asWJHtPQAAMpqamjI35s2b19PTE+8wECjraAgKoiiaMGHC4cOHs5u6u7uLiorGjBnT3t6+cuXK7PaamppDhw6dO3cu8qcRAAD619raunjx4lQqFfcgEDDraFAKoihqaGiYP39+NtW2bNnS0NAwduzYhQsXLliwILtrZWVlMpksLi5+9NFHGxsb45kXACDvJZPJVCr1gx/8IO5BIGDW0aAkspfBhL62ffZy3CMwkJriyrhHCInnc57zfB7xhrYGa8ZVRVEUhfZypaCgILA3j2X+fT+03/M1aGjrqHZcVRRFwb3sD24dZc6TxfV79nfJAQByLKwXo5CfrKNB0XUAADnmSgRw5ayjQdF1AAAAYdN1AAA5FtwHmSAPWUeD8p+uS6VS9957b7yjXP6Z1t57Oj8LAABc40ZFUdTd3f3MM8/85S9/iXuYvJNIuF4oAACQ7wqiKHrppZfmz59/4403xj3Mf8R4Cu6iHy3qAACA/FcQRdGrr766dOnSuCcBAABgKAqiKGpubr7jjjuymxL/K7PxzJkz69atmzhxYmlp6bp1686cOZPd+bnnnpsyZUphYeEdd9xx4MCBzPaenp7NmzdPnTq1pKRkxYoV3d3dfX/22bNnV69ePX78+NLS0qeeeqrvDi0tLdXV1ePHjx83blwymTx+/PgAj6S/Cc+fP79p06avf/3rX/nKV371q18NcOTMg+39qIf88AEAAIZNQRRFH3300cSJE7Ob0v/1m9/8Jnsxlccff/zgwYPvvvtuc3Pzvn37UqlUdv/XX3999+7dx48fv+eeex588MHMxmeffXb37t27du1qbW09d+7cpk2b+v7sVCrV0tKyb9++5ubmnTt39t1h6dKlq1ev7ujoaG9vLysrW79+/QCPpL8Jf/GLX/z5z3/etWvX0aNHOzo6Bjhy5l2Xmcd+mQfv7+EDAAAMm0Q6nS4sLPz3v/89evTo3nf88Y9//OlPf/qnP/1p7NixURRNnz791VdfLS8vj6LowIEDVVVVR44ciaIokUgcO3astLQ0iqLTp09PmDDh9OnTURTNmjVrx44dN998cxRFH3/88e233/7BBx9c9LNnzJjxyiuvZI85Z86cAT7PdurUqdmzZ3/44YfR/17OJHu7vwlvvPHG7du333LLLYM98uUcvL+HP2Js++zluEdgIDXFlXGPEBLP5zzn+TziDW0N1oyriqIo8on3qy3zHiW/57w3tHVUO64qcuWIqy/zXr+4fs8FURRNnDixq6ur99ZDhw79+Mc/fumllzJRF0VRV1fXtGnTMrdnzJjR2dmZ3TlTNVEUjR49+vPPP8/cbm9vnzlzZuY9jaWlpZlqukhnZ2fvY/bdobm5edGiRSUlJYlEori4+NixYwM8kv4m7Ojo6HvwQR15gINH/Tx8AACAYVMQRdHcuXP37NmT3fTJJ58kk8nf/va3U6ZMyW6cNGnS0aNHM7ePHDlSVlY28HEnT57c1taWfUvnhQsX+u5TVlbW1taWud3a2tp3h2XLli1fvvzIkSPnz58/ceLEJQ/yhRPecMMNmXNrl3Pk/i7FOdiHDwAAMGwKoii69957X3zxxeymysrK9evX33nnnb33q6mpWbt2bUdHR0dHx9q1a2tqagY+7qpVq1auXHn48OGzZ8/u379/2bJlffepra2tr6/v7Ozs7Oxct25d3x26u7uLiorGjBnT3t6+cuXKgX9ifxM+8MADa9asOXr06MmTJ+vr6wc+8oQJEw4fPnz5BwcAAIhdQRRF1dXVe/fubWlpyWzau3fvAw88cNH1MDdu3Dhr1qy5c+fOnTt39uzZGzZsGPi4a9asWbJkSTKZLCoqqqurq62t7bvPhg0bpk6dOmfOnIqKirvvvrvvDlu2bGloaBg7duzChQsXLFgw8E/sb8KHH354/vz5CxYsmD59+uTJkwc+ckNDw/z58/uetRvswwcAABg2/7kuyBNPPPH22283NTXFPQ/5xXUm8pzrTAyK53Oe83we8Vw3Ja+5bkogXDcln8V73ZRRmf8M/CcEAAAAyFsFcQ8AAADAFdF1AAAAYRsV9wAAAF+gvz9ERK743NW1wDoa2S7RdYlEYmR8qvI73/nOXXfd1dDQEPcgAMAVGRmvTPKaV/zXAOvoaou3nPPlfZhX47fw9NNPP/30059//nnOjwwAAJA/8qXrrsa/H8ycOXPu3Lkvv+zK5gAAwEiWL113lXzve9975ZVX4p4CAADgKiqIoujs2bOrV68eP358aWnpU089lbnjrrvu+v3vf5/d75///OekSZM+++yzKIoSicRzzz03ZcqUwsLCO+6448CBA5l9Wlpaqqurx48fP27cuGQyefz48cz2RCLx61//etq0addff/0tt9zy9ttv/9///d9NN92U+fa///3v0f++D/OiebJ3XfRezeyXPT09mzdvnjp1aklJyYoVK7q7u7P73Hnnne+8804uf2EAAAB5piCKolQq1dLSsm/fvubm5p07d2bu2LBhw2OPPdbT05P58rHHHlu7dm1xcXHmy9dff3337t3Hjx+/5557HnzwwczGpUuXrl69uqOjo729vaysrPffOm9qanrjjTdOnDhRW1v7ne98Z/v27a+99trx48fvu+++7LdnXXKeATz77LO7d+/etWtXa2vruXPnNm3alL1r0qRJXV1dQ/zdAAAAhCCRTqdnzJjxyiuvlJeXR1F04MCBOXPmZD7tdtttt61bt662tvYf//jHwoULW1paRo8eHUVRIpE4duxYaWlpFEWnT5+eMGHC6dOnLzruqVOnZs+e/eGHH2b27+rqmjhxYmb/MWPG9P323hfh7G+eiy7Umf1y1qxZO3bsuPnmm6Mo+vjjj2+//fYPPvggs8/p06e/+tWv9j6Dx6Bs+8ynE/NaTXFl3COExPM5z3k+j3hDW4M146qiKIpcx+9qy7wNyu857w1tHdWOq4pcD/Pqy7ydMK7fc0EURZ2dndOmTct8PWPGjOx9mVN2Fy5c+PnPf/6zn/0sE3UZmSqLomj06NHZC042NzcvWrSopKQkkUgUFxcfO3Ysu38m6jL79/ftWf3N05/29vaZM2cmEolEIlFaWpqJyeyhsj8LAABgRCqIoqisrKytrS3zdWtra/a+JUuWXH/99evXr//rX//6wx/+8AuPtWzZsuXLlx85cuT8+fMnTpy4cOHC0Gbqb54vf/nL2RODH330UXb75MmT29ra0v/V++fu2bPntttuG9oYAAAAQSiIoqi2tra+vr6zs7Ozs3PdunXZ+xKJxCOPPPLUU09t3Ljx+uuv/8JjdXd3FxUVjRkzpr29feXKlUOeqb95vvGNb/zyl7/s7u5ua2v70Y9+lN2+atWqlStXHj58+OzZs/v371+2bFn2rhdffPG+++4b8iQAAAD5ryCKog0bNkydOnXOnDkVFRV3331377uvu+66G2+8cfny5ZdzrC1btjQ0NIwdO3bhwoULFiwY8kz9zfPcc8/t3LlzwoQJCxcuvOeee7Lb16xZs2TJkmQyWVRUVFdXV1tbm9n+/vvvv/POO9/97neHPAkAAED+Swz8wb4lS5bU1NTU1NQM20B9XXS5lMu3ePHib33rWw0NDTkf6drhOhN5znUmBsXzOc95Po94rpuS11w3JRCum5LP4r1uyqj+7ujp6Xn++efb2tq+//3vD+dAOdTU1BT3CAAAAFddv1133XXXTZky5YUXXigoKBjOgQAAABiUfpstnU63tbXNnTt3OKfpb5K4RwAAuCzbtm0rLy8vLCysqKjYs2dP3ONAkKyjIXAuDgAgZ7Zu3drY2Hjy5Mn6+vq6urq4x4EgWUdD0O/7MAEAGKzsx/vnzZvX09MT7zAQKOtoCJyvAwDIsdbW1sWLF6dSqbgHgYBZR4PifB0AQI4lk8lUKlVdXR33IBAw62hQnK8DAMix/fv3ezEKV8g6GhRdBwCQYz4RBFfOOhoUXQcAkGOJRCLuESB41tGg6DoAAICw6ToAgBxLp9NxjwDBs44GRdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACETdcBAACEbVTcAwAAfIFEIhH3CCNcOu4BGAbW0cim6wCAfJdO646rzCv+a4B1dLXFW87ehwkAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAkDPbtm0rLy8vLCysqKjYs2dP3ONAkKyjIdB1AAA5s3Xr1sbGxpMnT9bX19fV1cU9DgTJOhqCUXEPAAAwcjQ1NWVuzJs3r6enJ95hIFDW0RA4XwcAkGOtra2LFy9OpVJxDwIBs44Gxfk6AIAcSyaTqVSquro67kEgYNbRoDhfBwCQY/v37/diFK6QdTQoug4AIMd8IgiunHU0KLoOACDHEolE3CNA8KyjQdF1AAAAYdN1AAA5lk6n4x4BgmcdDYquAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACJuuAwAACNuouAcAAPgCiUQi7hFGuHTcAzAMrKORTdcBAPkundYdV5lX/NcA6+hqi7ecvQ8TAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOAAAgbLoOACBntm3bVl5eXlhYWFFRsWfPnrjHgSBZR0Og6wAAcmbr1q2NjY0nT56sr6+vq6uLexwIknU0BKPiHgAAYORoamrK3Jg3b15PT0+8w0CgrKMhcL4OACDHWltbFy9enEql4h4EAmYdDYrzdQAAOZZMJlOpVHV1ddyDQMCso0Fxvg4AIMf279/vxShcIetoUHQdAECO+UQQXDnraFB0HQBAjiUSibhHgOBZR4Oi6wAAAMKm6wAAciydTsc9AgTPOhoUXQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABA2XQcAABC2UXEPAADwRRKJuCeA4CWsoxHN+ToAAICwOV8HAOSvbZ/uiHuEa0VNcWXcI3C1/M46Gi4xriPn6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKm6wAAAMKWSKfTcc8AAADA0P0/GQcL2HPG7TcAAAAASUVORK5CYII=" alt="Déroulement de l’appel de array_init" /><figcaption>Déroulement de l’appel de <code>array_init</code></figcaption>
</figure>
<h2 id="re-dimensionnement"><span class="header-section-number">7.3</span> Re-dimensionnement</h2>
<p>Pour re-dimensionner, on va utiliser la fonction <code>realloc</code> qui fait le gros du travail :</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1"><span class="dt">void</span> array_resize(<span class="kw">struct</span> Array *array_ptr, <span class="dt">int</span> new_size)</a>
<a class="sourceLine" id="cb83-2" title="2">{</a>
<a class="sourceLine" id="cb83-3" title="3">    array_ptr-&gt;data = realloc(array_ptr-&gt;data, </a>
<a class="sourceLine" id="cb83-4" title="4">                              new_size * <span class="kw">sizeof</span>(<span class="dt">float</span>));</a>
<a class="sourceLine" id="cb83-5" title="5">    array_ptr-&gt;size = new_size;</a>
<a class="sourceLine" id="cb83-6" title="6">}</a></code></pre></div>
<p>La fonction <code>realloc</code> prend comme paramètres</p>
<ul>
<li>un pointeur sur une zone déjà allouée,</li>
<li>une nouvelle taille ;</li>
</ul>
<p>elle s’arrange pour réallouer la zone indiquée, avec la taille voulue, au besoin en la déménageant ailleurs. Le contenu a été copié au passage.</p>
<h2 id="exercice-écrire-un-test"><span class="header-section-number">7.4</span> Exercice : écrire un test</h2>
<p>Écrire un test où le tableau est</p>
<ul>
<li>créé et initialisé avec 10 éléments,</li>
<li>affiché,</li>
<li>redimensionné à 20, on ajoutera des valeurs dans les cases supplémentaires,</li>
<li>affiché,</li>
<li>réduit à 5,</li>
<li>affiché.</li>
</ul>
<h2 id="exercice-écrire-la-fonction-array_resize-sans-realloc."><span class="header-section-number">7.5</span> Exercice : écrire la fonction <code>array_resize</code> sans <code>realloc</code>.</h2>
<p>Pour ça, il faut</p>
<ul>
<li>réserver une zone à la nouvelle dimensionn</li>
<li>recopier l’ancienne zone “data” dans la nouvelle (attention aux deux cas : agrandir et rétrécir),</li>
<li>libérer l’ancienne zone,</li>
<li>remplacer l’ancienne par la nouvelle,</li>
<li>et ne pas oublier de modifier le champ <code>size</code>…</li>
</ul>
<h1 id="chaînages"><span class="header-section-number">8</span> Chaînages</h1>
<p>On parle de <strong>chaînage</strong> quand on a des éléments dont un champ sert à indiquer où se trouve un autre élément (le suivant). Bien entendu, quand les éléments sont des données en mémoire, les pointeurs sont un moyen privilégié de matérialiser ce chaînage, grâce à un champ qui indique l’adresse du suivant.</p>
<p>Voici par exemple des éléments, qui ont pour vocation</p>
<ul>
<li>de contenir une valeur entière ;</li>
<li>d’être chaîné avec un autre élément.</li>
</ul>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1"><span class="kw">struct</span> Element {</a>
<a class="sourceLine" id="cb84-2" title="2">    <span class="dt">int</span> value;</a>
<a class="sourceLine" id="cb84-3" title="3">    <span class="kw">struct</span> Element *next_ptr;</a>
<a class="sourceLine" id="cb84-4" title="4">};</a></code></pre></div>
<p><strong>Note :</strong> on garde ici la convention de mettre le suffixe &quot;_ptr&quot; pour les données qui contiennent des adresses. C’est un peu plus long mais si on met <code>next</code> tout court (ce que font la plupart des tutoriels sur les pointeurs), on risque des confusions entre “l’élément suivant” qui est une structure avec “le pointeur vers l’élément suivant” qui est une adresse.</p>
<p>Le plus souvent, ce chaînage sert à représenter des <em>séquences</em> (suite linéaire d’éléments, le dernier n’a pas de suivant). Mais plus généralement, il pourrait aussi y avoir des chaînages circulaires (on dit aussi <em>listes circulaires</em>), ou des chaînes terminées par un cycle.</p>
<figure>
<img src="data:image/png;base64,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t7c3d/133HGHy5QruLaenp7q6mr7n5YvX553zC4PysuY3R/48PDw0qVLnR5IsfsEQHByG0Le5e6HfC73JnDbbbcJITZu3Gi/y6ZNm4QQy5YtK3j3rOHRUmKKOJUIRbWYa6+99ujRo++///7dd98thFiwYIF1g507dwohqqurn3nmmdOnTw8MDBw+fPgLX/iCEOLee+/NXf/EiROFEC0tLWfPnh0aGvrTn/60fPly72tbv369EGL27NkHDhw4f/78/v37a2pqXNpQ3iVexuz+wDdv3iyEqKys3LZt27vvvjs4OHj48GGzS5awTwAEx69el8W9Cfztb38TQnzmM58ZGhoyl4yMjMyaNUsIcfjw4YJ3zxoeLSWmiFOJUFSLOXLkiPnrqVOnhBAVFRXWDb70pS8JIQ4dOmRfydtvvy2EuOKKK3LXf8UVVwghvvnNbz700EMHDx4cHR21/7Xg2urq6oQQzz//vPXXZ599ttg45WXM7g/86quvFkK0tbXlPsAS9gmA4PjV67K4NwHDMG6++WYhxBNPPGH+unv3biHEDTfc4PHu9uHRUmKKOJUI5rVEWWlmdHRUCJFKpawl5iE9ODho/jo2NpbVgy666CLhYMKECbnb3bdv37Rp06zbXH755a+99pr3tZWXlwshzp07Z93l7NmzxcYpL2N2f+CZTEYI8d///jfvvi12nwAIjl+9Lot7EzAM48CBA0KI+fPnm78uXLhQ2F4KFry7feu0lJjiUvREuOSSS4QQPT099oWnT58WQlRVVWXd2Awx4uN/NrEznC/VHBkZyV24ePHid95554UXXli7du2MGTPeeuutn/70pyWvzYW1qqGhoZLH7PLAvWy64PoBBM2vXlesm2666brrrnv99df37dt35MiRI0eOXHnlld/61rdKWBUtJaaIU4lw5ZVXCiFefvll+8KXXnrJ+pNH8+bNE0L8+c9/zpvN894lk8nccsstra2tf/3rX4UQ5kUGHtdWW1srhDh06JB1l4MHD2atf8qUKUKIf//73+avr776qvyYs8ydO1cI8Zvf/MavfQIgIH71uizuTcB0//33CyFaWlpaW1uFEM3NzVZK83J3Cy0lrlzPXUETW7duFUJMnTp1z549PT09PT09u3fvNoPItm3brJvlTomsJbt27RJCfPrTn965c2dnZ+fAwMDg4OCxY8fa2toWLVqUu92vf/3rL730Ul9f3/nz5x977DEhRDqd9r42L5eiL1q0SAixZs2a3t7e9vb2a6+9toQxuz/wlpYWIcTFF1+8Y8eOrq6uwcHBP/7xj9ZlpMXuEwDB8avXZXFvAqaxsbH6+vpUKjV+/PiZM2dal6V7ubt967SUmCJOJcLQ0NB1112XG6avv/764eFh62ZeWoz93bqC0Tz3No2Njd7X5uWDEh5//HH7DW699dYSxuz+wIeHhxcvXuzyeIvaJwCC42OvsyvYBExPPfWUuXzTpk1F3Z2WogFqkxQDAwOPPPLIVVddlU6nM5nMVVdd9cgjjwwMDNhv47HF7Nu3b8WKFTNnzpwwYUImk5k3b966devs15hb9u/ff+utt06ePDmTycydO/fhhx/O2mLBtZ04ceI73/lORUXFpEmT7rrrrv7+/qwhjY2N3XvvvZMnT7744otXrlzZ19dXwpgLPvDh4eFHH310/vz56XS6oqKioaHB/v+GRe0TAIHysdfZFWwChmEcP35cCFFVVZX7AVHud8/dOi0ldviSGcQM38YAQE2PP/746tWrm5ubH3300ajHgrBxKToAALLOnTv39NNPCyFWrVoV9VgQgbKoBwAAQLxZ/8R3yy23yPwLIeKLOAUAgKx0Ot3Q0GB+RQwSiGunAAAApPwPiN0HPUgfLz0AAAAASUVORK5CYII=" alt="Chainages" /><figcaption>Chainages</figcaption>
</figure>
<p>Le pointeur <code>NULL</code>, qui marque l’absence d’élément, est dessiné sous forme d’une croix.</p>
<h2 id="notions-de-base-les-listes-simples"><span class="header-section-number">8.1</span> Notions de base : les listes simples</h2>
<p><strong>Pour représenter une liste</strong>, il nous faut un pointeur sur le premier élément.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb85-1" title="1"><span class="kw">struct</span> Element * first_ptr;</a></code></pre></div>
<figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoEAAACtCAIAAABAwDKLAAAAA3NCSVQICAjb4U/gAAARZUlEQVR4nO3da2wUVR/H8TMNShuIQhFqgLaUJrJoKqFGQ9XgBYKJMZYQiBQFhUBMtS8AL0EweAnRSKCQatRUgvEFLxqvhIgStKlEE00MKvRqkLbSplWh3Loire08LwbWfXa729m5njnz/bzaTndmzs5/5/zmvpqu6wIAAHguSwjx7bff5ufna5rmd2MAAAiRLCHE5s2b9+zZY+wQk8QAAHhD03V9woQJf/7557XXXmtlfE2zdjTb8ogAAKhB03XdThySwQAAWJNlHHzW4sT+p2narl278vPzs7KyhBBff/11aWlpTk7OjBkz9uzZI64euE4YK4Gmadu3b8/Ly5s0aVJVVdXAwMCIIybMCwAA5WUZO6P6VQn//uabb3744Yfh4WEhxMqVK7ds2XLu3LkjR458//33xlixcdPM4/Dhw0ePHj127FhbW9vrr7+easT4eQEAoLzEY9EJrzs6OgoLC40/CwoKnnvuucWLF+fn5/83/miHlDVNa2pquvnmm4UQTU1N5eXlJ06cSB4xYV4AAChvlAO/BQUFsdefffZZfX393Llzb7rppi+++ML8PGbOnGm8KC4u7u7uNjMvAACUN8p+cPI+rq7rBw8eXLt2bU9PjxAiKysr/dFjTdOam5tnz54thGhubn744YeN/eCEEblECwAQNhlcAFVRUdHc3Dw4OCjibiO+4YYbWlpa0o+4YcOG7u7u7u7uDRs2PProo+ZHBABAYWPMv7W8vHzJkiWdnZ2zZ8/et2+fMXDTpk133nnnuXPn0uzF3n///aWlpYODg8uXL9+8ebP5EQEAUJitI8BSPVSLLAcABEsG+8EjGjX5vDnRK9XWAAAAZtjN4HgEIQAA5jmZwRwNBgDAPB4MCQCAP8hgAAD8QQYDAOAPJ88HwwJXL2TjDD0AyIwMdteoEetqTPo7dwBAemSwM1Klnb8hZ+bubWsjAgDsI4OtSI6ugIZWqmYr8wEBQGZksCkJmaR8ICV/wLAtAQDwABk8MiInQcIScGT58IOVAEJOwQw24sFC5x6fK2RDemkiOaNFRwwDCDOlMjg+CWKv03fx5K4j4hedyUUaexsxDCC01MngVJf4Jnfx5K6rrOUxhVCJ5WNRCATq6yB1Mjg9ctcX5vOYGFYPPbXaqK8jQpHB9O8ySJXH8QMpk3roqdVGfW3iedGQCD9BrSpN0yiuwqivZWQw5MKarDB6arVRXwtCcSya4yRSGXUtZTXOiDxfb5OFo74ZkaG+GZWM+mYkFBkMySVfuC5DvxMIMvR3yfcB8mMhTvGxvmkuoqS+TtE0Tf0M5tsgGyqikowuyTHeJsN2A1Ix+WSFEVFfC9TJ4BHLT3cPuMf8EQvWxECwfAiK+lqmTgYb+CoA3jDZX7NKBoLlW4yor02qZTAAD5gJYHrnoLC2+0t9HUEGA8jMqF02vXNQWNv9pb4O4v5gAAgvAtVfZDAAhBE3AcqADAau4J4KM4LbcVPfeMGtYyoBrS8ZDMCsgHZzSEAd5UEGA8iAYjtPoUUdJUEGA0CIqHcUOtDIYKipr69v8uTJZ8+ejR+Sl5dnDPn111+XLl06adKkCRMmLFmy5PTp0wmjJxysi/05PDy8bdu2oqKi3NzcNWvWRKNRlz+HRKQ6gEl9rZGqiGmEp75kMNSUm5u7dOnS2tra2JDa2toVK1ZMnDhRCLFs2bKnn366q6urs7Nz2rRpL7zwgsnJ7t69u6Ghob6+/rfffhscHNy6dasrrZeVPPtP1NcyeYqYRojqq9tgc3QHydMS2OdUNVtaWgoKCgYHB3VdHxwcLCoq6ujoSH7b+fPnp0+fnjDfhDbE/oxEIq2trcbr3t7ewsJCR5pqmWfffPvdRfykHJkO9bUwNQ++MNTXPMF+MBQWiURuueWWjz/+WAjx0UcflZWVFRYWGv/68ccfFyxYkJubq2na9ddf39PTY3KanZ2dkUjE+K3yG2+88dSpU261Xj66ZPtP1NcC2YqYRljqazPDndkYsE2elsA+B6t56NChsrIyXdfnzZt39OjR2PDi4uIPPvjgzJkz//77b19fn7jaN8XekJ2dHY1GjdfGGm68njVrVnt7u1PNs8+zb76DM6K+5jlbX2++LdTXPMF+MJQUuwRj0aJFFy5cePPNN8ePHz937tzYG6LR6HXXXTdu3LjOzs5169YlT+G2227bsWNHNBptb29/8sknY8MrKyvXrVvX0tIyMDBw/Pjx5cuXu/1ZZCDbhTzU1wLZiphGuOprM8Od2hywSZ6WwD771YyfwnvvvZeVlXXo0KH4N3z++eezZs265pprCgoKampqRNJ29PHjx+fNm5ednV1YWPjOO+/E/jU0NFRTUxOJRMaOHVtSUrJ//36bTbXJm2++s3OhvuY5uOQ96ySpr3lCCFs3ikm1YWXng0Aqft2/GMTvszfLytm5UF/heX0t/zywtXlRX/P1tfXbhcQeFCPJV1qq3kQlYa6vJJ/dVZJ8xozqy/lgAOmwQQC4hwwGMApJdi8A9ZDBAKAyjmTIjAwGkBLdtxo4kiEtMhhAOnTfgHvIYAAA/EEGA4CyOJsgOTIYAFTG2QSZkcEAAPiDDAacp10VP/DLL79csGBBTk7O1KlT165de+bMGb+aB/tOnz5dUFAQX2Lt//nYNthx8ODBe+65Jzs7e+rUqU888cQff/xhDHdp/SWDAefFHsger7q6+tlnn/3rr79+/vnnMWPGPP744760DY546aWXKisrEwYmPI4fQbRjx47169f39va2tbXNnDlzxYoVxnCX1l9/Hq4NpOHjM9+dnW+aCV68eHH69Onnz5+32RK3l5Ub01egvq2trQ899FBjY2NOTk5smm5UzWabvfyphviZBr2+Mf39/Xl5edFoNGG4g+sv+8GAD+rr6+fMmeN3K2DRM8888+qrr2ZnZycMnzx58rhx40pKSmpqaoaGhnxpWwL2siyLRqNvvfXWfffdl/wvB9dfW7+bBMCCn376qaqq6sCBA343ZBR+7dBI7vDhw6dPn66oqEgYbiyry5cvHz9+fP369e3t7bt27fKjgXCAcQhhypQp3333XcK/nF1/WccgHWWOZY04wYaGhpUrV+7bt2/+/Pn2W+LqsnJp4kGv76233vr222/ffffdaab5+++/z5kz5+zZszZbYv9YtPeLOuj1jblw4UJ1dXV9ff2RI0diAx1ff8lgSEeZdTh5gnV1dRs3bvz000/vuOMOR1pCBns/3+RrnpMn29XVdfvtt/f09NhsCRns73wvXLgwderU/v5+40831l/OBwMeqa6ufv7557/66qv0KzAkl3Dxc6y3raioaGxsHBgYaGlpWb169bJly3xtJixatWpVS0vL4ODgqVOntmzZcu+99xrDXVp/2Q+GdBTYjk7YVTImm7z/dPHixfHjx9tpiXvLKohT9n6+8dP88MMPt23b1tbWNn369OXLl7/44ovJF21l2hI7bVZpOXs5X6OOra2teXl5Dz744GuvvZabmytcW3/JYEgn6OuwfWSwSvNNRgarNN9kHIsGACAAyGAAAPxBBgNIxOOOAW+QwQBGIMmpNUBtZDAAAP4ggwFANfJcJIz0yGAAAPxBBgP4P+xCAZ4hgwEA8AcZDACAP8hgAAD8QQYDAOAPMhjAf7ggSwEUMUDIYAAA/EEGAwDgDzIYAAB/kMEAoA5+8ypYyGAAV9B9q4ELsgKEDAbwH7pvwEtj/G4AIBF2BNVGfdUWxPqSwcAVId8FVP6mUrU/HQJaX45FAwDgDzIYABQRxIOxIUcGA4A6AnpINrTIYADsPwH+IIMBCMH+E+AHMhgIO3aC1UAdg4gMBsBOsCKoY+CQwQAA+IMMBgDAH2QwMAo7p9k4RSc/6qs2yetLBgOhpvwjKkOCOgYUGQyVaZr27rvvzpgxIycnp6ysrLGx0Rg+PDy8bdu2oqKi3NzcNWvWRKNRIURlZeX7778fG3fv3r1PPfWUsSGsaVr6LWJN07Zv356Xlzdp0qSqqqqBgQFxdSM6flxN03bt2pWfn5+VxarnAOqrtlDUVwck4+DXUgixePHi9vb2/v7+V1555a677jKG79y5c8GCBSdPnuzr63vsscc2btyo6/rAwMD8+fPr6up0Xa+rq5s/f/7AwIDJ9gghFi5c2NXV1dXVtXDhwpdffnnEzyKEKC8v7+7udvAD2hzd+06A+mb0AU2+TZ7OnPpm9AFlKRsQ4+w63NPTY7yORqM5OTnG60gk0traarzu7e0tLCyMvS4qKtq0aVNRUVFvb6/59gghmpqajNeNjY3FxcUjjiuE6OjosPOJkufr4+i+z5T6ZvQ2b1Bf88hgyMjZdXjEP3NycuKPBmVlZcXes3XrViHEjh07MmqPEOLSpUvG60uXLmVnZ6dqwPDwsKWPknK+dsZVIINH/DNs9ZWqJ6e+5gnOByOcCgoK2tvbY2vC0NCQMfyXX37Zu3fvJ598Ul1dfeLECWOgyWsj29vbjRcnT56cNm1aqnGlupJWV/QqHuqrNqXq62CkA46w/7WMTUGk2I7evXv3woULm5ubL1++fOzYsUceeUTX9f7+/pKSkoaGBl3XDxw4UFpa+vfff+u6Pnny5Obm5lHn+MADDxjnkxYtWrR161ZjeMK4jq9xlifo4+pPfc0zM0HZenLqa55clQMMHqzDQ0NDNTU1kUhk7NixJSUl+/fv13V91apVtbW1sTdXV1evXr1a1/WdO3dOmDAhfauEEG+88caUKVMmTpxYWVn5zz//GMMTxpUqg51tiZezpr6ZvsdL1Nc8IQS3lEE6ft3pKNVRRJNLwNqyMj6pX+s+9RXO1dffUo6I+opM6jvG7aYAAWK573C23/GgN5Gq1/aMkvUNZylTsbY0LNd3xBEzqi8ZDGRgxLUrWJ0gD1RKI1j1pZQJdF1Pf2DA2fo6svzJYCADqVa5oHSFUh2vk1CA6kspR2TEcKp0dLC+Tm0AcW8SEC4SxgmsoZQjunKtk5vbKA4egSCDgbBgz0kZlDI9V2PY2VMAZDAQIuw5KYNSpmfc/ON4DDt+Dp4MBkKB63eUwU6wec7GsBsrERkMqI8AVoaENwRLzqkYdmklIoMBxRHAiqGamYpdLG15Cu6tRGQwoDKOW6qEzSnL7Fyl5epiJ4MBZXHcUiUEsE3WYtjtxc4zOgA10WWrhGo6IhbDrj6PPSPsBwOqSfOcIAQR1XSWyau0vFnsZDCgILpsZRDAbhg1hj1b7ByLBuSV0E2M2ilwAlhm8dU008VTTVel+YEHL7d72A8GJJW8nZ5myz12/JkuW07Wqulyo8JuxKu0PF7y7AcDMkrVQSd3EOwtyc9kNWNvo5qeSfidJe83fchgIGAyPUANf4163jH2mlL6Iv4JHt6XgAwGgifWU/AIDgUQvb5z49cdTOJ8MAAg1GLXUnifxGQwACC84s8Bex/DZDAAIKSSL8Ky/wMPGSGDgYDh9GGwpK8X1fRRqqug7fzAQ6bIYEBGqbpmuuwgopoSSn8bkmcxTAYDkkp44AbP3wg0qikVM/cBexPD3JsESI2eWiVeHuREKuYfxOHBgzvYDwYAhIWFQHX1YmkyGAAQCpb3aN2LYTIYAKA+m4eUXbpniQwGACjOkXO6bpzOJ4MBACpz8KIqx2OYDAYAKMvxq5qdfbI0GQwAUJN7txU5FcNkMABAQa7e1yscimEyGACgGrcD2GD/YmkyGACgFG8C2GDzKi0yGACgDi8D2GAnhslgAIAivA9gg+UY5jcbAAAq8CuADdZimAwG/sMP2qiN+iovcCUmg4Er+JVAtVFftQW0vpwPBgDAH2QwAAD+IIMBAPAHGQwAgD/IYAAA/EEGAwDgDzIYAAB/kMEAAPiDDAYAwB9kMAAA/iCDAQDwBxkMAIA/yGAAAPxBBgMA4A8yGAAAf5DBAAD4gwwGAMAfZDAAAP4Y43cDgBFomuZ3E+Ai6qs26mve/wDbRcwtCByVjAAAAABJRU5ErkJggg==" alt="Une liste" /><figcaption>Une liste</figcaption>
</figure>
<p>Ce pointeur qui sera nul si la liste est vide.</p>
<h2 id="pour-parcourir-une-liste"><span class="header-section-number">8.2</span> Pour parcourir une liste</h2>
<p>nous aurons un pointeur qui contiendra d’abord l’adresse du premier élément (soit <code>first_ptr)</code>, puis du second, etc.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">struct</span> Element *ptr = first_ptr;  <span class="co">// adresse du premier (si il existe)</span></a>
<a class="sourceLine" id="cb86-2" title="2"><span class="cf">while</span> (ptr != NULL) {</a>
<a class="sourceLine" id="cb86-3" title="3">    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, ptr-&gt;value);</a>
<a class="sourceLine" id="cb86-4" title="4">    ptr = ptr-&gt;next_ptr;          <span class="co">// passage au suivant</span></a>
<a class="sourceLine" id="cb86-5" title="5">}</a></code></pre></div>
<p>Avec l’habitude, on préférera la boucle <code>for</code> idiomatique</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="cf">for</span> (<span class="kw">struct</span> Element *ptr = first_ptr; ptr != NULL; ptr = ptr-&gt;next_ptr) {</a>
<a class="sourceLine" id="cb87-2" title="2">    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, ptr-&gt;value);</a>
<a class="sourceLine" id="cb87-3" title="3">}</a></code></pre></div>
<h2 id="pour-construire-une-chaîne-vide"><span class="header-section-number">8.3</span> Pour construire une chaîne vide</h2>
<p>Au départ, la chaîne est vide, le pointeur de début est donc initialisé à <code>NULL</code>.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb88-1" title="1">first_ptr = NULL;</a></code></pre></div>
<h2 id="pour-ajouter-un-élément-en-tête"><span class="header-section-number">8.4</span> Pour ajouter un élément en tête</h2>
<p>C’est l’opération d’ajout la plus facile. A priori il y a deux cas à considérer : soit la liste est vide, soit elle ne l’est pas (!)</p>
<ol type="1">
<li>Si elle est vide, il faut mettre dans <code>first_ptr</code> l’adresse d’un nouvel <code>Element</code>, créé par <code>malloc</code>, contenant la valeur souhaitée et qui n’a pas de suivant. Et dire que cet élément est maintenant le premier de la liste. Soit un code de la forme :</li>
</ol>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb89-1" title="1"><span class="cf">if</span> (first_ptr == NULL) {</a>
<a class="sourceLine" id="cb89-2" title="2">    <span class="kw">struct</span> Element new_ptr = malloc(<span class="kw">sizeof</span> (<span class="kw">struct</span> Element));</a>
<a class="sourceLine" id="cb89-3" title="3">    new_ptr-&gt;value         = <span class="dv">1234</span>;</a>
<a class="sourceLine" id="cb89-4" title="4">    new ptr-&gt;next_ptr      = NULL;</a>
<a class="sourceLine" id="cb89-5" title="5">    first_ptr              = new_ptr;</a>
<a class="sourceLine" id="cb89-6" title="6">}</a></code></pre></div>
<ol start="2" type="1">
<li>Si la liste n’est pas vide, c’est presque pareil, sauf que le suivant du nouvel <code>Element</code> est l’ancien premier (qui devient donc le second)</li>
</ol>
<div class="sourceCode" id="cb90"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb90-1" title="1"><span class="cf">if</span> (first_ptr != NULL) {</a>
<a class="sourceLine" id="cb90-2" title="2">    <span class="kw">struct</span> Element new_ptr = malloc(<span class="kw">sizeof</span> (<span class="kw">struct</span> Element));</a>
<a class="sourceLine" id="cb90-3" title="3">    new_ptr-&gt;value         = <span class="dv">1234</span>;</a>
<a class="sourceLine" id="cb90-4" title="4">    new_ptr-&gt;next_ptr      = first_ptr;</a>
<a class="sourceLine" id="cb90-5" title="5">    first_ptr              = new_ptr;</a>
<a class="sourceLine" id="cb90-6" title="6">}</a></code></pre></div>
<ol start="3" type="1">
<li>Mais en fait le second cas recouvre le premier : si <code>first_ptr</code> est <code>NULL</code>, affecter la valeur <code>NULL</code> ou celle de <code>first_ptr</code>, c’est la même chose. Donc on n’a pas besoin de tester <code>first_ptr</code> pour séparer les cas, et on se contente de :</li>
</ol>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb91-1" title="1"><span class="co">// allocation d'un nouvel élément</span></a>
<a class="sourceLine" id="cb91-2" title="2"><span class="kw">struct</span> Element new_ptr = malloc(<span class="kw">sizeof</span> (<span class="kw">struct</span> Element));</a>
<a class="sourceLine" id="cb91-3" title="3"></a>
<a class="sourceLine" id="cb91-4" title="4"><span class="co">// remplissage de l'élément</span></a>
<a class="sourceLine" id="cb91-5" title="5">new_ptr-&gt;value         = <span class="dv">1234</span>;       <span class="co">// </span></a>
<a class="sourceLine" id="cb91-6" title="6">new_ptr-&gt;next_ptr      = first_ptr;  <span class="co">// null si premier ajout</span></a>
<a class="sourceLine" id="cb91-7" title="7"></a>
<a class="sourceLine" id="cb91-8" title="8"><span class="co">// mise à jour du pointeur de début de liste</span></a>
<a class="sourceLine" id="cb91-9" title="9">first_ptr              = new_ptr;</a></code></pre></div>
<p>Ci-dessous une illustration</p>
<figure>
<img src="data:image/png;base64,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" alt="Ajout en tête" /><figcaption>Ajout en tête</figcaption>
</figure>
<h2 id="pour-retirer-le-premier-élément"><span class="header-section-number">8.5</span> Pour retirer le premier élément</h2>
<p>il faudra libérer le premier élément et mettre à jour le pointeur de début de liste. Mais attention à procéder dans le bon ordre</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb92-1" title="1"><span class="kw">struct</span> Element old_ptr = first_ptr;</a>
<a class="sourceLine" id="cb92-2" title="2">first_ptr              = old_ptr-&gt;next_ptr;</a>
<a class="sourceLine" id="cb92-3" title="3">free(old_ptr);</a></code></pre></div>
<p>Pour bien comprendre, prenez le temps de faire un dessin avec toutes les étapes.</p>
<h1 id="réalisation-dune-pile-par-chaînages"><span class="header-section-number">9</span> Réalisation d’une pile par chaînages</h1>
<p>Avec ces opérations qui sont relativement simple on peut réaliser une “pile” (<em>stack</em>), une structure de données d’usage courant en programmation</p>
<h2 id="quest-ce-que-cest-1"><span class="header-section-number">9.1</span> Qu’est-ce que c’est ?</h2>
<p>Pensez à des feuilles de papier posées les unes sur les autres. Vous pouvez</p>
<ul>
<li>regarder ce qui est écrit sur celle qui est au <em>sommet</em> de la pile</li>
<li>poser une feuille dessus (<em>empiler</em>)</li>
<li>enlever celle du dessus (<em>dépiler</em>)</li>
<li>et aussi regarder si il reste des feuilles dans la pile (tester si la pile est vide)</li>
</ul>
<h2 id="quel-rapport-avec-les-chaînages"><span class="header-section-number">9.2</span> Quel rapport avec les chaînages ?</h2>
<p>Les opérations qu’on a vues avant permettent de représenter facilement une pile par une <strong>liste chaînée d’éléments</strong> contenant des valeurs</p>
<ul>
<li>empiler : c’est ajouter au début,</li>
<li>dépiler : c’est enlever le premier élément,</li>
<li>test de pile vide : comparer le pointeur de sommet et <code>NULL</code>,</li>
<li>la valeur du sommet de la pile est accessible par indirection de ce pointeur.</li>
</ul>
<p>On utilisera les déclarations suivantes</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb93-1" title="1"><span class="kw">struct</span> Element {</a>
<a class="sourceLine" id="cb93-2" title="2">    <span class="dt">int</span>             value;</a>
<a class="sourceLine" id="cb93-3" title="3">    <span class="kw">struct</span> Element *next_ptr;</a>
<a class="sourceLine" id="cb93-4" title="4">};</a>
<a class="sourceLine" id="cb93-5" title="5"></a>
<a class="sourceLine" id="cb93-6" title="6"><span class="kw">struct</span> Stack {</a>
<a class="sourceLine" id="cb93-7" title="7">    <span class="kw">struct</span> Element *top_ptr;</a>
<a class="sourceLine" id="cb93-8" title="8">};</a></code></pre></div>
<p>Le nom <code>top_ptr</code> a été choisi pour mieux refléter l’intention : c’est un pointeur (<code>ptr</code>) vers l’élément qui représente le sommet (<code>top</code>) de la pile.</p>
<figure>
<img src="data:image/png;base64,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/EpSiMmBwcliB6PIdZk/ZNFndir0Y2JzYHACgOyIT5GFDE4Df7Awk+rs7Fy5cuVDDz00YMCA1NTUp5566uDBg8bOHYgN5SZsR3yKyeaKc+bMmdeuXduzZ8+NGzdOnz49a9astWvX2tskABAK132KJklRlIMHD44bN87j8QwfPvz1119X7v08+jtcuFyuioqK7OzspKQkJeD3057euXNnzZo1ubm5KSkpmzdvDjopvbq6uo0bN371q1/98pe/PHTo0J/85Cc1NTWBo5w5c2b69OlpaWnJycnTpk1rb28PNTu9//73v5mZmZWVlUZ8UQBgGy5cEUqSoiglJSWrV6++ceNGXV3dBx98oOhOj9b/WrW1tYcPH+7t7Q0zufXr1x86dKi6urq5ubm1tTXUpDSTJk366U9/+v7773d1dWkDA0eZMWPG4sWLW1tbz507l5mZuXLlylCz07z33ntTpkx59dVXly5dGsP3ggTHfloIiPgUhc/ny87OrqqqOn/+fOA/4uqfnj17Nsyr6oMHH3ywvr7e90V+b9br7Oz81a9+NWbMGLfbPWLEiOXLl9+4caPPUbKyssLP7pVXXsnIyPj3v/8daiJAeGGWQMfMMR601nbKF2sMWMnl8/mOHj26du3aQ4cOpaamVlZWTpkyRQnY4na5XL29vfo9t36vqk89Hk9HR4fb7dZncyQb7729vY2NjRs3bmxvb3/vvff8Rjly5MgvfvGLY8eOdXR0KIrypS996c6dO2FmN2LEiJkzZ7788suRbj4AOraUm3LVuLRWHPxnmfWSFEUZN27crl27rl69WlFRsWDBAvWFwP0A+iFut/vWrVvq47a2Nm14dnZ2U1NTmBFDtiMpqbCwcMuWLXV1dYGjFBUVzZ07t6mp6c6dO9evX797926Y2SmKUltb+9e//nXjxo19zhcApPZ5DcSeWwslKYpSXFz80Ucf9fT0KLrEGjJkSGNjY6jRxo8fv2nTJq/X29LSsmjRIm34vHnznnvuuebm5o6OjrKysj4nNWnSpB07dly+fLmnp6elpWXFihWPP/544Cher3fw4MEDBw48d+7cwoULw89OUZSsrKza2to//vGP69ati/47QUJzdnUCp/Jx4YqVfD7f22+/PXLkSLfbPXbs2OrqanX7ZfPmzcnJyYruJB39Ht76+voJEya43e7c3NytW7dqr3Z3d69a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" alt="Une pile" /><figcaption>Une pile</figcaption>
</figure>
<h2 id="travail-à-faire"><span class="header-section-number">9.3</span> Travail à faire</h2>
<p>Voici du code de test, qui appelle des fonctions agissant sur des piles</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb94-1" title="1"><span class="dt">void</span> test_pile()</a>
<a class="sourceLine" id="cb94-2" title="2">{</a>
<a class="sourceLine" id="cb94-3" title="3">    <span class="kw">struct</span> Stack s;</a>
<a class="sourceLine" id="cb94-4" title="4">    stack_init(&amp; s);</a>
<a class="sourceLine" id="cb94-5" title="5">    </a>
<a class="sourceLine" id="cb94-6" title="6">    <span class="co">// empiler 10,20,30,40,50</span></a>
<a class="sourceLine" id="cb94-7" title="7">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb94-8" title="8">        stack_push (&amp;s, <span class="dv">10</span> * i);</a>
<a class="sourceLine" id="cb94-9" title="9">    }</a>
<a class="sourceLine" id="cb94-10" title="10"></a>
<a class="sourceLine" id="cb94-11" title="11">    printf(<span class="st">&quot;On devrait voir : 50 40 30 20 10</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb94-12" title="12"></a>
<a class="sourceLine" id="cb94-13" title="13">    <span class="cf">while</span> ( ! stack_is_empty (&amp;s)) {</a>
<a class="sourceLine" id="cb94-14" title="14">        printf(<span class="st">&quot;%d &quot;</span>, stack_top(&amp;s));</a>
<a class="sourceLine" id="cb94-15" title="15">        stack_pop(&amp;s);</a>
<a class="sourceLine" id="cb94-16" title="16">    };</a>
<a class="sourceLine" id="cb94-17" title="17">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb94-18" title="18">    </a>
<a class="sourceLine" id="cb94-19" title="19">    stack_free(&amp;s);</a>
<a class="sourceLine" id="cb94-20" title="20">}   </a></code></pre></div>
<p>Vous avez compris ce qu’il vous reste à faire : écrire les fonctions “<code>stack_quelque_chose</code>” pour que le code affiche ce qui est attendu.</p>
<h2 id="limites-pratiques-de-cette-représentation"><span class="header-section-number">9.4</span> Limites pratiques de cette représentation</h2>
<p>La représentation d’une pile par une liste chaînée a quelques inconvénients, elle est par exemple <strong>extrêmement inefficace</strong> pour représenter une “pile de caractères” (ou autres données de petite taille).</p>
<p>Il y a plusieurs raisons.</p>
<p><strong>La place perdue</strong></p>
<ul>
<li>Un <code>char</code> occupe 1 octet. Il faut lui ajouter un pointeur, qui occupe (sur une machine 64 bits) 8 octets.</li>
<li>Qui plus est, la taille de l’<code>Element</code> est arrondie pour des contraintes techniques (alignement de données). Ce ne sont pas 9 octets, mais 16. Faites afficher <code>sizeof(struct Element)</code> pour voir.</li>
<li>Et ce n’est pas fini : pour chaque allocation il y a quelques octets supplémentaires réservés pour la gestion des blocs occupés, la taille effectivement allouée est arrondie (par le haut) à un multiple de 32.</li>
</ul>
<p>Une simple boucle permet de voir ce phénomène :</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb95-1" title="1"><span class="cf">for</span> (<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;<span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb95-2" title="2">    printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, malloc(<span class="dv">1</span>));  <span class="co">// un seul octet</span></a>
<a class="sourceLine" id="cb95-3" title="3">}</a></code></pre></div>
<p>qui affiche les adresses successives pour des allocations d’un octet chacune</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb96-1" title="1"><span class="bn">0x168b010</span></a>
<a class="sourceLine" id="cb96-2" title="2"><span class="bn">0x168b030</span></a>
<a class="sourceLine" id="cb96-3" title="3"><span class="bn">0x168b050</span></a>
<a class="sourceLine" id="cb96-4" title="4"><span class="bn">0x168b070</span></a>
<a class="sourceLine" id="cb96-5" title="5"><span class="bn">0x168b090</span></a></code></pre></div>
<p>Elles sont espacées de 32 octets (0x20). Une liste chaînée de caractères “gaspille” 31 octets pour chaque caractère à stocker !</p>
<p><strong>La dispersion en mémoire</strong></p>
<ul>
<li>au gré des allocations et libérations pendant l’exécution d’un programme, il apparaît des “trous” dans la zone mémoire réservée pour l’allocation dynamique,</li>
<li>deux allocations successives (dans le temps) pourront se retrouver à des endroits distants,</li>
<li>l’éparpillement des données a une influence désastreuse sur l’utilisation de <em>caches</em> de différents niveaux qui sont là pour accélérer l’accès à la mémoire,</li>
<li>les performances d’un programme peuvent s’en trouver dégradées de façon importante.</li>
</ul>
<p>Bref, pour stocker des données de petite taille (individuellement) mais nombreuses, il est en général nettement préférable de représenter une pile par un tableau extensible (voir plus haut).</p>
<h1 id="réalisation-dune-file-queue-par-chaînage"><span class="header-section-number">10</span> Réalisation d’une file (Queue) par chaînage</h1>
<p>Une petite adaptation permet de réaliser facilement une “file d’attente” (“<em>Queue</em>” en anglais) , qui fonctionne un peu différemment d’une pile. C’est aussi une structure très utile en programmation.</p>
<p>Les opérations :</p>
<ul>
<li>y mettre des éléments (enfiler),</li>
<li>accéder à l’élément <strong>le plus ancien</strong> (pour une pile, c’était le plus récent),</li>
<li>supprimer le plus ancien,</li>
<li>et bien sûr tester si il en reste.</li>
</ul>
<h2 id="structures-de-données"><span class="header-section-number">10.1</span> Structures de données</h2>
<p>On utilise les dénominations “<em>back</em>” (pour l’arrière de la file, là où on met les éléments), et “<em>front</em>” (le premier de la file).</p>
<p>La représentation repose sur l’utilisation de deux pointeurs, un sur le premier élément de la liste, l’autre sur le dernier, ce qui facilite les ajouts à la fin.</p>
<figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAvgAAAC1CAIAAAClGRwvAAAAA3NCSVQICAjb4U/gAAAY80lEQVR4nO3dfXAU5R3A8U2E4SIB8yJcTEJCQivpKDjiTEfGtiphaqVo1cExAQGhMja8DAl1nForqENrsZCUlIrFFm1tp1Nf2jqOjo42A506jrVaILEJ9MwZQ8oJaRDkeEkI1z9Wtuu97N3t7cvz7H4/f2Que/vy7O6zz/O7377lxWIxBd6Vl5fndhFgLw5hADAwxu0CwHZ0hB5GIAsAxvLdLgAAAIBdCHQAAIBnEegAAADPItABAACeRaADAAA8i0AHAAB4FoEOAADwLAIdf3nrrbcuvfRSbz98xZK18/YmAuAMWhIREOj4y3333bdp0yYeIQgA8ImUgY6FcajxrLq6uubNmzdhwoTCwsJvfOMb+/bts2q5SLRv37558+ZZMqtcaogffuX4YR0B8TnTl+UlsGqh5rheAKG4nNEJhUJz5syZO3fuv//971AodMMNN9TX1x84cMDdUnnY8ePHx40b53YpAMBrYp/ndnHwf/mKovzlL3+ZNWtWQUHB1KlTf/nLXyrng0F9WJqXl9fW1jZlypT8/HwlIVrU/j179uz69eurq6uLi4u3bNmSdFZ6Dz300MqVK9etW1dWVlZWVtbS0rJy5cqHH344brZx/547d27jxo01NTUlJSXLly+PRqPmxvcb49165syZ5ubmSy65pKysrLm5+cyZM9o4TzzxxNSpUwsKCmbPnt3V1ZV0VqmW+NhjjwWDwdLS0tWrVw8PD6cthiVrmrhQRVEOHDiwYMGC0tLSoqKi2267bXBwUB2eWGn13n333YqKiq1bt4q2jgDiuNiXZcKg59q+fXttbe24ceMuv/zyv/3tb08//fSll16qNrk9PT3G05pun30kFotdcsklzz///OnTp/v6+r797W9r0WhccPqtb31rYGAg1bfqh40bN1533XWhUGhoaKi5uTnpyHrBYDAUCumHhEKhsrIy46Vs2bKlvr6+t7d3aGjozjvvXLdunbnx/SDVNtH+1Xbrgw8+OHfu3P7+/v7+/uuvv379+vXaOLfccks4HD5x4sTDDz98zTXXJJ1VqqXPnTv34MGDBw8enDt37kMPPZS2GLlLtdCZM2d2dHScPHnyk08+Wb169d13360ON6i0L7300qRJk/785z+Lto762Vo7Q0BeLvZlqb7SDzfoub75zW+GQqETJ0788Ic/nDBhws033/zBBx+o/1577bXG05pun/1DicViU6ZMaW9v/+ijjz73RcLu//DDDw2+VT984Qtf6OzsjF9G6i1+wQUXnDp1Sj/k5MmTY8eONV5KXV1dT0+P+jkSiVRXV5sb3w/SBjrabq2trX3//ffVz52dndOmTdPGOXTokPo5Go0WFBQknVWqpWvz7Orq0s8zVTFyl2qheseOHausrFQ/p6q027ZtKy8v//vf/25ucbauo362ls8TkJSLfVnSJELcJAY913/+8x/1s5qqSWxyDaY13T77hxKLxd59991bbrmltLT0i1/84iuvvPLZFwm7/9y5c/p/475VPwQCgbjAJXFkvaQZnYqKCuOlFBQU6OtTfn6+ufH9IG2go+1W/b47depUIBAwnkOGgU6G89TXrhylWug777wzZ86c4uJitRpccMEF6vBUlba2tvb+++83vThb11E/W8vnCUjKxb4sk4xOtj2X/t9sp6Vl0MtXFGXWrFl/+tOfjhw50tbWtnz5cnU7Jp7b0w8JBAInT55UP0ciEW34lClTQqGQwYRx6uvrn3nmGf2Q3/zmN3PmzDFeSlVVVTgc1tZhdHTU3PhQdHunvLy8t7dX/ayGmxlOaCwcDqsfent7tXka167cJV1oQ0PD0qVLQ6HQ2bNnh4aGtGqQtNIqirJ79+7nnnvuJz/5ibnF2b2OAOK42JdlIpeeKNtpaW308hVFaWxs/Ne//jUyMqLots7FF1/c3d2darKrrrpq8+bN0Wg0HA7fc8892vC77rprzZo1vb29R48ebWlpSTurDRs2/PznP29ra4tEIpFIpK2tbdu2bQ888IDxUpqamlasWNHd3T08PNzZ2dnQ0GBufP/IpNI3NjauXbtWvdZk7dq1jY2NxuMb1xBNS0vLwMDAwMBAS0vLokWLsprWtKQLjUajEydOHD9+fF9f34oVK7SRk1ZaRVEqKyt37979q1/96tFHHzWxOLvXEUAcF/uyTOTSE2U7Le3P58Risd///vfTp08PBAJXXnllR0eHGjBu2bKlqKhISZEH6+zsvPrqqwOBQHV19fbt27Vvh4eHv//971dWVhYXF7e2tiadVZy9e/feeOONhYWFiqJMmDBhz549aZcyOjra3t5eV1c3bty4GTNmvPjii+bG9wN1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" alt="Une file" /><figcaption>Une file</figcaption>
</figure>
<div class="sourceCode" id="cb97"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb97-1" title="1"><span class="kw">struct</span> Element {                  <span class="co">// ça ne change pas</span></a>
<a class="sourceLine" id="cb97-2" title="2">    <span class="dt">int</span>             value;</a>
<a class="sourceLine" id="cb97-3" title="3">    <span class="kw">struct</span> Element *next_ptr;</a>
<a class="sourceLine" id="cb97-4" title="4">};</a>
<a class="sourceLine" id="cb97-5" title="5"></a>
<a class="sourceLine" id="cb97-6" title="6"><span class="kw">struct</span> Queue {</a>
<a class="sourceLine" id="cb97-7" title="7">    <span class="kw">struct</span> Element *front_ptr,  *back_ptr;</a>
<a class="sourceLine" id="cb97-8" title="8">};</a></code></pre></div>
<h2 id="initialiser-une-file"><span class="header-section-number">10.2</span> Initialiser une file</h2>
<p>Pour initialiser une file (vide) : mettre ses deux pointeurs à <code>NULL</code> :</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb98-1" title="1"><span class="dt">void</span> queue_init(<span class="kw">struct</span> Queue *queue_ptr)</a>
<a class="sourceLine" id="cb98-2" title="2">{</a>
<a class="sourceLine" id="cb98-3" title="3">    queue_ptr-&gt;front_ptr = NULL;</a>
<a class="sourceLine" id="cb98-4" title="4">    queue_ptr-&gt;back_ptr  = NULL;</a>
<a class="sourceLine" id="cb98-5" title="5">}</a></code></pre></div>
<h2 id="pour-connaître-la-valeur-de-lélement-de-tête"><span class="header-section-number">10.3</span> Pour connaître la valeur de l’élement de tête</h2>
<div class="sourceCode" id="cb99"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb99-1" title="1"><span class="dt">int</span> queue_front(<span class="kw">struct</span> Queue *queue_ptr)</a>
<a class="sourceLine" id="cb99-2" title="2">{</a>
<a class="sourceLine" id="cb99-3" title="3">    <span class="cf">return</span> queue_ptr-&gt;value;</a>
<a class="sourceLine" id="cb99-4" title="4">}</a></code></pre></div>
<p>ça ne marchera évidemment que si la liste n’est pas vide, il faudra avoir vérifié avant.</p>
<h2 id="pour-tester-si-la-pile-est-vide"><span class="header-section-number">10.4</span> Pour tester si la pile est vide</h2>
<p>Je vous laisse écrire la fonction <code>queue_is_empty</code>, qui retourne un <code>bool</code>.</p>
<h2 id="pour-ajouterenlever-un-élément"><span class="header-section-number">10.5</span> Pour ajouter/enlever un élément</h2>
<p>C’est la fonction <code>queue_push_back</code> qui s’en occupera.</p>
<p>Remarquez qu’il y a deux cas : si la liste est vide ou pas. Dans les deux cas, il faudra allouer un nouvel <code>Element</code> (qui deviendra le dernier).</p>
<p>Mais :</p>
<ul>
<li>si la liste était vide, cet élément devient aussi le premier</li>
<li>si le liste n’était pas vide, il devient le suivant de l’ancien dernier</li>
</ul>
<p><strong>Illustration</strong> : effet de l’ajout d’une valeur -32 (à comparer au schéma précédent) dans une liste qui n’est pas vide.</p>
<figure>
<img src="data:image/png;base64,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" alt="Ajout dans une file" /><figcaption>Ajout dans une file</figcaption>
</figure>
<p>À vous d’écrire la fonction, ainsi que <code>queue_remove_front</code>. Attention, il faudra aussi prévoir le cas où la liste devient vide.</p>
<p><strong>Idée pour l’ajout</strong> : sachant que, dans un cas, il faut modifier le pointeur <code>front_ptr</code> de la file, dans l’autre le pointeur <code>next_ptr</code> du dernier élément, on peut noter l’adresse du pointeur à modifier dans un pointeur … de pointeur.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb100-1" title="1"><span class="co">// qui devra-t-on modifier ?</span></a>
<a class="sourceLine" id="cb100-2" title="2"><span class="kw">struct</span> Element  **pointer_ptr;          <span class="co">// adresse d'un pointeur</span></a>
<a class="sourceLine" id="cb100-3" title="3"></a>
<a class="sourceLine" id="cb100-4" title="4"><span class="cf">if</span> (.....front_ptr == NULL) {           <span class="co">// si pointeur de tete nul</span></a>
<a class="sourceLine" id="cb100-5" title="5">    pointer_ptr = &amp;(......front_ptr);      <span class="co">// c'est lui qu'on modifiera</span></a>
<a class="sourceLine" id="cb100-6" title="6">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb100-7" title="7">    pointer_ptr = &amp;(......next_ptr);       <span class="co">// sinon, le suivant du dernier</span></a>
<a class="sourceLine" id="cb100-8" title="8">}</a>
<a class="sourceLine" id="cb100-9" title="9"></a>
<a class="sourceLine" id="cb100-10" title="10"><span class="co">// allocation et remplissage</span></a>
<a class="sourceLine" id="cb100-11" title="11"><span class="kw">struct</span> Element new_ptr = malloc(....);</a>
<a class="sourceLine" id="cb100-12" title="12">....</a>
<a class="sourceLine" id="cb100-13" title="13"></a>
<a class="sourceLine" id="cb100-14" title="14"><span class="co">// &quot;accrochage&quot;</span></a>
<a class="sourceLine" id="cb100-15" title="15">....next_ptr = new_ptr;</a>
<a class="sourceLine" id="cb100-16" title="16">*pointer_ptr = new_ptr;               <span class="co">// modif du pointeur désigné.</span></a></code></pre></div>
<h2 id="code-de-test"><span class="header-section-number">10.6</span> Code de test</h2>
<p>Écrivez les fonctions nécessaires pour que ce code tourne correctement.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb101-1" title="1"><span class="dt">void</span> test_queue()</a>
<a class="sourceLine" id="cb101-2" title="2">{</a>
<a class="sourceLine" id="cb101-3" title="3">    <span class="kw">struct</span> Queue q;</a>
<a class="sourceLine" id="cb101-4" title="4">    queue_init(&amp; q);</a>
<a class="sourceLine" id="cb101-5" title="5">    </a>
<a class="sourceLine" id="cb101-6" title="6">    <span class="co">// ajouter 10,20,30,40,50</span></a>
<a class="sourceLine" id="cb101-7" title="7">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">5</span>; i++) {</a>
<a class="sourceLine" id="cb101-8" title="8">        queue_push_back (&amp;s, <span class="dv">10</span> * i);</a>
<a class="sourceLine" id="cb101-9" title="9">    }</a>
<a class="sourceLine" id="cb101-10" title="10"></a>
<a class="sourceLine" id="cb101-11" title="11">    printf(<span class="st">&quot;On devrait voir : 10 20 30 40 50</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb101-12" title="12"></a>
<a class="sourceLine" id="cb101-13" title="13">    <span class="cf">while</span> ( ! queue_is_empty (&amp;s)) {</a>
<a class="sourceLine" id="cb101-14" title="14">        printf(<span class="st">&quot;%d &quot;</span>, queue_front(&amp;s));</a>
<a class="sourceLine" id="cb101-15" title="15">        queue_remove_front(&amp;s);</a>
<a class="sourceLine" id="cb101-16" title="16">    };</a>
<a class="sourceLine" id="cb101-17" title="17">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb101-18" title="18">    </a>
<a class="sourceLine" id="cb101-19" title="19">    queue_free(&amp;s);</a>
<a class="sourceLine" id="cb101-20" title="20">}   </a></code></pre></div>
<h2 id="liste-à-double-chaînage"><span class="header-section-number">10.7</span> Liste à double chaînage</h2>
<p>Si on veut une structure de données où on ajoute/retire aux deux bouts (ce qu’on appelle une <code>dequeue</code> en anglais), on rend la situation symétrique avec, dans chaque élément, deux pointeurs : le précédent et le suivant.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb102-1" title="1"><span class="kw">struct</span> Element {              </a>
<a class="sourceLine" id="cb102-2" title="2">    <span class="dt">int</span>             value;</a>
<a class="sourceLine" id="cb102-3" title="3">    <span class="kw">struct</span> Element  *prev_ptr,    <span class="co">// précédent (previous)</span></a>
<a class="sourceLine" id="cb102-4" title="4">                    *next_ptr;    <span class="co">// suivant</span></a>
<a class="sourceLine" id="cb102-5" title="5">};</a>
<a class="sourceLine" id="cb102-6" title="6"></a>
<a class="sourceLine" id="cb102-7" title="7"><span class="kw">struct</span> Deueue {</a>
<a class="sourceLine" id="cb102-8" title="8">    <span class="kw">struct</span> Element *front_ptr,  *back_ptr;</a>
<a class="sourceLine" id="cb102-9" title="9">};</a></code></pre></div>
<p>Bien entendu, le précédent du premier, comme le suivant du dernier, ça sera <code>NULL</code>.</p>
<p>Je vous laisse faire un dessin, et écrire les opérations nécessaires</p>
<ul>
<li><code>dequeue_init</code>,</li>
<li><code>dequeue_push_front</code>, <code>dequeue_push_back</code>,</li>
<li><code>dequeue_is_empty</code>,</li>
<li><code>dequeue_front</code>, <code>dequeue_back</code>,</li>
<li><code>dequeue_remove_front</code>, <code>dequeue_remove_back</code>,</li>
<li><code>dequeue_free</code>,</li>
</ul>
<p>ainsi qu’un code de test.</p>
<h1 id="liste-ordonnée-priorityqueue"><span class="header-section-number">11</span> Liste ordonnée (<em>PriorityQueue</em>)</h1>
<p>Prenons l’exemple d’une structure “Agenda”. Deux opérations principales :</p>
<ul>
<li>ajouter des tâches, avec une date de réalisation</li>
<li>on veut connaître la première à effectuer</li>
</ul>
<p>et bien sûr, enlever la première, tester si il en reste, etc.</p>
<p>Une façon de faire est de conserver ces tâches dans une liste simple, mais ordonnée par date croissante. Ainsi, il sera facile d’accéder à la première tâche à effectuer : c’est celle qui est en tête.</p>
<p><strong>Note</strong>: il y a des structures de données plus efficaces que les listes pour faire ça, mais ça dépasse le cadre de ce document.</p>
<p>La difficulté ici sera d’insérer la nouvelle tâche au bon endroit dans la liste. Jusqu’ici c’était facile, on insérait toujours à un endroit connu : la tête ou la queue de liste. Là ça peut se passer au milieu. Et à quel endroit exactement ? Ça va dépendre. Juste avant le premier évènement suivant. Ou à la fin.</p>
<p>Comme ça se gâte un peu, on va dire que ça devient <em>intéressant</em>. C’est l’occasion de voir comment procéder en douceur.</p>
<h2 id="un-peu-dordre-dans-les-pensées"><span class="header-section-number">11.1</span> Un peu d’ordre dans les pensées</h2>
<p>On simplifie le problème, et on regarde comment insérer un nombre (pourquoi pas 33) dans une liste ordonnée de nombres (en ordre croissant)</p>
<ol type="1">
<li><p>En revenant sur une réflexion précédente (à propos des files/queues), ce qu’on voit, c’est que l’insertion va conduire à modifier</p>
<ul>
<li>soit le pointeur de début de liste</li>
<li>soit le pointeur “suivant” d’un des éléments existants.</li>
</ul></li>
<li><p>Quand modifie-t-on le pointeur de début de liste ?</p>
<ul>
<li>quand la liste est vide</li>
<li>quand elle n’est pas vide, et que son premier élément est plus grand que 33.</li>
</ul></li>
<li><p>dans les autres cas, le nombre 33 sera ajouté comme successeur d’un autre élément de la liste. Mais lequel ? Évidemment, il sera mis <strong>après le dernier élément inférieur</strong> à 33.</p></li>
</ol>
<h2 id="a-la-recherche-du-dernier-élément-inférieur"><span class="header-section-number">11.2</span> A la recherche du dernier élément inférieur</h2>
<p>Ça peut paraître compliqué de trouver le dernier élément inférieur, mais on peut procéder par étapes.</p>
<ol type="1">
<li><strong>Pour commencer</strong> on se donne un bout de programme qui joue avec une liste chaînée de trois éléments (11, 22, 44), et qui fait un <strong>parcours</strong></li>
</ol>
<div class="sourceCode" id="cb103"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb103-1" title="1"><span class="kw">struct</span> Element {</a>
<a class="sourceLine" id="cb103-2" title="2">    <span class="dt">int</span>             value;</a>
<a class="sourceLine" id="cb103-3" title="3">    <span class="kw">struct</span> Element *next_ptr;</a>
<a class="sourceLine" id="cb103-4" title="4">};</a>
<a class="sourceLine" id="cb103-5" title="5"></a>
<a class="sourceLine" id="cb103-6" title="6"><span class="dt">void</span> afficher_tous(<span class="kw">struct</span> Element *first_ptr)</a>
<a class="sourceLine" id="cb103-7" title="7">{</a>
<a class="sourceLine" id="cb103-8" title="8">    printf(<span class="st">&quot;Les éléments sont :</span><span class="sc">\n\t</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb103-9" title="9">    <span class="cf">for</span> (<span class="kw">struct</span> Element *p = first_ptr; p != NULL; p = p-&gt;next_ptr) {</a>
<a class="sourceLine" id="cb103-10" title="10">        printf(<span class="st">&quot; %d&quot;</span>, p-&gt;value);</a>
<a class="sourceLine" id="cb103-11" title="11">    }</a>
<a class="sourceLine" id="cb103-12" title="12">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb103-13" title="13">}</a>
<a class="sourceLine" id="cb103-14" title="14"></a>
<a class="sourceLine" id="cb103-15" title="15"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb103-16" title="16">{</a>
<a class="sourceLine" id="cb103-17" title="17">    <span class="kw">struct</span> Element z = { <span class="dv">44</span>, NULL};</a>
<a class="sourceLine" id="cb103-18" title="18">    <span class="kw">struct</span> Element y = { <span class="dv">22</span>, &amp;z};</a>
<a class="sourceLine" id="cb103-19" title="19">    <span class="kw">struct</span> Element x = { <span class="dv">11</span>, &amp;y };</a>
<a class="sourceLine" id="cb103-20" title="20">        </a>
<a class="sourceLine" id="cb103-21" title="21">    afficher_tous(&amp; x);</a>
<a class="sourceLine" id="cb103-22" title="22">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb103-23" title="23">}</a></code></pre></div>
<p>La construction de la liste est un peu expéditive, elle ne fait pas appel à l’allocation dynamique, mais on a des éléments chaînes, c’est tout ce qui nous intéresse.</p>
<p>Ce qu’il faut voir, c’est la boucle <code>for</code>, qui passe en revue tous les éléments, vous la connaissiez déjà.</p>
<ol start="2" type="1">
<li>Maintenant, comment faire <strong>afficher tous les éléments plus petits</strong> qu’une certaine valeur ? Voila du code de test</li>
</ol>
<div class="sourceCode" id="cb104"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb104-1" title="1">    afficher_plus_petits_que(&amp; x, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb104-2" title="2">    afficher_plus_petits_que(&amp; x, <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb104-3" title="3">    afficher_plus_petits_que(&amp; x, <span class="dv">33</span>);</a>
<a class="sourceLine" id="cb104-4" title="4">    afficher_plus_petits_que(&amp; x, <span class="dv">99</span>);</a></code></pre></div>
<p>C’est simple : dans la même boucle, on va sortir dès que la valeur limite est atteinte. Ça fera l’affaire parce que la liste est ordonnée : si une valeur dépasse, le reste de la liste aussi.</p>
<p>On utilise sans vergogne un <code>break</code>, qui, n’en déplaise aux esprits chagrins, est là pour ça :</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb105-1" title="1"><span class="dt">void</span> afficher_plus_petits_que(<span class="kw">struct</span> Element *first_ptr, <span class="dt">int</span> value)</a>
<a class="sourceLine" id="cb105-2" title="2">{</a>
<a class="sourceLine" id="cb105-3" title="3">    printf(<span class="st">&quot;Les éléments plus petits que %d sont :</span><span class="sc">\n\t</span><span class="st">&quot;</span>, value);</a>
<a class="sourceLine" id="cb105-4" title="4">    <span class="cf">for</span> (<span class="kw">struct</span> Element *p = first_ptr; p != NULL; p = p-&gt;next_ptr) {</a>
<a class="sourceLine" id="cb105-5" title="5">        <span class="cf">if</span> (p-&gt;value &gt;= value) {                        <span class="co">// on a dépassé ?</span></a>
<a class="sourceLine" id="cb105-6" title="6">            <span class="cf">break</span>;                                      <span class="co">// alors on arrête</span></a>
<a class="sourceLine" id="cb105-7" title="7">        }</a>
<a class="sourceLine" id="cb105-8" title="8">        printf(<span class="st">&quot; %d&quot;</span>, p-&gt;value);</a>
<a class="sourceLine" id="cb105-9" title="9">    }</a>
<a class="sourceLine" id="cb105-10" title="10">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb105-11" title="11">    }</a></code></pre></div>
<p>remarquez que si il n’y en a pas, et bien ça n’affiche rien. Ça peut arriver, bien sûr.</p>
<ol start="3" type="1">
<li>Encore un petit effort, comment trouver <strong>le dernier élément qui</strong> <strong>soit plus petit</strong> que la valeur ?</li>
</ol>
<p>L’idée va être de <em>noter</em> (dans un pointeur) la position du dernier élément plus petit rencontré jusque là.</p>
<p>Pour cela on définit un pointeur</p>
<ul>
<li>initialisé à <code>NULL</code> au départ (on n’a pas encore rencontré d’élément)</li>
<li>mis à jour chaque fois qu’on rencontre un meilleur élément (dans la boucle)</li>
<li>qu’on utilisera après la boucle.</li>
</ul>
<div class="sourceCode" id="cb106"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb106-1" title="1"><span class="dt">void</span> afficher_dernier_plus_petit(<span class="kw">struct</span> Element *first_ptr, <span class="dt">int</span> value)</a>
<a class="sourceLine" id="cb106-2" title="2">{</a>
<a class="sourceLine" id="cb106-3" title="3">    printf(<span class="st">&quot;Le dernier élément &lt; à %d est :</span><span class="sc">\n\t</span><span class="st">&quot;</span>, value);</a>
<a class="sourceLine" id="cb106-4" title="4"></a>
<a class="sourceLine" id="cb106-5" title="5">    <span class="kw">struct</span> Element *last = NULL;</a>
<a class="sourceLine" id="cb106-6" title="6">    <span class="cf">for</span> (<span class="kw">struct</span> Element *p = first_ptr; p != NULL; p = p-&gt;next_ptr) {</a>
<a class="sourceLine" id="cb106-7" title="7">        <span class="cf">if</span> (p-&gt;value &gt;= value) {</a>
<a class="sourceLine" id="cb106-8" title="8">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb106-9" title="9">        }</a>
<a class="sourceLine" id="cb106-10" title="10">        last = p;</a>
<a class="sourceLine" id="cb106-11" title="11">    }</a>
<a class="sourceLine" id="cb106-12" title="12"></a>
<a class="sourceLine" id="cb106-13" title="13">    <span class="cf">if</span> (last != NULL) {               <span class="co">// si on a trouvé un élement</span></a>
<a class="sourceLine" id="cb106-14" title="14">        printf(<span class="st">&quot;%d&quot;</span>, last-&gt;value);    <span class="co">// on affiche sa valeur</span></a>
<a class="sourceLine" id="cb106-15" title="15">    }</a>
<a class="sourceLine" id="cb106-16" title="16">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb106-17" title="17">}</a></code></pre></div>
<h2 id="insertion"><span class="header-section-number">11.3</span> Insertion</h2>
<p>On en revient à notre problème : pour insérer un élément dans la liste</p>
<ol type="1">
<li>On alloue un nouvel <code>Element</code>.</li>
<li>On cherche l’adresse du dernier élément plus petit.</li>
<li>On accroche le nouvel élément
<ul>
<li>derrière (<code>next_ptr</code>) le dernier plus petit si il y en a un,</li>
<li>au début de la liste sinon (<code>first_ptr</code>).</li>
</ul></li>
</ol>
<h1 id="conclusion"><span class="header-section-number">12</span> Conclusion</h1>
<p>La notion de <strong>pointeur</strong> est en fait très simple : une <strong>variable contenant l’adresse</strong> de quelque chose.</p>
<p>Mais elle est utilisée pour beaucoup de choses, ce qu’il fait qu’il y a une multitude de domaines connexes à étudier pour prétendre qu’on sait “programmer en C avec des pointeurs”.</p>
<p>L’<strong>allocation dynamique</strong> est un mécanisme fondamental pour le développement de la plupart des applications. En elle-même rien de compliqué non plus : c’est juste demander au système d’exploitation de <strong>réserver</strong> un certain nombre d’octets, et évidemment de nous dire où ils se trouvent (en retournant un pointeur). Et les <strong>libérer</strong> quand on n’en n’a plus besoin. La difficulté pratique est de faire la libération au bon moment : pas trop tôt (libération prématurée alors qu’on en aura encore besoin), pas trop tard (parce que ça fera une fuite mémoire), et pas deux fois…</p>
<p>Ce qui est plus compliqué, c’est d’arriver à s’en servir pour <strong>réaliser des structures de données</strong> qui peuvent effectuer un certain nombre d’opérations (pour un conteneur : ajouter des éléments, etc). Et la réalisation de ces opérations nécessite des compétences algorithmiques.</p>
<p>Bien entendu, les structures de données ne se limitent pas aux tableaux extensibles et aux listes chaînées (ou doublement chaînées) que j’ai choisi pour illustrer l’usage des pointeurs, il y en a beaucoup d’autres (arbres, graphes, etc).</p>
<p>En espérant que ce document vous sera utile !</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Le terme “programmation système” est mal défini. Historiquement ça désignait le code de que l’on écrit, non pas pour réaliser des applications directement, mais pour aider d’autres programmeurs à réaliser des applications, en faisant appel à des mécanismes un peu techniques liés au système d’exploitation. Ou en modifiant le système d’exploitation. Maintenant on l’emploie un peu à tort et à travers, dès que, dans un programme, on appelle une fonction de la bibliothèque du système (comme <code>fork</code>, <code>pipe</code>, <code>signal</code>, …).<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
